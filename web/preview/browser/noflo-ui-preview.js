
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("component-emitter/index.js", function(exports, require, module){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

});
require.register("component-underscore/index.js", function(exports, require, module){
//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.3.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = _.toArray(obj).reverse();
    if (context && !initial) iterator = _.bind(iterator, context);
    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    var found = false;
    if (obj == null) return found;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    found = any(obj, function(value) {
      return value === target;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = Math.floor(Math.random() * ++index);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, val, context) {
    var iterator = lookupIterator(obj, val);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      if (a === void 0) return 1;
      if (b === void 0) return -1;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(obj, val) {
    return _.isFunction(val) ? val : function(obj) { return obj[val]; };
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, val, behavior) {
    var result = {};
    var iterator = lookupIterator(obj, val);
    each(obj, function(value, index) {
      var key = iterator(value, index);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, val) {
    return group(obj, val, function(result, key, value) {
      (result[key] || (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, val) {
    return group(obj, val, function(result, key, value) {
      result[key] || (result[key] = 0);
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var value = iterator(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj)                                     return [];
    if (_.isArray(obj))                           return slice.call(obj);
    if (_.isArguments(obj))                       return slice.call(obj);
    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.isArray(obj) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, (index == null) || guard ? 1 : index);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var results = [];
    _.reduce(initial, function(memo, value, index) {
      if (isSorted ? (_.last(memo) !== value || !memo.length) : !_.include(memo, value)) {
        memo.push(value);
        results.push(array[index]);
      }
      return memo;
    }, []);
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, []));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(slice.call(arguments, 1), true, []);
    return _.filter(array, function(value){ return !_.include(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Zip together two arrays -- an array of keys and an array of values -- into
  // a single object.
  _.zipObject = function(keys, values) {
    var result = {};
    for (var i = 0, l = keys.length; i < l; i++) {
      result[keys[i]] = values[i];
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i, l;
    if (isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (array == null) return -1;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, throttling, more, result;
    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
    return function() {
      context = this; args = arguments;
      var later = function() {
        timeout = null;
        if (more) func.apply(context, args);
        whenDone();
      };
      if (!timeout) timeout = setTimeout(later, wait);
      if (throttling) {
        more = true;
      } else {
        throttling = true;
        result = func.apply(context, args);
      }
      whenDone();
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      return memo = func.apply(this, arguments);
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var result = {};
    each(flatten(slice.call(arguments, 1), true, []), function(key) {
      if (key in obj) result[key] = obj[key];
    });
    return result;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, stack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a._chain) a = a._wrapped;
    if (b._chain) b = b._wrapped;
    // Invoke a custom `isEqual` method if one is provided.
    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = stack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (stack[length] == a) return true;
    }
    // Add the first object to the stack of traversed objects.
    stack.push(a);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          // Ensure commutative equality for sparse arrays.
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent.
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    stack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return _.isNumber(obj) && isFinite(obj);
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    // `NaN` is the only value for which `===` is not reflexive.
    return obj !== obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // List of HTML entities for escaping.
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  };

  // Regex containing the keys listed immediately above.
  var htmlEscaper = /[&<>"'\/]/g;

  // Escape a string for HTML interpolation.
  _.escape = function(string) {
    return ('' + string).replace(htmlEscaper, function(match) {
      return htmlEscapes[match];
    });
  };

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /.^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    '\\':   '\\',
    "'":    "'",
    r:      '\r',
    n:      '\n',
    t:      '\t',
    u2028:  '\u2028',
    u2029:  '\u2029'
  };

  for (var key in escapes) escapes[escapes[key]] = key;
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

  // Within an interpolation, evaluation, or escaping, remove HTML escaping
  // that had been previously added.
  var unescape = function(code) {
    return code.replace(unescaper, function(match, escape) {
      return escapes[escape];
    });
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults(settings || {}, _.templateSettings);

    // Compile the template source, taking care to escape characters that
    // cannot be included in a string literal and then unescape them in code
    // blocks.
    var source = "__p+='" + text
      .replace(escaper, function(match) {
        return '\\' + escapes[match];
      })
      .replace(settings.escape || noMatch, function(match, code) {
        return "'+\n((__t=(" + unescape(code) + "))==null?'':_.escape(__t))+\n'";
      })
      .replace(settings.interpolate || noMatch, function(match, code) {
        return "'+\n((__t=(" + unescape(code) + "))==null?'':__t)+\n'";
      })
      .replace(settings.evaluate || noMatch, function(match, code) {
        return "';\n" + unescape(code) + "\n__p+='";
      }) + "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'')};\n" +
      source + "return __p;\n";

    var render = new Function(settings.variable || 'obj', '_', source);
    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result(obj, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

}).call(this);

});
require.register("noflo-fbp/lib/fbp.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "line": parse_line,
        "LineTerminator": parse_LineTerminator,
        "comment": parse_comment,
        "connection": parse_connection,
        "bridge": parse_bridge,
        "leftlet": parse_leftlet,
        "iip": parse_iip,
        "rightlet": parse_rightlet,
        "node": parse_node,
        "component": parse_component,
        "compMeta": parse_compMeta,
        "port": parse_port,
        "anychar": parse_anychar,
        "iipchar": parse_iipchar,
        "_": parse__,
        "__": parse___
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_line();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_line();
        }
        if (result0 !== null) {
          result0 = (function(offset) { return parser.getResult();  })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_line() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 7) === "EXPORT=") {
            result1 = "EXPORT=";
            pos += 7;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"EXPORT=\"");
            }
          }
          if (result1 !== null) {
            if (/^[A-Za-z.0-9_]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Za-z.0-9_]");
              }
            }
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                if (/^[A-Za-z.0-9_]/.test(input.charAt(pos))) {
                  result3 = input.charAt(pos);
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[A-Za-z.0-9_]");
                  }
                }
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result3 = ":";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result3 !== null) {
                if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                  result5 = input.charAt(pos);
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("[A-Z0-9_]");
                  }
                }
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                      result5 = input.charAt(pos);
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("[A-Z0-9_]");
                      }
                    }
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result5 = parse__();
                  if (result5 !== null) {
                    result6 = parse_LineTerminator();
                    result6 = result6 !== null ? result6 : "";
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, priv, pub) {return parser.registerExports(priv.join(""),pub.join(""))})(pos0, result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse__();
          if (result0 !== null) {
            if (input.substr(pos, 7) === "INPORT=") {
              result1 = "INPORT=";
              pos += 7;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"INPORT=\"");
              }
            }
            if (result1 !== null) {
              if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[A-Za-z0-9_]");
                }
              }
              if (result3 !== null) {
                result2 = [];
                while (result3 !== null) {
                  result2.push(result3);
                  if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                    result3 = input.charAt(pos);
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("[A-Za-z0-9_]");
                    }
                  }
                }
              } else {
                result2 = null;
              }
              if (result2 !== null) {
                if (input.charCodeAt(pos) === 46) {
                  result3 = ".";
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result3 !== null) {
                  if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                    result5 = input.charAt(pos);
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[A-Z0-9_]");
                    }
                  }
                  if (result5 !== null) {
                    result4 = [];
                    while (result5 !== null) {
                      result4.push(result5);
                      if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                        result5 = input.charAt(pos);
                        pos++;
                      } else {
                        result5 = null;
                        if (reportFailures === 0) {
                          matchFailed("[A-Z0-9_]");
                        }
                      }
                    }
                  } else {
                    result4 = null;
                  }
                  if (result4 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result5 = ":";
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result5 !== null) {
                      if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                        result7 = input.charAt(pos);
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("[A-Z0-9_]");
                        }
                      }
                      if (result7 !== null) {
                        result6 = [];
                        while (result7 !== null) {
                          result6.push(result7);
                          if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                            result7 = input.charAt(pos);
                            pos++;
                          } else {
                            result7 = null;
                            if (reportFailures === 0) {
                              matchFailed("[A-Z0-9_]");
                            }
                          }
                        }
                      } else {
                        result6 = null;
                      }
                      if (result6 !== null) {
                        result7 = parse__();
                        if (result7 !== null) {
                          result8 = parse_LineTerminator();
                          result8 = result8 !== null ? result8 : "";
                          if (result8 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, node, port, pub) {return parser.registerInports(node.join(""),port.join(""),pub.join(""))})(pos0, result0[2], result0[4], result0[6]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse__();
            if (result0 !== null) {
              if (input.substr(pos, 8) === "OUTPORT=") {
                result1 = "OUTPORT=";
                pos += 8;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"OUTPORT=\"");
                }
              }
              if (result1 !== null) {
                if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                  result3 = input.charAt(pos);
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[A-Za-z0-9_]");
                  }
                }
                if (result3 !== null) {
                  result2 = [];
                  while (result3 !== null) {
                    result2.push(result3);
                    if (/^[A-Za-z0-9_]/.test(input.charAt(pos))) {
                      result3 = input.charAt(pos);
                      pos++;
                    } else {
                      result3 = null;
                      if (reportFailures === 0) {
                        matchFailed("[A-Za-z0-9_]");
                      }
                    }
                  }
                } else {
                  result2 = null;
                }
                if (result2 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result3 = ".";
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  if (result3 !== null) {
                    if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                      result5 = input.charAt(pos);
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("[A-Z0-9_]");
                      }
                    }
                    if (result5 !== null) {
                      result4 = [];
                      while (result5 !== null) {
                        result4.push(result5);
                        if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                          result5 = input.charAt(pos);
                          pos++;
                        } else {
                          result5 = null;
                          if (reportFailures === 0) {
                            matchFailed("[A-Z0-9_]");
                          }
                        }
                      }
                    } else {
                      result4 = null;
                    }
                    if (result4 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result5 = ":";
                        pos++;
                      } else {
                        result5 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result5 !== null) {
                        if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                          result7 = input.charAt(pos);
                          pos++;
                        } else {
                          result7 = null;
                          if (reportFailures === 0) {
                            matchFailed("[A-Z0-9_]");
                          }
                        }
                        if (result7 !== null) {
                          result6 = [];
                          while (result7 !== null) {
                            result6.push(result7);
                            if (/^[A-Z0-9_]/.test(input.charAt(pos))) {
                              result7 = input.charAt(pos);
                              pos++;
                            } else {
                              result7 = null;
                              if (reportFailures === 0) {
                                matchFailed("[A-Z0-9_]");
                              }
                            }
                          }
                        } else {
                          result6 = null;
                        }
                        if (result6 !== null) {
                          result7 = parse__();
                          if (result7 !== null) {
                            result8 = parse_LineTerminator();
                            result8 = result8 !== null ? result8 : "";
                            if (result8 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, node, port, pub) {return parser.registerOutports(node.join(""),port.join(""),pub.join(""))})(pos0, result0[2], result0[4], result0[6]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              result0 = parse_comment();
              if (result0 !== null) {
                if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
                  result1 = input.charAt(pos);
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\n\\r\\u2028\\u2029]");
                  }
                }
                result1 = result1 !== null ? result1 : "";
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                result0 = parse__();
                if (result0 !== null) {
                  if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
                    result1 = input.charAt(pos);
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\n\\r\\u2028\\u2029]");
                    }
                  }
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  pos1 = pos;
                  result0 = parse__();
                  if (result0 !== null) {
                    result1 = parse_connection();
                    if (result1 !== null) {
                      result2 = parse__();
                      if (result2 !== null) {
                        result3 = parse_LineTerminator();
                        result3 = result3 !== null ? result3 : "";
                        if (result3 !== null) {
                          result0 = [result0, result1, result2, result3];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                  if (result0 !== null) {
                    result0 = (function(offset, edges) {return parser.registerEdges(edges);})(pos0, result0[1]);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_comment();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\n\\r\\u2028\\u2029]");
                }
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 35) {
            result1 = "#";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"#\"");
            }
          }
          if (result1 !== null) {
            result2 = [];
            result3 = parse_anychar();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_anychar();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_connection() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_bridge();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            if (input.substr(pos, 2) === "->") {
              result2 = "->";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"->\"");
              }
            }
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                result4 = parse_connection();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, x, y) { return [x,y]; })(pos0, result0[0], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_bridge();
        }
        return result0;
      }
      
      function parse_bridge() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_port();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_node();
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                result4 = parse_port();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, x, proc, y) { return [{"tgt":{process:proc, port:x}},{"src":{process:proc, port:y}}]; })(pos0, result0[0], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_iip();
          if (result0 === null) {
            result0 = parse_rightlet();
            if (result0 === null) {
              result0 = parse_leftlet();
            }
          }
        }
        return result0;
      }
      
      function parse_leftlet() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_node();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, proc, port) { return {"src":{process:proc, port:port}} })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_iip() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 39) {
          result0 = "'";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"'\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_iipchar();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_iipchar();
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 39) {
              result2 = "'";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, iip) { return {"data":iip.join("")} })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rightlet() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_port();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_node();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, port, proc) { return {"tgt":{process:proc, port:port}} })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_node() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z0-9_]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_component();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, node, comp) { if(comp){parser.addNode(node.join(""),comp);}; return node.join("")})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_component() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          if (/^[a-zA-Z\/\-0-9_]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[a-zA-Z\\/\\-0-9_]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[a-zA-Z\/\-0-9_]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[a-zA-Z\\/\\-0-9_]");
                }
              }
            }
          } else {
            result1 = null;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_compMeta();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 41) {
                result3 = ")";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\")\"");
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, comp, meta) { var o = {}; comp ? o.comp = comp.join("") : o.comp = ''; meta ? o.meta = meta.join("").split(',') : null; return o; })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_compMeta() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          if (/^[a-zA-Z\/]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[a-zA-Z\\/]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[a-zA-Z\/]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[a-zA-Z\\/]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, meta) {return meta})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_port() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[A-Z.0-9_]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z.0-9_]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[A-Z.0-9_]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[A-Z.0-9_]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, portname) {return portname.join("").toLowerCase()})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_anychar() {
        var result0;
        
        if (/^[^\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_iipchar() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[\\]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\\\]");
          }
        }
        if (result0 !== null) {
          if (/^[']/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[']");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "'"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          if (/^[^']/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[^']");
            }
          }
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        if (input.charCodeAt(pos) === 32) {
          result1 = " ";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (input.charCodeAt(pos) === 32) {
            result1 = " ";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        if (input.charCodeAt(pos) === 32) {
          result1 = " ";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (input.charCodeAt(pos) === 32) {
              result1 = " ";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\" \"");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var parser, edges, nodes; 
      
        parser = this;
        delete parser.exports;
        delete parser.inports;
        delete parser.outports;
      
        edges = parser.edges = [];
      
        nodes = {};
      
        parser.addNode = function (nodeName, comp) {
          if (!nodes[nodeName]) {
            nodes[nodeName] = {}
          }
          if (!!comp.comp) {
            nodes[nodeName].component = comp.comp;
          }
          if (!!comp.meta) {
            nodes[nodeName].metadata={routes:comp.meta};
          }
         
        }
      
        parser.getResult = function () {
          return {processes:nodes, connections:parser.processEdges(), exports:parser.exports, inports: parser.inports, outports: parser.outports};
        }  
      
        var flatten = function (array, isShallow) {
          var index = -1,
            length = array ? array.length : 0,
            result = [];
      
          while (++index < length) {
            var value = array[index];
      
            if (value instanceof Array) {
              Array.prototype.push.apply(result, isShallow ? value : flatten(value));
            }
            else {
              result.push(value);
            }
          }
          return result;
        }
        
        parser.registerExports = function (priv, pub) {
          if (!parser.exports) {
            parser.exports = [];
          }
          parser.exports.push({private:priv.toLowerCase(), public:pub.toLowerCase()})
        }
        parser.registerInports = function (node, port, pub) {
          if (!parser.inports) {
            parser.inports = {};
          }
          parser.inports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
        }
        parser.registerOutports = function (node, port, pub) {
          if (!parser.outports) {
            parser.outports = {};
          }
          parser.outports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
        }
      
        parser.registerEdges = function (edges) {
      
          edges.forEach(function (o, i) {
            parser.edges.push(o);
          });
        }  
      
        parser.processEdges = function () {   
          var flats, grouped;
          flats = flatten(parser.edges);
          grouped = [];
          var current = {};
          flats.forEach(function (o, i) {
            if (i % 2 !== 0) { 
              var pair = grouped[grouped.length - 1];
              pair.tgt = o.tgt;
              return;
            }
            grouped.push(o);
          });
          return grouped;
        }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("noflo-noflo/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo","description":"Flow-Based Programming environment for JavaScript","keywords":["fbp","workflow","flow"],"repo":"noflo/noflo","version":"0.4.1","dependencies":{"component/emitter":"*","component/underscore":"*","noflo/fbp":"*"},"development":{},"license":"MIT","main":"src/lib/NoFlo.js","scripts":["src/lib/Graph.coffee","src/lib/InternalSocket.coffee","src/lib/BasePort.coffee","src/lib/InPort.coffee","src/lib/OutPort.coffee","src/lib/Ports.coffee","src/lib/Port.coffee","src/lib/ArrayPort.coffee","src/lib/Component.coffee","src/lib/AsyncComponent.coffee","src/lib/LoggingComponent.coffee","src/lib/ComponentLoader.coffee","src/lib/NoFlo.coffee","src/lib/Network.coffee","src/lib/Platform.coffee","src/lib/Journal.coffee","src/lib/Utils.coffee","src/components/Graph.coffee"],"json":["component.json"],"noflo":{"components":{"Graph":"src/components/Graph.js"}}}');
});
require.register("noflo-noflo/src/lib/Graph.js", function(exports, require, module){
var EventEmitter, Graph, clone,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

clone = require('./Utils').clone;

Graph = (function(_super) {
  __extends(Graph, _super);

  Graph.prototype.name = '';

  Graph.prototype.properties = {};

  Graph.prototype.nodes = [];

  Graph.prototype.edges = [];

  Graph.prototype.initializers = [];

  Graph.prototype.exports = [];

  Graph.prototype.inports = {};

  Graph.prototype.outports = {};

  Graph.prototype.groups = [];

  function Graph(name) {
    this.name = name != null ? name : '';
    this.properties = {};
    this.nodes = [];
    this.edges = [];
    this.initializers = [];
    this.exports = [];
    this.inports = {};
    this.outports = {};
    this.groups = [];
    this.transaction = {
      id: null,
      depth: 0
    };
  }

  Graph.prototype.startTransaction = function(id, metadata) {
    if (this.transaction.id) {
      throw Error("Nested transactions not supported");
    }
    this.transaction.id = id;
    this.transaction.depth = 1;
    return this.emit('startTransaction', id, metadata);
  };

  Graph.prototype.endTransaction = function(id, metadata) {
    if (!this.transaction.id) {
      throw Error("Attempted to end non-existing transaction");
    }
    this.transaction.id = null;
    this.transaction.depth = 0;
    return this.emit('endTransaction', id, metadata);
  };

  Graph.prototype.checkTransactionStart = function() {
    if (!this.transaction.id) {
      return this.startTransaction('implicit');
    } else if (this.transaction.id === 'implicit') {
      return this.transaction.depth += 1;
    }
  };

  Graph.prototype.checkTransactionEnd = function() {
    if (this.transaction.id === 'implicit') {
      this.transaction.depth -= 1;
    }
    if (this.transaction.depth === 0) {
      return this.endTransaction('implicit');
    }
  };

  Graph.prototype.setProperties = function(properties) {
    var before, item, val;
    this.checkTransactionStart();
    before = clone(this.properties);
    for (item in properties) {
      val = properties[item];
      this.properties[item] = val;
    }
    this.emit('changeProperties', this.properties, before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addExport = function(publicPort, nodeKey, portKey, metadata) {
    var exported;
    if (metadata == null) {
      metadata = {
        x: 0,
        y: 0
      };
    }
    if (!this.getNode(nodeKey)) {
      return;
    }
    this.checkTransactionStart();
    exported = {
      "public": publicPort,
      process: nodeKey,
      port: portKey,
      metadata: metadata
    };
    this.exports.push(exported);
    this.emit('addExport', exported);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeExport = function(publicPort) {
    var exported, found, idx, _i, _len, _ref;
    publicPort = publicPort.toLowerCase();
    found = null;
    _ref = this.exports;
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      exported = _ref[idx];
      if (exported["public"] === publicPort) {
        found = exported;
      }
    }
    if (!found) {
      return;
    }
    this.checkTransactionStart();
    this.exports.splice(this.exports.indexOf(found), 1);
    this.emit('removeExport', found);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addInport = function(publicPort, nodeKey, portKey, metadata) {
    if (!this.getNode(nodeKey)) {
      return;
    }
    this.checkTransactionStart();
    this.inports[publicPort] = {
      process: nodeKey,
      port: portKey,
      metadata: metadata
    };
    this.emit('addInport', publicPort, this.inports[publicPort]);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeInport = function(publicPort) {
    var port;
    publicPort = publicPort.toLowerCase();
    if (!this.inports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    port = this.inports[publicPort];
    this.setInportMetadata(publicPort, {});
    delete this.inports[publicPort];
    this.emit('removeInport', publicPort, port);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameInport = function(oldPort, newPort) {
    if (!this.inports[oldPort]) {
      return;
    }
    this.checkTransactionStart();
    this.inports[newPort] = this.inports[oldPort];
    delete this.inports[oldPort];
    this.emit('renameInport', oldPort, newPort);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setInportMetadata = function(publicPort, metadata) {
    var before, item, val;
    if (!this.inports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    before = clone(this.inports[publicPort].metadata);
    if (!this.inports[publicPort].metadata) {
      this.inports[publicPort].metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        this.inports[publicPort].metadata[item] = val;
      } else {
        delete this.inports[publicPort].metadata[item];
      }
    }
    this.emit('changeInport', publicPort, this.inports[publicPort], before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addOutport = function(publicPort, nodeKey, portKey, metadata) {
    if (!this.getNode(nodeKey)) {
      return;
    }
    this.checkTransactionStart();
    this.outports[publicPort] = {
      process: nodeKey,
      port: portKey,
      metadata: metadata
    };
    this.emit('addOutport', publicPort, this.outports[publicPort]);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeOutport = function(publicPort) {
    var port;
    publicPort = publicPort.toLowerCase();
    if (!this.outports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    port = this.outports[publicPort];
    this.setOutportMetadata(publicPort, {});
    delete this.outports[publicPort];
    this.emit('removeOutport', publicPort, port);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameOutport = function(oldPort, newPort) {
    if (!this.outports[oldPort]) {
      return;
    }
    this.checkTransactionStart();
    this.outports[newPort] = this.outports[oldPort];
    delete this.outports[oldPort];
    this.emit('renameOutport', oldPort, newPort);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setOutportMetadata = function(publicPort, metadata) {
    var before, item, val;
    if (!this.outports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    before = clone(this.outports[publicPort].metadata);
    if (!this.outports[publicPort].metadata) {
      this.outports[publicPort].metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        this.outports[publicPort].metadata[item] = val;
      } else {
        delete this.outports[publicPort].metadata[item];
      }
    }
    this.emit('changeOutport', publicPort, this.outports[publicPort], before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addGroup = function(group, nodes, metadata) {
    var g;
    this.checkTransactionStart();
    g = {
      name: group,
      nodes: nodes,
      metadata: metadata
    };
    this.groups.push(g);
    this.emit('addGroup', g);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameGroup = function(oldName, newName) {
    var group, _i, _len, _ref;
    this.checkTransactionStart();
    _ref = this.groups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      if (!group) {
        continue;
      }
      if (group.name !== oldName) {
        continue;
      }
      group.name = newName;
      this.emit('renameGroup', oldName, newName);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeGroup = function(groupName) {
    var group, _i, _len, _ref;
    this.checkTransactionStart();
    _ref = this.groups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      if (!group) {
        continue;
      }
      if (group.name !== groupName) {
        continue;
      }
      this.setGroupMetadata(group.name, {});
      this.groups.splice(this.groups.indexOf(group), 1);
      this.emit('removeGroup', group);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.setGroupMetadata = function(groupName, metadata) {
    var before, group, item, val, _i, _len, _ref;
    this.checkTransactionStart();
    _ref = this.groups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      if (!group) {
        continue;
      }
      if (group.name !== groupName) {
        continue;
      }
      before = clone(group.metadata);
      for (item in metadata) {
        val = metadata[item];
        if (val != null) {
          group.metadata[item] = val;
        } else {
          delete group.metadata[item];
        }
      }
      this.emit('changeGroup', group, before);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.addNode = function(id, component, metadata) {
    var node;
    this.checkTransactionStart();
    if (!metadata) {
      metadata = {};
    }
    node = {
      id: id,
      component: component,
      metadata: metadata
    };
    this.nodes.push(node);
    this.emit('addNode', node);
    this.checkTransactionEnd();
    return node;
  };

  Graph.prototype.removeNode = function(id) {
    var edge, exported, group, index, initializer, node, priv, pub, toRemove, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    node = this.getNode(id);
    if (!node) {
      return;
    }
    this.checkTransactionStart();
    toRemove = [];
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      if ((edge.from.node === node.id) || (edge.to.node === node.id)) {
        toRemove.push(edge);
      }
    }
    for (_j = 0, _len1 = toRemove.length; _j < _len1; _j++) {
      edge = toRemove[_j];
      this.removeEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port);
    }
    toRemove = [];
    _ref1 = this.initializers;
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      initializer = _ref1[_k];
      if (initializer.to.node === node.id) {
        toRemove.push(initializer);
      }
    }
    for (_l = 0, _len3 = toRemove.length; _l < _len3; _l++) {
      initializer = toRemove[_l];
      this.removeInitial(initializer.to.node, initializer.to.port);
    }
    toRemove = [];
    _ref2 = this.exports;
    for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
      exported = _ref2[_m];
      if (id.toLowerCase() === exported.process) {
        toRemove.push(exported);
      }
    }
    for (_n = 0, _len5 = toRemove.length; _n < _len5; _n++) {
      exported = toRemove[_n];
      this.removeExports(exported["public"]);
    }
    toRemove = [];
    _ref3 = this.inports;
    for (pub in _ref3) {
      priv = _ref3[pub];
      if (priv.process === id) {
        toRemove.push(pub);
      }
    }
    for (_o = 0, _len6 = toRemove.length; _o < _len6; _o++) {
      pub = toRemove[_o];
      this.removeInport(pub);
    }
    toRemove = [];
    _ref4 = this.outports;
    for (pub in _ref4) {
      priv = _ref4[pub];
      if (priv.process === id) {
        toRemove.push(pub);
      }
    }
    for (_p = 0, _len7 = toRemove.length; _p < _len7; _p++) {
      pub = toRemove[_p];
      this.removeOutport(pub);
    }
    _ref5 = this.groups;
    for (_q = 0, _len8 = _ref5.length; _q < _len8; _q++) {
      group = _ref5[_q];
      if (!group) {
        continue;
      }
      index = group.nodes.indexOf(id);
      if (index === -1) {
        continue;
      }
      group.nodes.splice(index, 1);
    }
    this.setNodeMetadata(id, {});
    if (-1 !== this.nodes.indexOf(node)) {
      this.nodes.splice(this.nodes.indexOf(node), 1);
    }
    this.emit('removeNode', node);
    return this.checkTransactionEnd();
  };

  Graph.prototype.getNode = function(id) {
    var node, _i, _len, _ref;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!node) {
        continue;
      }
      if (node.id === id) {
        return node;
      }
    }
    return null;
  };

  Graph.prototype.renameNode = function(oldId, newId) {
    var edge, exported, group, iip, index, node, priv, pub, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    this.checkTransactionStart();
    node = this.getNode(oldId);
    if (!node) {
      return;
    }
    node.id = newId;
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      if (!edge) {
        continue;
      }
      if (edge.from.node === oldId) {
        edge.from.node = newId;
      }
      if (edge.to.node === oldId) {
        edge.to.node = newId;
      }
    }
    _ref1 = this.initializers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      iip = _ref1[_j];
      if (!iip) {
        continue;
      }
      if (iip.to.node === oldId) {
        iip.to.node = newId;
      }
    }
    _ref2 = this.inports;
    for (pub in _ref2) {
      priv = _ref2[pub];
      if (priv.process === oldId) {
        priv.process = newId;
      }
    }
    _ref3 = this.outports;
    for (pub in _ref3) {
      priv = _ref3[pub];
      if (priv.process === oldId) {
        priv.process = newId;
      }
    }
    _ref4 = this.exports;
    for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
      exported = _ref4[_k];
      if (exported.process === oldId) {
        exported.process = newId;
      }
    }
    _ref5 = this.groups;
    for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
      group = _ref5[_l];
      if (!group) {
        continue;
      }
      index = group.nodes.indexOf(oldId);
      if (index === -1) {
        continue;
      }
      group.nodes[index] = newId;
    }
    this.emit('renameNode', oldId, newId);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setNodeMetadata = function(id, metadata) {
    var before, item, node, val;
    node = this.getNode(id);
    if (!node) {
      return;
    }
    this.checkTransactionStart();
    before = clone(node.metadata);
    if (!node.metadata) {
      node.metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        node.metadata[item] = val;
      } else {
        delete node.metadata[item];
      }
    }
    this.emit('changeNode', node, before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addEdge = function(outNode, outPort, inNode, inPort, metadata) {
    var edge, _i, _len, _ref;
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      if (edge.from.node === outNode && edge.from.port === outPort && edge.to.node === inNode && edge.to.port === inPort) {
        return;
      }
    }
    if (!this.getNode(outNode)) {
      return;
    }
    if (!this.getNode(inNode)) {
      return;
    }
    if (!metadata) {
      metadata = {};
    }
    this.checkTransactionStart();
    edge = {
      from: {
        node: outNode,
        port: outPort
      },
      to: {
        node: inNode,
        port: inPort
      },
      metadata: metadata
    };
    this.edges.push(edge);
    this.emit('addEdge', edge);
    this.checkTransactionEnd();
    return edge;
  };

  Graph.prototype.removeEdge = function(node, port, node2, port2) {
    var edge, index, toKeep, toRemove, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    this.checkTransactionStart();
    toRemove = [];
    toKeep = [];
    if (node2 && port2) {
      _ref = this.edges;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        edge = _ref[index];
        if (edge.from.node === node && edge.from.port === port && edge.to.node === node2 && edge.to.port === port2) {
          this.setEdgeMetadata(edge.from.node, edge.from.port, edge.to.node, edge.to.port, {});
          toRemove.push(edge);
        } else {
          toKeep.push(edge);
        }
      }
    } else {
      _ref1 = this.edges;
      for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
        edge = _ref1[index];
        if ((edge.from.node === node && edge.from.port === port) || (edge.to.node === node && edge.to.port === port)) {
          this.setEdgeMetadata(edge.from.node, edge.from.port, edge.to.node, edge.to.port, {});
          toRemove.push(edge);
        } else {
          toKeep.push(edge);
        }
      }
    }
    this.edges = toKeep;
    for (_k = 0, _len2 = toRemove.length; _k < _len2; _k++) {
      edge = toRemove[_k];
      this.emit('removeEdge', edge);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.getEdge = function(node, port, node2, port2) {
    var edge, index, _i, _len, _ref;
    _ref = this.edges;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      edge = _ref[index];
      if (!edge) {
        continue;
      }
      if (edge.from.node === node && edge.from.port === port) {
        if (edge.to.node === node2 && edge.to.port === port2) {
          return edge;
        }
      }
    }
    return null;
  };

  Graph.prototype.setEdgeMetadata = function(node, port, node2, port2, metadata) {
    var before, edge, item, val;
    edge = this.getEdge(node, port, node2, port2);
    if (!edge) {
      return;
    }
    this.checkTransactionStart();
    before = clone(edge.metadata);
    if (!edge.metadata) {
      edge.metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        edge.metadata[item] = val;
      } else {
        delete edge.metadata[item];
      }
    }
    this.emit('changeEdge', edge, before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addInitial = function(data, node, port, metadata) {
    var initializer;
    if (!this.getNode(node)) {
      return;
    }
    this.checkTransactionStart();
    initializer = {
      from: {
        data: data
      },
      to: {
        node: node,
        port: port
      },
      metadata: metadata
    };
    this.initializers.push(initializer);
    this.emit('addInitial', initializer);
    this.checkTransactionEnd();
    return initializer;
  };

  Graph.prototype.removeInitial = function(node, port) {
    var edge, index, toKeep, toRemove, _i, _j, _len, _len1, _ref;
    this.checkTransactionStart();
    toRemove = [];
    toKeep = [];
    _ref = this.initializers;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      edge = _ref[index];
      if (edge.to.node === node && edge.to.port === port) {
        toRemove.push(edge);
      } else {
        toKeep.push(edge);
      }
    }
    this.initializers = toKeep;
    for (_j = 0, _len1 = toRemove.length; _j < _len1; _j++) {
      edge = toRemove[_j];
      this.emit('removeInitial', edge);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.toDOT = function() {
    var cleanID, cleanPort, data, dot, edge, id, initializer, node, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    cleanID = function(id) {
      return id.replace(/\s*/g, "");
    };
    cleanPort = function(port) {
      return port.replace(/\./g, "");
    };
    dot = "digraph {\n";
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      dot += "    " + (cleanID(node.id)) + " [label=" + node.id + " shape=box]\n";
    }
    _ref1 = this.initializers;
    for (id = _j = 0, _len1 = _ref1.length; _j < _len1; id = ++_j) {
      initializer = _ref1[id];
      if (typeof initializer.from.data === 'function') {
        data = 'Function';
      } else {
        data = initializer.from.data;
      }
      dot += "    data" + id + " [label=\"'" + data + "'\" shape=plaintext]\n";
      dot += "    data" + id + " -> " + (cleanID(initializer.to.node)) + "[headlabel=" + (cleanPort(initializer.to.port)) + " labelfontcolor=blue labelfontsize=8.0]\n";
    }
    _ref2 = this.edges;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      edge = _ref2[_k];
      dot += "    " + (cleanID(edge.from.node)) + " -> " + (cleanID(edge.to.node)) + "[taillabel=" + (cleanPort(edge.from.port)) + " headlabel=" + (cleanPort(edge.to.port)) + " labelfontcolor=blue labelfontsize=8.0]\n";
    }
    dot += "}";
    return dot;
  };

  Graph.prototype.toYUML = function() {
    var edge, initializer, yuml, _i, _j, _len, _len1, _ref, _ref1;
    yuml = [];
    _ref = this.initializers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      initializer = _ref[_i];
      yuml.push("(start)[" + initializer.to.port + "]->(" + initializer.to.node + ")");
    }
    _ref1 = this.edges;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      edge = _ref1[_j];
      yuml.push("(" + edge.from.node + ")[" + edge.from.port + "]->(" + edge.to.node + ")");
    }
    return yuml.join(",");
  };

  Graph.prototype.toJSON = function() {
    var connection, edge, exported, group, groupData, initializer, json, node, priv, property, pub, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    json = {
      properties: {},
      inports: {},
      outports: {},
      groups: [],
      processes: {},
      connections: []
    };
    if (this.name) {
      json.properties.name = this.name;
    }
    _ref = this.properties;
    for (property in _ref) {
      value = _ref[property];
      json.properties[property] = value;
    }
    _ref1 = this.inports;
    for (pub in _ref1) {
      priv = _ref1[pub];
      json.inports[pub] = priv;
    }
    _ref2 = this.outports;
    for (pub in _ref2) {
      priv = _ref2[pub];
      json.outports[pub] = priv;
    }
    _ref3 = this.exports;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      exported = _ref3[_i];
      if (!json.exports) {
        json.exports = [];
      }
      json.exports.push(exported);
    }
    _ref4 = this.groups;
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      group = _ref4[_j];
      groupData = {
        name: group.name,
        nodes: group.nodes
      };
      if (Object.keys(group.metadata).length) {
        groupData.metadata = group.metadata;
      }
      json.groups.push(groupData);
    }
    _ref5 = this.nodes;
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      node = _ref5[_k];
      json.processes[node.id] = {
        component: node.component
      };
      if (node.metadata) {
        json.processes[node.id].metadata = node.metadata;
      }
    }
    _ref6 = this.edges;
    for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
      edge = _ref6[_l];
      connection = {
        src: {
          process: edge.from.node,
          port: edge.from.port
        },
        tgt: {
          process: edge.to.node,
          port: edge.to.port
        }
      };
      if (Object.keys(edge.metadata).length) {
        connection.metadata = edge.metadata;
      }
      json.connections.push(connection);
    }
    _ref7 = this.initializers;
    for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {
      initializer = _ref7[_m];
      json.connections.push({
        data: initializer.from.data,
        tgt: {
          process: initializer.to.node,
          port: initializer.to.port
        }
      });
    }
    return json;
  };

  Graph.prototype.save = function(file, success) {
    var json;
    json = JSON.stringify(this.toJSON(), null, 4);
    return require('fs').writeFile("" + file + ".json", json, "utf-8", function(err, data) {
      if (err) {
        throw err;
      }
      return success(file);
    });
  };

  return Graph;

})(EventEmitter);

exports.Graph = Graph;

exports.createGraph = function(name) {
  return new Graph(name);
};

exports.loadJSON = function(definition, success, metadata) {
  var conn, def, exported, graph, group, id, portId, priv, processId, properties, property, pub, split, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
  if (metadata == null) {
    metadata = {};
  }
  if (!definition.properties) {
    definition.properties = {};
  }
  if (!definition.processes) {
    definition.processes = {};
  }
  if (!definition.connections) {
    definition.connections = [];
  }
  graph = new Graph(definition.properties.name);
  graph.startTransaction('loadJSON', metadata);
  properties = {};
  _ref = definition.properties;
  for (property in _ref) {
    value = _ref[property];
    if (property === 'name') {
      continue;
    }
    properties[property] = value;
  }
  graph.setProperties(properties);
  _ref1 = definition.processes;
  for (id in _ref1) {
    def = _ref1[id];
    if (!def.metadata) {
      def.metadata = {};
    }
    graph.addNode(id, def.component, def.metadata);
  }
  _ref2 = definition.connections;
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    conn = _ref2[_i];
    if (conn.data !== void 0) {
      graph.addInitial(conn.data, conn.tgt.process, conn.tgt.port.toLowerCase());
      continue;
    }
    metadata = conn.metadata ? conn.metadata : {};
    graph.addEdge(conn.src.process, conn.src.port.toLowerCase(), conn.tgt.process, conn.tgt.port.toLowerCase(), metadata);
  }
  if (definition.exports && definition.exports.length) {
    _ref3 = definition.exports;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      exported = _ref3[_j];
      if (exported["private"]) {
        split = exported["private"].split('.');
        if (split.length !== 2) {
          continue;
        }
        processId = split[0];
        portId = split[1];
        for (id in definition.processes) {
          if (id.toLowerCase() === processId.toLowerCase()) {
            processId = id;
          }
        }
      } else {
        processId = exported.process;
        portId = exported.port;
      }
      graph.addExport(exported["public"], processId, portId, exported.metadata);
    }
  }
  if (definition.inports) {
    _ref4 = definition.inports;
    for (pub in _ref4) {
      priv = _ref4[pub];
      graph.addInport(pub, priv.process, priv.port, priv.metadata);
    }
  }
  if (definition.outports) {
    _ref5 = definition.outports;
    for (pub in _ref5) {
      priv = _ref5[pub];
      graph.addOutport(pub, priv.process, priv.port, priv.metadata);
    }
  }
  if (definition.groups) {
    _ref6 = definition.groups;
    for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
      group = _ref6[_k];
      graph.addGroup(group.name, group.nodes, group.metadata || {});
    }
  }
  graph.endTransaction('loadJSON');
  return success(graph);
};

exports.loadFBP = function(fbpData, success) {
  var definition;
  definition = require('fbp').parse(fbpData);
  return exports.loadJSON(definition, success);
};

exports.loadHTTP = function(url, success) {
  var req;
  req = new XMLHttpRequest;
  req.onreadystatechange = function() {
    if (req.readyState !== 4) {
      return;
    }
    if (req.status !== 200) {
      return success();
    }
    return success(req.responseText);
  };
  req.open('GET', url, true);
  return req.send();
};

exports.loadFile = function(file, success, metadata) {
  var definition, e;
  if (metadata == null) {
    metadata = {};
  }
  if (!(typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1)) {
    try {
      definition = require(file);
      exports.loadJSON(definition, success, metadata);
      return;
    } catch (_error) {
      e = _error;
      exports.loadHTTP(file, function(data) {
        if (!data) {
          throw new Error("Failed to load graph " + file);
          return;
        }
        if (file.split('.').pop() === 'fbp') {
          return exports.loadFBP(data, success);
        }
        definition = JSON.parse(data);
        return exports.loadJSON(definition, success);
      });
    }
    return;
  }
  return require('fs').readFile(file, "utf-8", function(err, data) {
    if (err) {
      throw err;
    }
    if (file.split('.').pop() === 'fbp') {
      return exports.loadFBP(data, success);
    }
    definition = JSON.parse(data);
    return exports.loadJSON(definition, success);
  });
};

});
require.register("noflo-noflo/src/lib/InternalSocket.js", function(exports, require, module){
var EventEmitter, InternalSocket,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

InternalSocket = (function(_super) {
  __extends(InternalSocket, _super);

  function InternalSocket() {
    this.connected = false;
    this.groups = [];
  }

  InternalSocket.prototype.connect = function() {
    if (this.connected) {
      return;
    }
    this.connected = true;
    return this.emit('connect', this);
  };

  InternalSocket.prototype.disconnect = function() {
    if (!this.connected) {
      return;
    }
    this.connected = false;
    return this.emit('disconnect', this);
  };

  InternalSocket.prototype.isConnected = function() {
    return this.connected;
  };

  InternalSocket.prototype.send = function(data) {
    if (!this.connected) {
      this.connect();
    }
    return this.emit('data', data);
  };

  InternalSocket.prototype.beginGroup = function(group) {
    this.groups.push(group);
    return this.emit('begingroup', group);
  };

  InternalSocket.prototype.endGroup = function() {
    return this.emit('endgroup', this.groups.pop());
  };

  InternalSocket.prototype.getId = function() {
    var fromStr, toStr;
    fromStr = function(from) {
      return "" + from.process.id + "() " + (from.port.toUpperCase());
    };
    toStr = function(to) {
      return "" + (to.port.toUpperCase()) + " " + to.process.id + "()";
    };
    if (!(this.from || this.to)) {
      return "UNDEFINED";
    }
    if (this.from && !this.to) {
      return "" + (fromStr(this.from)) + " -> ANON";
    }
    if (!this.from) {
      return "DATA -> " + (toStr(this.to));
    }
    return "" + (fromStr(this.from)) + " -> " + (toStr(this.to));
  };

  return InternalSocket;

})(EventEmitter);

exports.InternalSocket = InternalSocket;

exports.createSocket = function() {
  return new InternalSocket;
};

});
require.register("noflo-noflo/src/lib/BasePort.js", function(exports, require, module){
var BasePort, EventEmitter, validTypes,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

validTypes = ['all', 'string', 'number', 'int', 'object', 'array', 'boolean', 'color', 'date', 'bang'];

BasePort = (function(_super) {
  __extends(BasePort, _super);

  function BasePort(options) {
    this.handleOptions(options);
    this.sockets = [];
    this.node = null;
    this.name = null;
  }

  BasePort.prototype.handleOptions = function(options) {
    if (!options) {
      options = {};
    }
    if (!options.datatype) {
      options.datatype = 'all';
    }
    if (options.required === void 0) {
      options.required = true;
    }
    if (validTypes.indexOf(options.datatype) === -1) {
      throw new Error("Invalid port datatype '" + options.datatype + "' specified, valid are " + (validTypes.join(' ,')));
    }
    if (options.type && options.type.indexOf('/') === -1) {
      throw new Error("Invalid port type '" + options.type + "' specified. Should be URL or MIME type");
    }
    return this.options = options;
  };

  BasePort.prototype.getId = function() {
    if (!(this.node && this.name)) {
      return 'Port';
    }
    return "" + this.node + " " + (this.name.toUpperCase());
  };

  BasePort.prototype.getDataType = function() {
    return this.options.datatype;
  };

  BasePort.prototype.getDescription = function() {
    return this.options.description;
  };

  BasePort.prototype.attach = function(socket, index) {
    if (index == null) {
      index = null;
    }
    if (!this.isAddressable() || index === null) {
      index = this.sockets.length;
    }
    this.sockets[index] = socket;
    this.attachSocket(socket, index);
    if (this.isAddressable()) {
      this.emit('attach', socket, index);
      return;
    }
    return this.emit('attach', socket);
  };

  BasePort.prototype.attachSocket = function() {};

  BasePort.prototype.detach = function(socket) {
    var index;
    index = this.sockets.indexOf(socket);
    if (index === -1) {
      return;
    }
    this.sockets.splice(index, 1);
    if (this.isAddressable()) {
      this.emit('detach', socket, index);
      return;
    }
    return this.emit('detach', socket);
  };

  BasePort.prototype.isAddressable = function() {
    if (this.options.addressable) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isBuffered = function() {
    if (this.options.buffered) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isRequired = function() {
    if (this.options.required) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isAttached = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (this.isAddressable() && socketId !== null) {
      if (this.sockets[socketId]) {
        return true;
      }
      return false;
    }
    if (this.sockets.length) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isConnected = function(socketId) {
    var connected;
    if (socketId == null) {
      socketId = null;
    }
    if (this.isAddressable()) {
      if (socketId === null) {
        throw new Error("" + (this.getId()) + ": Socket ID required");
      }
      if (!this.sockets[socketId]) {
        throw new Error("" + (this.getId()) + ": Socket " + socketId + " not available");
      }
      return this.sockets[socketId].isConnected();
    }
    connected = false;
    this.sockets.forEach((function(_this) {
      return function(socket) {
        if (socket.isConnected()) {
          return connected = true;
        }
      };
    })(this));
    return connected;
  };

  BasePort.prototype.canAttach = function() {
    return true;
  };

  return BasePort;

})(EventEmitter);

module.exports = BasePort;

});
require.register("noflo-noflo/src/lib/InPort.js", function(exports, require, module){
var BasePort, InPort,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BasePort = require('./BasePort');

InPort = (function(_super) {
  __extends(InPort, _super);

  function InPort(options, process) {
    this.process = null;
    if (!process && typeof options === 'function') {
      process = options;
      options = {};
    }
    if (options && options.buffered === void 0) {
      options.buffered = false;
    }
    if (!process && options && options.process) {
      process = options.process;
      delete options.process;
    }
    if (process) {
      if (typeof process !== 'function') {
        throw new Error('process must be a function');
      }
      this.process = process;
    }
    InPort.__super__.constructor.call(this, options);
    this.sendDefault();
    this.prepareBuffer();
  }

  InPort.prototype.attachSocket = function(socket, localId) {
    if (localId == null) {
      localId = null;
    }
    socket.on('connect', (function(_this) {
      return function() {
        return _this.handleSocketEvent('connect', socket, localId);
      };
    })(this));
    socket.on('begingroup', (function(_this) {
      return function(group) {
        return _this.handleSocketEvent('begingroup', group, localId);
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        _this.validateData(data);
        return _this.handleSocketEvent('data', data, localId);
      };
    })(this));
    socket.on('endgroup', (function(_this) {
      return function(group) {
        return _this.handleSocketEvent('endgroup', group, localId);
      };
    })(this));
    return socket.on('disconnect', (function(_this) {
      return function() {
        return _this.handleSocketEvent('disconnect', socket, localId);
      };
    })(this));
  };

  InPort.prototype.handleSocketEvent = function(event, payload, id) {
    if (this.isBuffered()) {
      this.buffer.push({
        event: event,
        payload: payload,
        id: id
      });
      if (this.isAddressable()) {
        if (this.process) {
          this.process(event, id, this.nodeInstance);
        }
        this.emit(event, id);
      } else {
        if (this.process) {
          this.process(event, this.nodeInstance);
        }
        this.emit(event);
      }
      return;
    }
    if (this.process) {
      if (this.isAddressable()) {
        this.process(event, payload, id, this.nodeInstance);
      } else {
        this.process(event, payload, this.nodeInstance);
      }
    }
    if (this.isAddressable()) {
      return this.emit(event, payload, id);
    }
    return this.emit(event, payload);
  };

  InPort.prototype.sendDefault = function() {
    if (this.options["default"] === void 0) {
      return;
    }
    return setTimeout((function(_this) {
      return function() {
        var idx, socket, _i, _len, _ref, _results;
        _ref = _this.sockets;
        _results = [];
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          socket = _ref[idx];
          _results.push(_this.handleSocketEvent('data', _this.options["default"], idx));
        }
        return _results;
      };
    })(this), 0);
  };

  InPort.prototype.prepareBuffer = function() {
    if (!this.isBuffered()) {
      return;
    }
    return this.buffer = [];
  };

  InPort.prototype.validateData = function(data) {
    if (!this.options.values) {
      return;
    }
    if (this.options.values.indexOf(data) === -1) {
      throw new Error('Invalid data received');
    }
  };

  InPort.prototype.receive = function() {
    if (!this.isBuffered()) {
      throw new Error('Receive is only possible on buffered ports');
    }
    return this.buffer.shift();
  };

  return InPort;

})(BasePort);

module.exports = InPort;

});
require.register("noflo-noflo/src/lib/OutPort.js", function(exports, require, module){
var BasePort, OutPort,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BasePort = require('./BasePort');

OutPort = (function(_super) {
  __extends(OutPort, _super);

  function OutPort() {
    return OutPort.__super__.constructor.apply(this, arguments);
  }

  OutPort.prototype.connect = function(socketId) {
    var socket, sockets, _i, _len, _results;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    _results = [];
    for (_i = 0, _len = sockets.length; _i < _len; _i++) {
      socket = sockets[_i];
      _results.push(socket.connect());
    }
    return _results;
  };

  OutPort.prototype.beginGroup = function(group, socketId) {
    var sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    return sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.beginGroup(group);
      }
      socket.once('connect', function() {
        return socket.beginGroup(group);
      });
      return socket.connect();
    });
  };

  OutPort.prototype.send = function(data, socketId) {
    var sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    return sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.send(data);
      }
      socket.once('connect', function() {
        return socket.send(data);
      });
      return socket.connect();
    });
  };

  OutPort.prototype.endGroup = function(socketId) {
    var socket, sockets, _i, _len, _results;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    _results = [];
    for (_i = 0, _len = sockets.length; _i < _len; _i++) {
      socket = sockets[_i];
      _results.push(socket.endGroup());
    }
    return _results;
  };

  OutPort.prototype.disconnect = function(socketId) {
    var socket, sockets, _i, _len, _results;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    _results = [];
    for (_i = 0, _len = sockets.length; _i < _len; _i++) {
      socket = sockets[_i];
      _results.push(socket.disconnect());
    }
    return _results;
  };

  OutPort.prototype.checkRequired = function(sockets) {
    if (sockets.length === 0 && this.isRequired()) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
  };

  OutPort.prototype.getSockets = function(socketId) {
    if (this.isAddressable()) {
      if (socketId === null) {
        throw new Error("" + (this.getId()) + " Socket ID required");
      }
      if (!this.sockets[socketId]) {
        return [];
      }
      return [this.sockets[socketId]];
    }
    return this.sockets;
  };

  return OutPort;

})(BasePort);

module.exports = OutPort;

});
require.register("noflo-noflo/src/lib/Ports.js", function(exports, require, module){
var EventEmitter, InPort, InPorts, OutPort, OutPorts, Ports,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

InPort = require('./InPort');

OutPort = require('./OutPort');

Ports = (function(_super) {
  __extends(Ports, _super);

  Ports.prototype.model = InPort;

  function Ports(ports) {
    var name, options;
    this.ports = {};
    if (!ports) {
      return;
    }
    for (name in ports) {
      options = ports[name];
      this.add(name, options);
    }
  }

  Ports.prototype.add = function(name, options, process) {
    if (name === 'add' || name === 'remove') {
      throw new Error('Add and remove are restricted port names');
    }
    if (this.ports[name]) {
      this.remove(name);
    }
    if (typeof options === 'object' && options.canAttach) {
      this.ports[name] = options;
    } else {
      this.ports[name] = new this.model(options, process);
    }
    this[name] = this.ports[name];
    return this.emit('add', name);
  };

  Ports.prototype.remove = function(name) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not defined");
    }
    delete this.ports[name];
    delete this[name];
    return this.emit('remove', name);
  };

  return Ports;

})(EventEmitter);

exports.InPorts = InPorts = (function(_super) {
  __extends(InPorts, _super);

  function InPorts() {
    return InPorts.__super__.constructor.apply(this, arguments);
  }

  InPorts.prototype.on = function(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].on(event, callback);
  };

  InPorts.prototype.once = function(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].once(event, callback);
  };

  return InPorts;

})(Ports);

exports.OutPorts = OutPorts = (function(_super) {
  __extends(OutPorts, _super);

  function OutPorts() {
    return OutPorts.__super__.constructor.apply(this, arguments);
  }

  OutPorts.prototype.model = OutPort;

  OutPorts.prototype.connect = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].connect(socketId);
  };

  OutPorts.prototype.beginGroup = function(name, group, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].beginGroup(group, socketId);
  };

  OutPorts.prototype.send = function(name, data, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].send(data, socketId);
  };

  OutPorts.prototype.endGroup = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].endGroup(socketId);
  };

  OutPorts.prototype.disconnect = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].disconnect(socketId);
  };

  return OutPorts;

})(Ports);

});
require.register("noflo-noflo/src/lib/Port.js", function(exports, require, module){
var EventEmitter, Port,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

Port = (function(_super) {
  __extends(Port, _super);

  Port.prototype.description = '';

  Port.prototype.required = true;

  function Port(type) {
    this.type = type;
    if (!this.type) {
      this.type = 'all';
    }
    this.sockets = [];
    this.from = null;
    this.node = null;
    this.name = null;
  }

  Port.prototype.getId = function() {
    if (!(this.node && this.name)) {
      return 'Port';
    }
    return "" + this.node + " " + (this.name.toUpperCase());
  };

  Port.prototype.getDataType = function() {
    return this.type;
  };

  Port.prototype.getDescription = function() {
    return this.description;
  };

  Port.prototype.attach = function(socket) {
    this.sockets.push(socket);
    return this.attachSocket(socket);
  };

  Port.prototype.attachSocket = function(socket, localId) {
    if (localId == null) {
      localId = null;
    }
    this.emit("attach", socket);
    this.from = socket.from;
    if (socket.setMaxListeners) {
      socket.setMaxListeners(0);
    }
    socket.on("connect", (function(_this) {
      return function() {
        return _this.emit("connect", socket, localId);
      };
    })(this));
    socket.on("begingroup", (function(_this) {
      return function(group) {
        return _this.emit("begingroup", group, localId);
      };
    })(this));
    socket.on("data", (function(_this) {
      return function(data) {
        return _this.emit("data", data, localId);
      };
    })(this));
    socket.on("endgroup", (function(_this) {
      return function(group) {
        return _this.emit("endgroup", group, localId);
      };
    })(this));
    return socket.on("disconnect", (function(_this) {
      return function() {
        return _this.emit("disconnect", socket, localId);
      };
    })(this));
  };

  Port.prototype.connect = function() {
    var socket, _i, _len, _ref, _results;
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    _ref = this.sockets;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      _results.push(socket.connect());
    }
    return _results;
  };

  Port.prototype.beginGroup = function(group) {
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    return this.sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.beginGroup(group);
      }
      socket.once('connect', function() {
        return socket.beginGroup(group);
      });
      return socket.connect();
    });
  };

  Port.prototype.send = function(data) {
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    return this.sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.send(data);
      }
      socket.once('connect', function() {
        return socket.send(data);
      });
      return socket.connect();
    });
  };

  Port.prototype.endGroup = function() {
    var socket, _i, _len, _ref, _results;
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    _ref = this.sockets;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      _results.push(socket.endGroup());
    }
    return _results;
  };

  Port.prototype.disconnect = function() {
    var socket, _i, _len, _ref, _results;
    if (this.sockets.length === 0) {
      throw new Error("" + (this.getId()) + ": No connections available");
    }
    _ref = this.sockets;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      _results.push(socket.disconnect());
    }
    return _results;
  };

  Port.prototype.detach = function(socket) {
    var index;
    if (this.sockets.length === 0) {
      return;
    }
    if (!socket) {
      socket = this.sockets[0];
    }
    index = this.sockets.indexOf(socket);
    if (index === -1) {
      return;
    }
    this.sockets.splice(index, 1);
    return this.emit("detach", socket);
  };

  Port.prototype.isConnected = function() {
    var connected;
    connected = false;
    this.sockets.forEach((function(_this) {
      return function(socket) {
        if (socket.isConnected()) {
          return connected = true;
        }
      };
    })(this));
    return connected;
  };

  Port.prototype.isAddressable = function() {
    return false;
  };

  Port.prototype.isRequired = function() {
    return this.required;
  };

  Port.prototype.isAttached = function() {
    if (this.sockets.length > 0) {
      return true;
    }
    return false;
  };

  Port.prototype.canAttach = function() {
    return true;
  };

  return Port;

})(EventEmitter);

exports.Port = Port;

});
require.register("noflo-noflo/src/lib/ArrayPort.js", function(exports, require, module){
var ArrayPort, port,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

port = require("./Port");

ArrayPort = (function(_super) {
  __extends(ArrayPort, _super);

  function ArrayPort(type) {
    this.type = type;
    ArrayPort.__super__.constructor.call(this, this.type);
  }

  ArrayPort.prototype.attach = function(socket) {
    this.sockets.push(socket);
    return this.attachSocket(socket, this.sockets.length - 1);
  };

  ArrayPort.prototype.connect = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach(function(socket) {
        return socket.connect();
      });
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.beginGroup = function(group, socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          return _this.beginGroup(group, index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    if (this.isConnected(socketId)) {
      return this.sockets[socketId].beginGroup(group);
    }
    this.sockets[socketId].once("connect", (function(_this) {
      return function() {
        return _this.sockets[socketId].beginGroup(group);
      };
    })(this));
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.send = function(data, socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          return _this.send(data, index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    if (this.isConnected(socketId)) {
      return this.sockets[socketId].send(data);
    }
    this.sockets[socketId].once("connect", (function(_this) {
      return function() {
        return _this.sockets[socketId].send(data);
      };
    })(this));
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.endGroup = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          return _this.endGroup(index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error("" + (this.getId()) + ": No connection '" + socketId + "' available");
    }
    return this.sockets[socketId].endGroup();
  };

  ArrayPort.prototype.disconnect = function(socketId) {
    var socket, _i, _len, _ref;
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error("" + (this.getId()) + ": No connections available");
      }
      _ref = this.sockets;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        socket = _ref[_i];
        socket.disconnect();
      }
      return;
    }
    if (!this.sockets[socketId]) {
      return;
    }
    return this.sockets[socketId].disconnect();
  };

  ArrayPort.prototype.isConnected = function(socketId) {
    var connected;
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      connected = false;
      this.sockets.forEach((function(_this) {
        return function(socket) {
          if (socket.isConnected()) {
            return connected = true;
          }
        };
      })(this));
      return connected;
    }
    if (!this.sockets[socketId]) {
      return false;
    }
    return this.sockets[socketId].isConnected();
  };

  ArrayPort.prototype.isAddressable = function() {
    return true;
  };

  ArrayPort.prototype.isAttached = function(socketId) {
    if (socketId === void 0) {
      if (this.sockets.length > 0) {
        return true;
      }
      return false;
    }
    if (this.sockets[socketId]) {
      return true;
    }
    return false;
  };

  return ArrayPort;

})(port.Port);

exports.ArrayPort = ArrayPort;

});
require.register("noflo-noflo/src/lib/Component.js", function(exports, require, module){
var Component, EventEmitter, ports,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (!require('./Platform').isBrowser()) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

ports = require('./Ports');

Component = (function(_super) {
  __extends(Component, _super);

  Component.prototype.description = '';

  Component.prototype.icon = null;

  function Component(options) {
    this.error = __bind(this.error, this);
    if (!options) {
      options = {};
    }
    if (!options.inPorts) {
      options.inPorts = {};
    }
    if (options.inPorts instanceof ports.InPorts) {
      this.inPorts = options.inPorts;
    } else {
      this.inPorts = new ports.InPorts(options.inPorts);
    }
    if (!options.outPorts) {
      options.outPorts = {};
    }
    if (options.outPorts instanceof ports.OutPorts) {
      this.outPorts = options.outPorts;
    } else {
      this.outPorts = new ports.OutPorts(options.outPorts);
    }
  }

  Component.prototype.getDescription = function() {
    return this.description;
  };

  Component.prototype.isReady = function() {
    return true;
  };

  Component.prototype.isSubgraph = function() {
    return false;
  };

  Component.prototype.setIcon = function(icon) {
    this.icon = icon;
    return this.emit('icon', this.icon);
  };

  Component.prototype.getIcon = function() {
    return this.icon;
  };

  Component.prototype.error = function(e) {
    if (this.outPorts.error && this.outPorts.error.isAttached()) {
      this.outPorts.error.send(e);
      this.outPorts.error.disconnect();
      return;
    }
    throw e;
  };

  Component.prototype.shutdown = function() {};

  return Component;

})(EventEmitter);

exports.Component = Component;

});
require.register("noflo-noflo/src/lib/AsyncComponent.js", function(exports, require, module){
var AsyncComponent, component, port,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

port = require("./Port");

component = require("./Component");

AsyncComponent = (function(_super) {
  __extends(AsyncComponent, _super);

  function AsyncComponent(inPortName, outPortName, errPortName) {
    this.inPortName = inPortName != null ? inPortName : "in";
    this.outPortName = outPortName != null ? outPortName : "out";
    this.errPortName = errPortName != null ? errPortName : "error";
    if (!this.inPorts[this.inPortName]) {
      throw new Error("no inPort named '" + this.inPortName + "'");
    }
    if (!this.outPorts[this.outPortName]) {
      throw new Error("no outPort named '" + this.outPortName + "'");
    }
    this.load = 0;
    this.q = [];
    this.outPorts.load = new port.Port();
    this.inPorts[this.inPortName].on("begingroup", (function(_this) {
      return function(group) {
        if (_this.load > 0) {
          return _this.q.push({
            name: "begingroup",
            data: group
          });
        }
        return _this.outPorts[_this.outPortName].beginGroup(group);
      };
    })(this));
    this.inPorts[this.inPortName].on("endgroup", (function(_this) {
      return function() {
        if (_this.load > 0) {
          return _this.q.push({
            name: "endgroup"
          });
        }
        return _this.outPorts[_this.outPortName].endGroup();
      };
    })(this));
    this.inPorts[this.inPortName].on("disconnect", (function(_this) {
      return function() {
        if (_this.load > 0) {
          return _this.q.push({
            name: "disconnect"
          });
        }
        _this.outPorts[_this.outPortName].disconnect();
        if (_this.outPorts.load.isAttached()) {
          return _this.outPorts.load.disconnect();
        }
      };
    })(this));
    this.inPorts[this.inPortName].on("data", (function(_this) {
      return function(data) {
        if (_this.q.length > 0) {
          return _this.q.push({
            name: "data",
            data: data
          });
        }
        return _this.processData(data);
      };
    })(this));
  }

  AsyncComponent.prototype.processData = function(data) {
    this.incrementLoad();
    return this.doAsync(data, (function(_this) {
      return function(err) {
        if (err) {
          if (_this.outPorts[_this.errPortName] && _this.outPorts[_this.errPortName].isAttached()) {
            _this.outPorts[_this.errPortName].send(err);
            _this.outPorts[_this.errPortName].disconnect();
          } else {
            throw err;
          }
        }
        return _this.decrementLoad();
      };
    })(this));
  };

  AsyncComponent.prototype.incrementLoad = function() {
    this.load++;
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.send(this.load);
    }
    if (this.outPorts.load.isAttached()) {
      return this.outPorts.load.disconnect();
    }
  };

  AsyncComponent.prototype.doAsync = function(data, callback) {
    return callback(new Error("AsyncComponents must implement doAsync"));
  };

  AsyncComponent.prototype.decrementLoad = function() {
    if (this.load === 0) {
      throw new Error("load cannot be negative");
    }
    this.load--;
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.send(this.load);
    }
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.disconnect();
    }
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick((function(_this) {
        return function() {
          return _this.processQueue();
        };
      })(this));
    } else {
      return setTimeout((function(_this) {
        return function() {
          return _this.processQueue();
        };
      })(this), 0);
    }
  };

  AsyncComponent.prototype.processQueue = function() {
    var event, processedData;
    if (this.load > 0) {
      return;
    }
    processedData = false;
    while (this.q.length > 0) {
      event = this.q[0];
      switch (event.name) {
        case "begingroup":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].beginGroup(event.data);
          this.q.shift();
          break;
        case "endgroup":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].endGroup();
          this.q.shift();
          break;
        case "disconnect":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].disconnect();
          if (this.outPorts.load.isAttached()) {
            this.outPorts.load.disconnect();
          }
          this.q.shift();
          break;
        case "data":
          this.processData(event.data);
          this.q.shift();
          processedData = true;
      }
    }
  };

  return AsyncComponent;

})(component.Component);

exports.AsyncComponent = AsyncComponent;

});
require.register("noflo-noflo/src/lib/LoggingComponent.js", function(exports, require, module){
var Component, Port, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Component = require("./Component").Component;

Port = require("./Port").Port;

if (!require('./Platform').isBrowser()) {
  util = require("util");
} else {
  util = {
    inspect: function(data) {
      return data;
    }
  };
}

exports.LoggingComponent = (function(_super) {
  __extends(LoggingComponent, _super);

  function LoggingComponent() {
    this.sendLog = __bind(this.sendLog, this);
    this.outPorts = {
      log: new Port()
    };
  }

  LoggingComponent.prototype.sendLog = function(message) {
    if (typeof message === "object") {
      message.when = new Date;
      message.source = this.constructor.name;
      if (this.nodeId != null) {
        message.nodeID = this.nodeId;
      }
    }
    if ((this.outPorts.log != null) && this.outPorts.log.isAttached()) {
      return this.outPorts.log.send(message);
    } else {
      return console.log(util.inspect(message, 4, true, true));
    }
  };

  return LoggingComponent;

})(Component);

});
require.register("noflo-noflo/src/lib/ComponentLoader.js", function(exports, require, module){
var ComponentLoader, internalSocket, nofloGraph;

internalSocket = require('./InternalSocket');

nofloGraph = require('./Graph');

ComponentLoader = (function() {
  function ComponentLoader(baseDir) {
    this.baseDir = baseDir;
    this.components = null;
    this.checked = [];
    this.revalidate = false;
    this.libraryIcons = {};
  }

  ComponentLoader.prototype.getModulePrefix = function(name) {
    if (!name) {
      return '';
    }
    if (name === 'noflo') {
      return '';
    }
    return name.replace('noflo-', '');
  };

  ComponentLoader.prototype.getModuleComponents = function(moduleName) {
    var cPath, definition, dependency, e, loader, name, prefix, _ref, _ref1, _results;
    if (this.checked.indexOf(moduleName) !== -1) {
      return;
    }
    this.checked.push(moduleName);
    try {
      definition = require("/" + moduleName + "/component.json");
    } catch (_error) {
      e = _error;
      if (moduleName.substr(0, 1) === '/') {
        return this.getModuleComponents("noflo-" + (moduleName.substr(1)));
      }
      return;
    }
    for (dependency in definition.dependencies) {
      this.getModuleComponents(dependency.replace('/', '-'));
    }
    if (!definition.noflo) {
      return;
    }
    prefix = this.getModulePrefix(definition.name);
    if (definition.noflo.icon) {
      this.libraryIcons[prefix] = definition.noflo.icon;
    }
    if (moduleName[0] === '/') {
      moduleName = moduleName.substr(1);
    }
    if (definition.noflo.loader) {
      loader = require("/" + moduleName + "/" + definition.noflo.loader);
      loader(this);
    }
    if (definition.noflo.components) {
      _ref = definition.noflo.components;
      for (name in _ref) {
        cPath = _ref[name];
        if (cPath.indexOf('.coffee') !== -1) {
          cPath = cPath.replace('.coffee', '.js');
        }
        this.registerComponent(prefix, name, "/" + moduleName + "/" + cPath);
      }
    }
    if (definition.noflo.graphs) {
      _ref1 = definition.noflo.graphs;
      _results = [];
      for (name in _ref1) {
        cPath = _ref1[name];
        _results.push(this.registerComponent(prefix, name, "/" + moduleName + "/" + cPath));
      }
      return _results;
    }
  };

  ComponentLoader.prototype.listComponents = function(callback) {
    if (this.components !== null) {
      return callback(this.components);
    }
    this.components = {};
    this.getModuleComponents(this.baseDir);
    return callback(this.components);
  };

  ComponentLoader.prototype.load = function(name, callback, delayed, metadata) {
    var component, componentName, implementation, instance;
    if (!this.components) {
      this.listComponents((function(_this) {
        return function(components) {
          return _this.load(name, callback, delayed, metadata);
        };
      })(this));
      return;
    }
    component = this.components[name];
    if (!component) {
      for (componentName in this.components) {
        if (componentName.split('/')[1] === name) {
          component = this.components[componentName];
          break;
        }
      }
      if (!component) {
        throw new Error("Component " + name + " not available with base " + this.baseDir);
        return;
      }
    }
    if (this.isGraph(component)) {
      if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
        process.nextTick((function(_this) {
          return function() {
            return _this.loadGraph(name, component, callback, delayed, metadata);
          };
        })(this));
      } else {
        setTimeout((function(_this) {
          return function() {
            return _this.loadGraph(name, component, callback, delayed, metadata);
          };
        })(this), 0);
      }
      return;
    }
    if (typeof component === 'function') {
      implementation = component;
      if (component.getComponent && typeof component.getComponent === 'function') {
        instance = component.getComponent(metadata);
      } else {
        instance = component(metadata);
      }
    } else if (typeof component === 'object' && typeof component.getComponent === 'function') {
      instance = component.getComponent(metadata);
    } else {
      implementation = require(component);
      if (implementation.getComponent && typeof implementation.getComponent === 'function') {
        instance = implementation.getComponent(metadata);
      } else {
        instance = implementation(metadata);
      }
    }
    if (name === 'Graph') {
      instance.baseDir = this.baseDir;
    }
    this.setIcon(name, instance);
    return callback(instance);
  };

  ComponentLoader.prototype.isGraph = function(cPath) {
    if (typeof cPath === 'object' && cPath instanceof nofloGraph.Graph) {
      return true;
    }
    if (typeof cPath !== 'string') {
      return false;
    }
    return cPath.indexOf('.fbp') !== -1 || cPath.indexOf('.json') !== -1;
  };

  ComponentLoader.prototype.loadGraph = function(name, component, callback, delayed, metadata) {
    var delaySocket, graph, graphImplementation, graphSocket;
    graphImplementation = require(this.components['Graph']);
    graphSocket = internalSocket.createSocket();
    graph = graphImplementation.getComponent(metadata);
    graph.loader = this;
    graph.baseDir = this.baseDir;
    if (delayed) {
      delaySocket = internalSocket.createSocket();
      graph.inPorts.start.attach(delaySocket);
    }
    graph.inPorts.graph.attach(graphSocket);
    graphSocket.send(component);
    graphSocket.disconnect();
    graph.inPorts.remove('graph');
    graph.inPorts.remove('start');
    this.setIcon(name, graph);
    return callback(graph);
  };

  ComponentLoader.prototype.setIcon = function(name, instance) {
    var componentName, library, _ref;
    if (!instance.getIcon || instance.getIcon()) {
      return;
    }
    _ref = name.split('/'), library = _ref[0], componentName = _ref[1];
    if (componentName && this.getLibraryIcon(library)) {
      instance.setIcon(this.getLibraryIcon(library));
      return;
    }
    if (instance.isSubgraph()) {
      instance.setIcon('sitemap');
      return;
    }
    instance.setIcon('square');
  };

  ComponentLoader.prototype.getLibraryIcon = function(prefix) {
    if (this.libraryIcons[prefix]) {
      return this.libraryIcons[prefix];
    }
    return null;
  };

  ComponentLoader.prototype.registerComponent = function(packageId, name, cPath, callback) {
    var fullName, prefix;
    prefix = this.getModulePrefix(packageId);
    fullName = "" + prefix + "/" + name;
    if (!packageId) {
      fullName = name;
    }
    this.components[fullName] = cPath;
    if (callback) {
      return callback();
    }
  };

  ComponentLoader.prototype.registerGraph = function(packageId, name, gPath, callback) {
    return this.registerComponent(packageId, name, gPath, callback);
  };

  ComponentLoader.prototype.clear = function() {
    this.components = null;
    this.checked = [];
    return this.revalidate = true;
  };

  return ComponentLoader;

})();

exports.ComponentLoader = ComponentLoader;

});
require.register("noflo-noflo/src/lib/NoFlo.js", function(exports, require, module){
var ports;

exports.graph = require('./Graph');

exports.Graph = exports.graph.Graph;

exports.journal = require('./Journal');

exports.Journal = exports.journal.Journal;

exports.Network = require('./Network').Network;

exports.isBrowser = require('./Platform').isBrowser;

if (!exports.isBrowser()) {
  exports.ComponentLoader = require('./nodejs/ComponentLoader').ComponentLoader;
} else {
  exports.ComponentLoader = require('./ComponentLoader').ComponentLoader;
}

exports.Component = require('./Component').Component;

exports.AsyncComponent = require('./AsyncComponent').AsyncComponent;

exports.LoggingComponent = require('./LoggingComponent').LoggingComponent;

ports = require('./Ports');

exports.InPorts = ports.InPorts;

exports.OutPorts = ports.OutPorts;

exports.InPort = require('./InPort');

exports.OutPort = require('./OutPort');

exports.Port = require('./Port').Port;

exports.ArrayPort = require('./ArrayPort').ArrayPort;

exports.internalSocket = require('./InternalSocket');

exports.createNetwork = function(graph, callback, delay) {
  var network, networkReady;
  network = new exports.Network(graph);
  networkReady = function(network) {
    if (callback != null) {
      callback(network);
    }
    return network.start();
  };
  if (graph.nodes.length === 0) {
    setTimeout(function() {
      return networkReady(network);
    }, 0);
    return network;
  }
  network.loader.listComponents(function() {
    if (delay) {
      if (callback != null) {
        callback(network);
      }
      return;
    }
    return network.connect(function() {
      return networkReady(network);
    });
  });
  return network;
};

exports.loadFile = function(file, callback) {
  return exports.graph.loadFile(file, function(net) {
    return exports.createNetwork(net, callback);
  });
};

exports.saveFile = function(graph, file, callback) {
  return exports.graph.save(file, function() {
    return callback(file);
  });
};

});
require.register("noflo-noflo/src/lib/Network.js", function(exports, require, module){
var EventEmitter, Network, componentLoader, graph, internalSocket, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

internalSocket = require("./InternalSocket");

graph = require("./Graph");

if (!require('./Platform').isBrowser()) {
  componentLoader = require("./nodejs/ComponentLoader");
  EventEmitter = require('events').EventEmitter;
} else {
  componentLoader = require('./ComponentLoader');
  EventEmitter = require('emitter');
}

Network = (function(_super) {
  __extends(Network, _super);

  Network.prototype.processes = {};

  Network.prototype.connections = [];

  Network.prototype.initials = [];

  Network.prototype.graph = null;

  Network.prototype.startupDate = null;

  Network.prototype.portBuffer = {};

  function Network(graph) {
    this.processes = {};
    this.connections = [];
    this.initials = [];
    this.graph = graph;
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      this.baseDir = graph.baseDir || process.cwd();
    } else {
      this.baseDir = graph.baseDir || '/';
    }
    this.startupDate = new Date();
    if (graph.componentLoader) {
      this.loader = graph.componentLoader;
    } else {
      this.loader = new componentLoader.ComponentLoader(this.baseDir);
    }
  }

  Network.prototype.uptime = function() {
    return new Date() - this.startupDate;
  };

  Network.prototype.connectionCount = 0;

  Network.prototype.increaseConnections = function() {
    if (this.connectionCount === 0) {
      this.emit('start', {
        start: this.startupDate
      });
    }
    return this.connectionCount++;
  };

  Network.prototype.decreaseConnections = function() {
    var ender;
    this.connectionCount--;
    if (this.connectionCount === 0) {
      ender = _.debounce((function(_this) {
        return function() {
          if (_this.connectionCount) {
            return;
          }
          return _this.emit('end', {
            start: _this.startupDate,
            end: new Date,
            uptime: _this.uptime()
          });
        };
      })(this), 10);
      return ender();
    }
  };

  Network.prototype.load = function(component, metadata, callback) {
    return this.loader.load(component, callback, false, metadata);
  };

  Network.prototype.addNode = function(node, callback) {
    var process;
    if (this.processes[node.id]) {
      if (callback) {
        callback(this.processes[node.id]);
      }
      return;
    }
    process = {
      id: node.id
    };
    if (!node.component) {
      this.processes[process.id] = process;
      if (callback) {
        callback(process);
      }
      return;
    }
    return this.load(node.component, node.metadata, (function(_this) {
      return function(instance) {
        var name, port, _ref, _ref1;
        instance.nodeId = node.id;
        process.component = instance;
        _ref = process.component.inPorts;
        for (name in _ref) {
          port = _ref[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        _ref1 = process.component.outPorts;
        for (name in _ref1) {
          port = _ref1[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        if (instance.isSubgraph()) {
          _this.subscribeSubgraph(process);
        }
        _this.subscribeNode(process);
        _this.processes[process.id] = process;
        if (callback) {
          return callback(process);
        }
      };
    })(this));
  };

  Network.prototype.removeNode = function(node, callback) {
    if (!this.processes[node.id]) {
      return;
    }
    this.processes[node.id].component.shutdown();
    delete this.processes[node.id];
    if (callback) {
      return callback();
    }
  };

  Network.prototype.renameNode = function(oldId, newId, callback) {
    var name, port, process, _ref, _ref1;
    process = this.getNode(oldId);
    if (!process) {
      return;
    }
    process.id = newId;
    _ref = process.component.inPorts;
    for (name in _ref) {
      port = _ref[name];
      port.node = newId;
    }
    _ref1 = process.component.outPorts;
    for (name in _ref1) {
      port = _ref1[name];
      port.node = newId;
    }
    this.processes[newId] = process;
    delete this.processes[oldId];
    if (callback) {
      return callback();
    }
  };

  Network.prototype.getNode = function(id) {
    return this.processes[id];
  };

  Network.prototype.connect = function(done) {
    var edges, initializers, nodes, serialize, subscribeGraph;
    if (done == null) {
      done = function() {};
    }
    serialize = (function(_this) {
      return function(next, add) {
        return function(type) {
          return _this["add" + type](add, function() {
            return next(type);
          });
        };
      };
    })(this);
    subscribeGraph = (function(_this) {
      return function() {
        _this.subscribeGraph();
        return done();
      };
    })(this);
    initializers = _.reduceRight(this.graph.initializers, serialize, subscribeGraph);
    edges = _.reduceRight(this.graph.edges, serialize, function() {
      return initializers("Initial");
    });
    nodes = _.reduceRight(this.graph.nodes, serialize, function() {
      return edges("Edge");
    });
    return nodes("Node");
  };

  Network.prototype.connectPort = function(socket, process, port, inbound) {
    if (inbound) {
      socket.to = {
        process: process,
        port: port
      };
      if (!(process.component.inPorts && process.component.inPorts[port])) {
        throw new Error("No inport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
        return;
      }
      return process.component.inPorts[port].attach(socket);
    }
    socket.from = {
      process: process,
      port: port
    };
    if (!(process.component.outPorts && process.component.outPorts[port])) {
      throw new Error("No outport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
      return;
    }
    return process.component.outPorts[port].attach(socket);
  };

  Network.prototype.subscribeGraph = function() {
    var graphOps, processOps, processing, registerOp;
    graphOps = [];
    processing = false;
    registerOp = function(op, details) {
      return graphOps.push({
        op: op,
        details: details
      });
    };
    processOps = (function(_this) {
      return function() {
        var cb, op;
        if (!graphOps.length) {
          processing = false;
          return;
        }
        processing = true;
        op = graphOps.shift();
        cb = processOps;
        switch (op.op) {
          case 'renameNode':
            return _this.renameNode(op.details.from, op.details.to, cb);
          default:
            return _this[op.op](op.details, cb);
        }
      };
    })(this);
    this.graph.on('addNode', (function(_this) {
      return function(node) {
        registerOp('addNode', node);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('removeNode', (function(_this) {
      return function(node) {
        registerOp('removeNode', node);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        registerOp('renameNode', {
          from: oldId,
          to: newId
        });
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('addEdge', (function(_this) {
      return function(edge) {
        registerOp('addEdge', edge);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('removeEdge', (function(_this) {
      return function(edge) {
        registerOp('removeEdge', edge);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('addInitial', (function(_this) {
      return function(iip) {
        registerOp('addInitial', iip);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    return this.graph.on('removeInitial', (function(_this) {
      return function(iip) {
        registerOp('removeInitial', iip);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
  };

  Network.prototype.subscribeSubgraph = function(node) {
    var emitSub;
    if (!node.component.isReady()) {
      node.component.once('ready', (function(_this) {
        return function() {
          _this.subscribeSubgraph(node);
        };
      })(this));
    }
    if (!node.component.network) {
      return;
    }
    emitSub = (function(_this) {
      return function(type, data) {
        if (type === 'connect') {
          _this.increaseConnections();
        }
        if (type === 'disconnect') {
          _this.decreaseConnections();
        }
        if (!data) {
          data = {};
        }
        if (data.subgraph) {
          data.subgraph = "" + node.id + ":" + data.subgraph;
        } else {
          data.subgraph = node.id;
        }
        return _this.emit(type, data);
      };
    })(this);
    node.component.network.on('connect', function(data) {
      return emitSub('connect', data);
    });
    node.component.network.on('begingroup', function(data) {
      return emitSub('begingroup', data);
    });
    node.component.network.on('data', function(data) {
      return emitSub('data', data);
    });
    node.component.network.on('endgroup', function(data) {
      return emitSub('endgroup', data);
    });
    return node.component.network.on('disconnect', function(data) {
      return emitSub('disconnect', data);
    });
  };

  Network.prototype.subscribeSocket = function(socket) {
    socket.on('connect', (function(_this) {
      return function() {
        _this.increaseConnections();
        return _this.emit('connect', {
          id: socket.getId(),
          socket: socket
        });
      };
    })(this));
    socket.on('begingroup', (function(_this) {
      return function(group) {
        return _this.emit('begingroup', {
          id: socket.getId(),
          socket: socket,
          group: group
        });
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        return _this.emit('data', {
          id: socket.getId(),
          socket: socket,
          data: data
        });
      };
    })(this));
    socket.on('endgroup', (function(_this) {
      return function(group) {
        return _this.emit('endgroup', {
          id: socket.getId(),
          socket: socket,
          group: group
        });
      };
    })(this));
    return socket.on('disconnect', (function(_this) {
      return function() {
        _this.decreaseConnections();
        return _this.emit('disconnect', {
          id: socket.getId(),
          socket: socket
        });
      };
    })(this));
  };

  Network.prototype.subscribeNode = function(node) {
    if (!node.component.getIcon) {
      return;
    }
    return node.component.on('icon', (function(_this) {
      return function() {
        return _this.emit('icon', {
          id: node.id,
          icon: node.component.getIcon()
        });
      };
    })(this));
  };

  Network.prototype.addEdge = function(edge, callback) {
    var from, socket, to;
    socket = internalSocket.createSocket();
    from = this.getNode(edge.from.node);
    if (!from) {
      throw new Error("No process defined for outbound node " + edge.from.node);
    }
    if (!from.component) {
      throw new Error("No component defined for outbound node " + edge.from.node);
    }
    if (!from.component.isReady()) {
      from.component.once("ready", (function(_this) {
        return function() {
          return _this.addEdge(edge, callback);
        };
      })(this));
      return;
    }
    to = this.getNode(edge.to.node);
    if (!to) {
      throw new Error("No process defined for inbound node " + edge.to.node);
    }
    if (!to.component) {
      throw new Error("No component defined for inbound node " + edge.to.node);
    }
    if (!to.component.isReady()) {
      to.component.once("ready", (function(_this) {
        return function() {
          return _this.addEdge(edge, callback);
        };
      })(this));
      return;
    }
    this.connectPort(socket, to, edge.to.port, true);
    this.connectPort(socket, from, edge.from.port, false);
    this.subscribeSocket(socket);
    this.connections.push(socket);
    if (callback) {
      return callback();
    }
  };

  Network.prototype.removeEdge = function(edge, callback) {
    var connection, _i, _len, _ref, _results;
    _ref = this.connections;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      if (!connection) {
        continue;
      }
      if (!(edge.to.node === connection.to.process.id && edge.to.port === connection.to.port)) {
        continue;
      }
      connection.to.process.component.inPorts[connection.to.port].detach(connection);
      if (edge.from.node) {
        if (connection.from && edge.from.node === connection.from.process.id && edge.from.port === connection.from.port) {
          connection.from.process.component.outPorts[connection.from.port].detach(connection);
        }
      }
      this.connections.splice(this.connections.indexOf(connection), 1);
      if (callback) {
        _results.push(callback());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Network.prototype.addInitial = function(initializer, callback) {
    var socket, to;
    socket = internalSocket.createSocket();
    this.subscribeSocket(socket);
    to = this.getNode(initializer.to.node);
    if (!to) {
      throw new Error("No process defined for inbound node " + initializer.to.node);
    }
    if (!(to.component.isReady() || to.component.inPorts[initializer.to.port])) {
      to.component.setMaxListeners(0);
      to.component.once("ready", (function(_this) {
        return function() {
          return _this.addInitial(initializer, callback);
        };
      })(this));
      return;
    }
    this.connectPort(socket, to, initializer.to.port, true);
    this.connections.push(socket);
    this.initials.push({
      socket: socket,
      data: initializer.from.data
    });
    if (callback) {
      return callback();
    }
  };

  Network.prototype.removeInitial = function(initializer, callback) {
    var connection, _i, _len, _ref;
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      if (!connection) {
        continue;
      }
      if (!(initializer.to.node === connection.to.process.id && initializer.to.port === connection.to.port)) {
        continue;
      }
      connection.to.process.component.inPorts[connection.to.port].detach(connection);
      this.connections.splice(this.connections.indexOf(connection), 1);
    }
    if (callback) {
      return callback();
    }
  };

  Network.prototype.sendInitial = function(initial) {
    initial.socket.connect();
    initial.socket.send(initial.data);
    return initial.socket.disconnect();
  };

  Network.prototype.sendInitials = function() {
    var send;
    send = (function(_this) {
      return function() {
        var initial, _i, _len, _ref;
        _ref = _this.initials;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          initial = _ref[_i];
          _this.sendInitial(initial);
        }
        return _this.initials = [];
      };
    })(this);
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick(send);
    } else {
      return setTimeout(send, 0);
    }
  };

  Network.prototype.start = function() {
    return this.sendInitials();
  };

  Network.prototype.stop = function() {
    var connection, id, process, _i, _len, _ref, _ref1, _results;
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      if (!connection.isConnected()) {
        continue;
      }
      connection.disconnect();
    }
    _ref1 = this.processes;
    _results = [];
    for (id in _ref1) {
      process = _ref1[id];
      _results.push(process.component.shutdown());
    }
    return _results;
  };

  return Network;

})(EventEmitter);

exports.Network = Network;

});
require.register("noflo-noflo/src/lib/Platform.js", function(exports, require, module){
exports.isBrowser = function() {
  if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
    return false;
  }
  return true;
};

});
require.register("noflo-noflo/src/lib/Journal.js", function(exports, require, module){
var EventEmitter, Journal, JournalStore, MemoryJournalStore, calculateMeta, clone, entryToPrettyString,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  EventEmitter = require('events').EventEmitter;
} else {
  EventEmitter = require('emitter');
}

clone = require('./Utils').clone;

entryToPrettyString = function(entry) {
  var a;
  a = entry.args;
  switch (entry.cmd) {
    case 'addNode':
      return "" + a.id + "(" + a.component + ")";
    case 'removeNode':
      return "DEL " + a.id + "(" + a.component + ")";
    case 'renameNode':
      return "RENAME " + a.oldId + " " + a.newId;
    case 'changeNode':
      return "META " + a.id;
    case 'addEdge':
      return "" + a.from.node + " " + a.from.port + " -> " + a.to.port + " " + a.to.node;
    case 'removeEdge':
      return "" + a.from.node + " " + a.from.port + " -X> " + a.to.port + " " + a.to.node;
    case 'changeEdge':
      return "META " + a.from.node + " " + a.from.port + " -> " + a.to.port + " " + a.to.node;
    case 'addInitial':
      return "'" + a.from.data + "' -> " + a.to.port + " " + a.to.node;
    case 'removeInitial':
      return "'" + a.from.data + "' -X> " + a.to.port + " " + a.to.node;
    case 'startTransaction':
      return ">>> " + entry.rev + ": " + a.id;
    case 'endTransaction':
      return "<<< " + entry.rev + ": " + a.id;
    case 'changeProperties':
      return "PROPERTIES";
    case 'addGroup':
      return "GROUP " + a.name;
    case 'renameGroup':
      return "RENAME GROUP " + a.oldName + " " + a.newName;
    case 'removeGroup':
      return "DEL GROUP " + a.name;
    case 'changeGroup':
      return "META GROUP " + a.name;
    case 'addInport':
      return "INPORT " + a.name;
    case 'removeInport':
      return "DEL INPORT " + a.name;
    case 'renameInport':
      return "RENAME INPORT " + a.oldId + " " + a.newId;
    case 'changeInport':
      return "META INPORT " + a.name;
    case 'addOutport':
      return "OUTPORT " + a.name;
    case 'removeOutport':
      return "DEL OUTPORT " + a.name;
    case 'renameOutport':
      return "RENAME OUTPORT " + a.oldId + " " + a.newId;
    case 'changeOutport':
      return "META OUTPORT " + a.name;
    default:
      throw new Error("Unknown journal entry: " + entry.cmd);
  }
};

calculateMeta = function(oldMeta, newMeta) {
  var k, setMeta, v;
  setMeta = {};
  for (k in oldMeta) {
    v = oldMeta[k];
    setMeta[k] = null;
  }
  for (k in newMeta) {
    v = newMeta[k];
    setMeta[k] = v;
  }
  return setMeta;
};

JournalStore = (function(_super) {
  __extends(JournalStore, _super);

  JournalStore.prototype.lastRevision = 0;

  function JournalStore(graph) {
    this.graph = graph;
    this.lastRevision = 0;
  }

  JournalStore.prototype.putTransaction = function(revId, entries) {
    if (revId > this.lastRevision) {
      this.lastRevision = revId;
    }
    return this.emit('transaction', revId);
  };

  JournalStore.prototype.fetchTransaction = function(revId, entries) {};

  return JournalStore;

})(EventEmitter);

MemoryJournalStore = (function(_super) {
  __extends(MemoryJournalStore, _super);

  function MemoryJournalStore(graph) {
    MemoryJournalStore.__super__.constructor.call(this, graph);
    this.transactions = [];
  }

  MemoryJournalStore.prototype.putTransaction = function(revId, entries) {
    MemoryJournalStore.__super__.putTransaction.call(this, revId, entries);
    return this.transactions[revId] = entries;
  };

  MemoryJournalStore.prototype.fetchTransaction = function(revId) {
    return this.transactions[revId];
  };

  return MemoryJournalStore;

})(JournalStore);

Journal = (function(_super) {
  __extends(Journal, _super);

  Journal.prototype.graph = null;

  Journal.prototype.entries = [];

  Journal.prototype.subscribed = true;

  function Journal(graph, metadata, store) {
    this.endTransaction = __bind(this.endTransaction, this);
    this.startTransaction = __bind(this.startTransaction, this);
    var edge, group, iip, k, node, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    this.graph = graph;
    this.entries = [];
    this.subscribed = true;
    this.store = store || new MemoryJournalStore(this.graph);
    if (this.store.transactions.length === 0) {
      this.currentRevision = -1;
      this.startTransaction('initial', metadata);
      _ref = this.graph.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.appendCommand('addNode', node);
      }
      _ref1 = this.graph.edges;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        edge = _ref1[_j];
        this.appendCommand('addEdge', edge);
      }
      _ref2 = this.graph.initializers;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        iip = _ref2[_k];
        this.appendCommand('addInitial', iip);
      }
      if (Object.keys(this.graph.properties).length > 0) {
        this.appendCommand('changeProperties', this.graph.properties, {});
      }
      _ref3 = this.graph.inports;
      for (k in _ref3) {
        v = _ref3[k];
        this.appendCommand('addInport', {
          name: k,
          port: v
        });
      }
      _ref4 = this.graph.outports;
      for (k in _ref4) {
        v = _ref4[k];
        this.appendCommand('addOutport', {
          name: k,
          port: v
        });
      }
      _ref5 = this.graph.groups;
      for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
        group = _ref5[_l];
        this.appendCommand('addGroup', group);
      }
      this.endTransaction('initial', metadata);
    } else {
      this.currentRevision = this.store.lastRevision;
    }
    this.graph.on('addNode', (function(_this) {
      return function(node) {
        return _this.appendCommand('addNode', node);
      };
    })(this));
    this.graph.on('removeNode', (function(_this) {
      return function(node) {
        return _this.appendCommand('removeNode', node);
      };
    })(this));
    this.graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        var args;
        args = {
          oldId: oldId,
          newId: newId
        };
        return _this.appendCommand('renameNode', args);
      };
    })(this));
    this.graph.on('changeNode', (function(_this) {
      return function(node, oldMeta) {
        return _this.appendCommand('changeNode', {
          id: node.id,
          "new": node.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addEdge', (function(_this) {
      return function(edge) {
        return _this.appendCommand('addEdge', edge);
      };
    })(this));
    this.graph.on('removeEdge', (function(_this) {
      return function(edge) {
        return _this.appendCommand('removeEdge', edge);
      };
    })(this));
    this.graph.on('changeEdge', (function(_this) {
      return function(edge, oldMeta) {
        return _this.appendCommand('changeEdge', {
          from: edge.from,
          to: edge.to,
          "new": edge.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addInitial', (function(_this) {
      return function(iip) {
        return _this.appendCommand('addInitial', iip);
      };
    })(this));
    this.graph.on('removeInitial', (function(_this) {
      return function(iip) {
        return _this.appendCommand('removeInitial', iip);
      };
    })(this));
    this.graph.on('changeProperties', (function(_this) {
      return function(newProps, oldProps) {
        return _this.appendCommand('changeProperties', {
          "new": newProps,
          old: oldProps
        });
      };
    })(this));
    this.graph.on('addGroup', (function(_this) {
      return function(group) {
        return _this.appendCommand('addGroup', group);
      };
    })(this));
    this.graph.on('renameGroup', (function(_this) {
      return function(oldName, newName) {
        return _this.appendCommand('renameGroup', {
          oldName: oldName,
          newName: newName
        });
      };
    })(this));
    this.graph.on('removeGroup', (function(_this) {
      return function(group) {
        return _this.appendCommand('removeGroup', group);
      };
    })(this));
    this.graph.on('changeGroup', (function(_this) {
      return function(group, oldMeta) {
        return _this.appendCommand('changeGroup', {
          name: group.name,
          "new": group.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addExport', (function(_this) {
      return function(exported) {
        return _this.appendCommand('addExport', exported);
      };
    })(this));
    this.graph.on('removeExport', (function(_this) {
      return function(exported) {
        return _this.appendCommand('removeExport', exported);
      };
    })(this));
    this.graph.on('addInport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('addInport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('removeInport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('removeInport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('renameInport', (function(_this) {
      return function(oldId, newId) {
        return _this.appendCommand('renameInport', {
          oldId: oldId,
          newId: newId
        });
      };
    })(this));
    this.graph.on('changeInport', (function(_this) {
      return function(name, port, oldMeta) {
        return _this.appendCommand('changeInport', {
          name: name,
          "new": port.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addOutport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('addOutport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('removeOutport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('removeOutport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('renameOutport', (function(_this) {
      return function(oldId, newId) {
        return _this.appendCommand('renameOutport', {
          oldId: oldId,
          newId: newId
        });
      };
    })(this));
    this.graph.on('changeOutport', (function(_this) {
      return function(name, port, oldMeta) {
        return _this.appendCommand('changeOutport', {
          name: name,
          "new": port.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('startTransaction', (function(_this) {
      return function(id, meta) {
        return _this.startTransaction(id, meta);
      };
    })(this));
    this.graph.on('endTransaction', (function(_this) {
      return function(id, meta) {
        return _this.endTransaction(id, meta);
      };
    })(this));
  }

  Journal.prototype.startTransaction = function(id, meta) {
    if (!this.subscribed) {
      return;
    }
    if (this.entries.length > 0) {
      throw Error("Inconsistent @entries");
    }
    this.currentRevision++;
    return this.appendCommand('startTransaction', {
      id: id,
      metadata: meta
    }, this.currentRevision);
  };

  Journal.prototype.endTransaction = function(id, meta) {
    if (!this.subscribed) {
      return;
    }
    this.appendCommand('endTransaction', {
      id: id,
      metadata: meta
    }, this.currentRevision);
    this.store.putTransaction(this.currentRevision, this.entries);
    return this.entries = [];
  };

  Journal.prototype.appendCommand = function(cmd, args, rev) {
    var entry;
    if (!this.subscribed) {
      return;
    }
    entry = {
      cmd: cmd,
      args: clone(args)
    };
    if (rev != null) {
      entry.rev = rev;
    }
    return this.entries.push(entry);
  };

  Journal.prototype.executeEntry = function(entry) {
    var a;
    a = entry.args;
    switch (entry.cmd) {
      case 'addNode':
        return this.graph.addNode(a.id, a.component);
      case 'removeNode':
        return this.graph.removeNode(a.id);
      case 'renameNode':
        return this.graph.renameNode(a.oldId, a.newId);
      case 'changeNode':
        return this.graph.setNodeMetadata(a.id, calculateMeta(a.old, a["new"]));
      case 'addEdge':
        return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'removeEdge':
        return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'changeEdge':
        return this.graph.setEdgeMetadata(a.from.node, a.from.port, a.to.node, a.to.port, calculateMeta(a.old, a["new"]));
      case 'addInitial':
        return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
      case 'removeInitial':
        return this.graph.removeInitial(a.to.node, a.to.port);
      case 'startTransaction':
        return null;
      case 'endTransaction':
        return null;
      case 'changeProperties':
        return this.graph.setProperties(a["new"]);
      case 'addGroup':
        return this.graph.addGroup(a.name, a.nodes, a.metadata);
      case 'renameGroup':
        return this.graph.renameGroup(a.oldName, a.newName);
      case 'removeGroup':
        return this.graph.removeGroup(a.name);
      case 'changeGroup':
        return this.graph.setGroupMetadata(a.name, calculateMeta(a.old, a["new"]));
      case 'addInport':
        return this.graph.addInport(a.name, a.port.process, a.port.port, a.port.metadata);
      case 'removeInport':
        return this.graph.removeInport(a.name);
      case 'renameInport':
        return this.graph.renameInport(a.oldId, a.newId);
      case 'changeInport':
        return this.graph.setInportMetadata(a.port, calculateMeta(a.old, a["new"]));
      case 'addOutport':
        return this.graph.addOutport(a.name, a.port.process, a.port.port, a.port.metadata(a.name));
      case 'removeOutport':
        return this.graph.removeOutport;
      case 'renameOutport':
        return this.graph.renameOutport(a.oldId, a.newId);
      case 'changeOutport':
        return this.graph.setOutportMetadata(a.port, calculateMeta(a.old, a["new"]));
      default:
        throw new Error("Unknown journal entry: " + entry.cmd);
    }
  };

  Journal.prototype.executeEntryInversed = function(entry) {
    var a;
    a = entry.args;
    switch (entry.cmd) {
      case 'addNode':
        return this.graph.removeNode(a.id);
      case 'removeNode':
        return this.graph.addNode(a.id, a.component);
      case 'renameNode':
        return this.graph.renameNode(a.newId, a.oldId);
      case 'changeNode':
        return this.graph.setNodeMetadata(a.id, calculateMeta(a["new"], a.old));
      case 'addEdge':
        return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'removeEdge':
        return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'changeEdge':
        return this.graph.setEdgeMetadata(a.from.node, a.from.port, a.to.node, a.to.port, calculateMeta(a["new"], a.old));
      case 'addInitial':
        return this.graph.removeInitial(a.to.node, a.to.port);
      case 'removeInitial':
        return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
      case 'startTransaction':
        return null;
      case 'endTransaction':
        return null;
      case 'changeProperties':
        return this.graph.setProperties(a.old);
      case 'addGroup':
        return this.graph.removeGroup(a.name);
      case 'renameGroup':
        return this.graph.renameGroup(a.newName, a.oldName);
      case 'removeGroup':
        return this.graph.addGroup(a.name, a.nodes, a.metadata);
      case 'changeGroup':
        return this.graph.setGroupMetadata(a.name, calculateMeta(a["new"], a.old));
      case 'addInport':
        return this.graph.removeInport(a.name);
      case 'removeInport':
        return this.graph.addInport(a.name, a.port.process, a.port.port, a.port.metadata);
      case 'renameInport':
        return this.graph.renameInport(a.newId, a.oldId);
      case 'changeInport':
        return this.graph.setInportMetadata(a.port, calculateMeta(a["new"], a.old));
      case 'addOutport':
        return this.graph.removeOutport(a.name);
      case 'removeOutport':
        return this.graph.addOutport(a.name, a.port.process, a.port.port, a.port.metadata);
      case 'renameOutport':
        return this.graph.renameOutport(a.newId, a.oldId);
      case 'changeOutport':
        return this.graph.setOutportMetadata(a.port, calculateMeta(a["new"], a.old));
      default:
        throw new Error("Unknown journal entry: " + entry.cmd);
    }
  };

  Journal.prototype.moveToRevision = function(revId) {
    var entries, entry, i, r, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    if (revId === this.currentRevision) {
      return;
    }
    this.subscribed = false;
    if (revId > this.currentRevision) {
      for (r = _i = _ref = this.currentRevision + 1; _ref <= revId ? _i <= revId : _i >= revId; r = _ref <= revId ? ++_i : --_i) {
        _ref1 = this.store.fetchTransaction(r);
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          entry = _ref1[_j];
          this.executeEntry(entry);
        }
      }
    } else {
      for (r = _k = _ref2 = this.currentRevision, _ref3 = revId + 1; _k >= _ref3; r = _k += -1) {
        entries = this.store.fetchTransaction(r);
        for (i = _l = _ref4 = entries.length - 1; _l >= 0; i = _l += -1) {
          this.executeEntryInversed(entries[i]);
        }
      }
    }
    this.currentRevision = revId;
    return this.subscribed = true;
  };

  Journal.prototype.undo = function() {
    if (!this.canUndo()) {
      return;
    }
    return this.moveToRevision(this.currentRevision - 1);
  };

  Journal.prototype.canUndo = function() {
    return this.currentRevision > 0;
  };

  Journal.prototype.redo = function() {
    if (!this.canRedo()) {
      return;
    }
    return this.moveToRevision(this.currentRevision + 1);
  };

  Journal.prototype.canRedo = function() {
    return this.currentRevision < this.store.lastRevision;
  };

  Journal.prototype.toPrettyString = function(startRev, endRev) {
    var e, entry, lines, r, _i, _j, _len;
    startRev |= 0;
    endRev |= this.store.lastRevision;
    lines = [];
    for (r = _i = startRev; startRev <= endRev ? _i < endRev : _i > endRev; r = startRev <= endRev ? ++_i : --_i) {
      e = this.store.fetchTransaction(r);
      for (_j = 0, _len = e.length; _j < _len; _j++) {
        entry = e[_j];
        lines.push(entryToPrettyString(entry));
      }
    }
    return lines.join('\n');
  };

  Journal.prototype.toJSON = function(startRev, endRev) {
    var entries, entry, r, _i, _j, _len, _ref;
    startRev |= 0;
    endRev |= this.store.lastRevision;
    entries = [];
    for (r = _i = startRev; _i < endRev; r = _i += 1) {
      _ref = this.store.fetchTransaction(r);
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        entry = _ref[_j];
        entries.push(entryToPrettyString(entry));
      }
    }
    return entries;
  };

  Journal.prototype.save = function(file, success) {
    var json;
    json = JSON.stringify(this.toJSON(), null, 4);
    return require('fs').writeFile("" + file + ".json", json, "utf-8", function(err, data) {
      if (err) {
        throw err;
      }
      return success(file);
    });
  };

  return Journal;

})(EventEmitter);

exports.Journal = Journal;

exports.JournalStore = JournalStore;

exports.MemoryJournalStore = MemoryJournalStore;

});
require.register("noflo-noflo/src/lib/Utils.js", function(exports, require, module){
var clone;

clone = function(obj) {
  var flags, key, newInstance;
  if ((obj == null) || typeof obj !== 'object') {
    return obj;
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (obj instanceof RegExp) {
    flags = '';
    if (obj.global != null) {
      flags += 'g';
    }
    if (obj.ignoreCase != null) {
      flags += 'i';
    }
    if (obj.multiline != null) {
      flags += 'm';
    }
    if (obj.sticky != null) {
      flags += 'y';
    }
    return new RegExp(obj.source, flags);
  }
  newInstance = new obj.constructor();
  for (key in obj) {
    newInstance[key] = clone(obj[key]);
  }
  return newInstance;
};

exports.clone = clone;

});
require.register("noflo-noflo/src/components/Graph.js", function(exports, require, module){
var Graph, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  noflo = require("../../lib/NoFlo");
} else {
  noflo = require('../lib/NoFlo');
}

Graph = (function(_super) {
  __extends(Graph, _super);

  function Graph(metadata) {
    this.metadata = metadata;
    this.network = null;
    this.ready = true;
    this.started = false;
    this.baseDir = null;
    this.loader = null;
    this.inPorts = new noflo.InPorts({
      graph: {
        datatype: 'all',
        description: 'NoFlo graph definition to be used with the subgraph component',
        required: true,
        immediate: true
      },
      start: {
        datatype: 'bang',
        description: 'if attached, the network will only be started when receiving a start message',
        required: false
      }
    });
    this.outPorts = new noflo.OutPorts;
    this.inPorts.on('graph', 'data', (function(_this) {
      return function(data) {
        return _this.setGraph(data);
      };
    })(this));
    this.inPorts.on('start', 'data', (function(_this) {
      return function() {
        return _this.start();
      };
    })(this));
  }

  Graph.prototype.setGraph = function(graph) {
    this.ready = false;
    if (typeof graph === 'object') {
      if (typeof graph.addNode === 'function') {
        return this.createNetwork(graph);
      }
      noflo.graph.loadJSON(graph, (function(_this) {
        return function(instance) {
          instance.baseDir = _this.baseDir;
          return _this.createNetwork(instance);
        };
      })(this));
      return;
    }
    if (graph.substr(0, 1) !== "/" && graph.substr(1, 1) !== ":" && process && process.cwd) {
      graph = "" + (process.cwd()) + "/" + graph;
    }
    return graph = noflo.graph.loadFile(graph, (function(_this) {
      return function(instance) {
        instance.baseDir = _this.baseDir;
        return _this.createNetwork(instance);
      };
    })(this));
  };

  Graph.prototype.createNetwork = function(graph) {
    this.description = graph.properties.description || '';
    graph.componentLoader = this.loader;
    return noflo.createNetwork(graph, (function(_this) {
      return function(network) {
        _this.network = network;
        _this.emit('network', _this.network);
        return _this.network.connect(function() {
          var name, notReady, process, _ref, _ref1;
          notReady = false;
          _ref = _this.network.processes;
          for (name in _ref) {
            process = _ref[name];
            if (!_this.checkComponent(name, process)) {
              notReady = true;
            }
          }
          if (!notReady) {
            _this.setToReady();
          }
          if (((_ref1 = _this.inPorts.start) != null ? _ref1.isAttached() : void 0) && !_this.started) {
            return;
          }
          return _this.start(graph);
        });
      };
    })(this), true);
  };

  Graph.prototype.start = function(graph) {
    this.started = true;
    if (!this.network) {
      return;
    }
    this.network.sendInitials();
    if (!graph) {
      return;
    }
    return graph.on('addInitial', (function(_this) {
      return function() {
        return _this.network.sendInitials();
      };
    })(this));
  };

  Graph.prototype.checkComponent = function(name, process) {
    if (!process.component.isReady()) {
      process.component.once("ready", (function(_this) {
        return function() {
          _this.checkComponent(name, process);
          return _this.setToReady();
        };
      })(this));
      return false;
    }
    this.findEdgePorts(name, process);
    return true;
  };

  Graph.prototype.isExportedInport = function(port, nodeName, portName) {
    var exported, priv, pub, _i, _len, _ref, _ref1;
    _ref = this.network.graph.inports;
    for (pub in _ref) {
      priv = _ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    _ref1 = this.network.graph.exports;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      exported = _ref1[_i];
      if (!(exported.process === nodeName && exported.port === portName)) {
        continue;
      }
      this.network.graph.checkTransactionStart();
      this.network.graph.removeExport(exported["public"]);
      this.network.graph.addInport(exported["public"], exported.process, exported.port, exported.metadata);
      this.network.graph.checkTransactionEnd();
      return exported["public"];
    }
    if (Object.keys(this.network.graph.inports).length > 0) {
      return false;
    }
    if (port.isAttached()) {
      return false;
    }
    return (nodeName + '.' + portName).toLowerCase();
  };

  Graph.prototype.isExportedOutport = function(port, nodeName, portName) {
    var exported, priv, pub, _i, _len, _ref, _ref1;
    _ref = this.network.graph.outports;
    for (pub in _ref) {
      priv = _ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    _ref1 = this.network.graph.exports;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      exported = _ref1[_i];
      if (!(exported.process === nodeName && exported.port === portName)) {
        continue;
      }
      this.network.graph.checkTransactionStart();
      this.network.graph.removeExport(exported["public"]);
      this.network.graph.addOutport(exported["public"], exported.process, exported.port, exported.metadata);
      this.network.graph.checkTransactionEnd();
      return exported["public"];
    }
    if (Object.keys(this.network.graph.outports).length > 0) {
      return false;
    }
    if (port.isAttached()) {
      return false;
    }
    return (nodeName + '.' + portName).toLowerCase();
  };

  Graph.prototype.setToReady = function() {
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick((function(_this) {
        return function() {
          _this.ready = true;
          return _this.emit('ready');
        };
      })(this));
    } else {
      return setTimeout((function(_this) {
        return function() {
          _this.ready = true;
          return _this.emit('ready');
        };
      })(this), 0);
    }
  };

  Graph.prototype.findEdgePorts = function(name, process) {
    var port, portName, targetPortName, _ref, _ref1;
    _ref = process.component.inPorts;
    for (portName in _ref) {
      port = _ref[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      targetPortName = this.isExportedInport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.inPorts.add(targetPortName, port);
    }
    _ref1 = process.component.outPorts;
    for (portName in _ref1) {
      port = _ref1[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      targetPortName = this.isExportedOutport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.outPorts.add(targetPortName, port);
    }
    return true;
  };

  Graph.prototype.isReady = function() {
    return this.ready;
  };

  Graph.prototype.isSubgraph = function() {
    return true;
  };

  Graph.prototype.shutdown = function() {
    if (!this.network) {
      return;
    }
    return this.network.stop();
  };

  return Graph;

})(noflo.Component);

exports.getComponent = function(metadata) {
  return new Graph(metadata);
};

});
require.register("noflo-noflo-runtime-base/src/Base.js", function(exports, require, module){
var BaseTransport, protocols;

protocols = {
  Graph: require('./protocol/Graph'),
  Network: require('./protocol/Network'),
  Component: require('./protocol/Component')
};

BaseTransport = (function() {
  function BaseTransport(options) {
    this.options = options;
    if (!this.options) {
      this.options = {};
    }
    this.graph = new protocols.Graph(this);
    this.network = new protocols.Network(this);
    this.component = new protocols.Component(this);
    this.context = null;
  }

  BaseTransport.prototype.send = function(protocol, topic, payload, context) {};

  BaseTransport.prototype.receive = function(protocol, topic, payload, context) {
    this.context = context;
    switch (protocol) {
      case 'graph':
        return this.graph.receive(topic, payload, context);
      case 'network':
        return this.network.receive(topic, payload, context);
      case 'component':
        return this.component.receive(topic, payload, context);
    }
  };

  return BaseTransport;

})();

module.exports = BaseTransport;

});
require.register("noflo-noflo-runtime-base/src/protocol/Graph.js", function(exports, require, module){
var GraphProtocol, noflo;

noflo = require('noflo');

GraphProtocol = (function() {
  function GraphProtocol(transport) {
    this.transport = transport;
    this.graphs = {};
  }

  GraphProtocol.prototype.send = function(topic, payload, context) {
    return this.transport.send('graph', topic, payload, context);
  };

  GraphProtocol.prototype.receive = function(topic, payload, context) {
    var graph;
    if (topic !== 'clear') {
      graph = this.resolveGraph(payload, context);
      if (!graph) {
        return;
      }
    }
    switch (topic) {
      case 'clear':
        return this.initGraph(payload, context);
      case 'addnode':
        return this.addNode(graph, payload, context);
      case 'removenode':
        return this.removeNode(graph, payload, context);
      case 'renamenode':
        return this.renameNode(graph, payload, context);
      case 'addedge':
        return this.addEdge(graph, payload, context);
      case 'removeedge':
        return this.removeEdge(graph, payload, context);
      case 'addinitial':
        return this.addInitial(graph, payload, context);
      case 'removeinitial':
        return this.removeInitial(graph, payload, context);
      case 'addinport':
        return this.addInport(graph, payload, context);
      case 'removeinport':
        return this.removeInport(graph, payload, context);
      case 'addoutport':
        return this.addOutport(graph, payload, context);
      case 'removeoutport':
        return this.removeOutport(graph, payload, context);
    }
  };

  GraphProtocol.prototype.resolveGraph = function(payload, context) {
    if (!payload.graph) {
      this.send('error', new Error('No graph specified'), context);
      return;
    }
    if (!this.graphs[payload.graph]) {
      this.send('error', new Error('Requested graph not found'), context);
      return;
    }
    return this.graphs[payload.graph];
  };

  GraphProtocol.prototype.initGraph = function(payload, context) {
    var fullName, graph;
    if (!payload.id) {
      this.send('error', new Error('No graph ID provided'), context);
      return;
    }
    if (!payload.name) {
      payload.name = 'NoFlo runtime';
    }
    graph = new noflo.Graph(payload.name);
    fullName = payload.id;
    if (payload.library) {
      graph.properties.library = payload.library;
      fullName = "" + payload.library + "/" + fullName;
    }
    graph.baseDir = this.transport.options.baseDir;
    this.subscribeGraph(payload.id, graph, context);
    if (!payload.main) {
      this.transport.component.registerGraph(fullName, graph, context);
    }
    return this.graphs[payload.id] = graph;
  };

  GraphProtocol.prototype.subscribeGraph = function(id, graph, context) {
    graph.on('addNode', (function(_this) {
      return function(node) {
        node.graph = id;
        return _this.send('addnode', node, context);
      };
    })(this));
    graph.on('removeNode', (function(_this) {
      return function(node) {
        node.graph = id;
        return _this.send('removenode', node, context);
      };
    })(this));
    graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        return _this.send('renamenode', {
          from: oldId,
          to: newId,
          graph: id
        }, context);
      };
    })(this));
    graph.on('addEdge', (function(_this) {
      return function(edge) {
        var edgeData;
        edgeData = {
          src: edge.from,
          tgt: edge.to,
          metadata: edge.metadata,
          graph: id
        };
        return _this.send('addedge', edgeData, context);
      };
    })(this));
    graph.on('removeEdge', (function(_this) {
      return function(edge) {
        var edgeData;
        edgeData = {
          src: edge.from,
          tgt: edge.to,
          metadata: edge.metadata,
          graph: id
        };
        return _this.send('removeedge', edgeData, context);
      };
    })(this));
    graph.on('addInitial', (function(_this) {
      return function(iip) {
        var iipData;
        iipData = {
          src: iip.from,
          tgt: iip.to,
          metadata: iip.metadata,
          graph: id
        };
        return _this.send('addinitial', iipData, context);
      };
    })(this));
    return graph.on('removeInitial', (function(_this) {
      return function(iip) {
        var iipData;
        iipData = {
          src: iip.from,
          tgt: iip.to,
          metadata: iip.metadata,
          graph: id
        };
        return _this.send('removeinitial', iipData, context);
      };
    })(this));
  };

  GraphProtocol.prototype.addNode = function(graph, node, context) {
    if (!(node.id || node.component)) {
      this.send('error', new Error('No ID or component supplied'), context);
      return;
    }
    return graph.addNode(node.id, node.component, node.metadata);
  };

  GraphProtocol.prototype.removeNode = function(graph, payload) {
    if (!payload.id) {
      this.send('error', new Error('No ID supplied'), context);
      return;
    }
    return graph.removeNode(payload.id);
  };

  GraphProtocol.prototype.renameNode = function(graph, payload, context) {
    if (!(payload.from || payload.to)) {
      this.send('error', new Error('No from or to supplied'), context);
      return;
    }
    return graph.renameNode(payload.from, payload.to);
  };

  GraphProtocol.prototype.addEdge = function(graph, edge, context) {
    if (!(edge.src || edge.tgt)) {
      this.send('error', new Error('No src or tgt supplied'), context);
      return;
    }
    return graph.addEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port, edge.metadata);
  };

  GraphProtocol.prototype.removeEdge = function(graph, edge, context) {
    if (!(edge.src || edge.tgt)) {
      this.send('error', new Error('No src or tgt supplied'), context);
      return;
    }
    return graph.removeEdge(edge.src.node, edge.src.port, edge.tgt.node, edge.tgt.port);
  };

  GraphProtocol.prototype.addInitial = function(graph, payload, context) {
    if (!(payload.src || payload.tgt)) {
      this.send('error', new Error('No src or tgt supplied'), context);
      return;
    }
    return graph.addInitial(payload.src.data, payload.tgt.node, payload.tgt.port, payload.metadata);
  };

  GraphProtocol.prototype.removeInitial = function(graph, payload, context) {
    if (!payload.tgt) {
      this.send('error', new Error('No tgt supplied'), context);
      return;
    }
    return graph.removeInitial(payload.tgt.node, payload.tgt.port);
  };

  GraphProtocol.prototype.addInport = function(graph, payload, context) {
    if (!(payload["public"] || payload.node || payload.port)) {
      this.send('error', new Error('Missing exported inport information'), context);
      return;
    }
    return graph.addInport(payload["public"], payload.node, payload.port, payload.metadata);
  };

  GraphProtocol.prototype.removeInport = function(graph, payload, context) {
    if (!payload["public"]) {
      this.send('error', new Error('Missing exported inport name'), context);
      return;
    }
    return graph.removeInport(payload["public"]);
  };

  GraphProtocol.prototype.addOutport = function(graph, payload, context) {
    if (!(payload["public"] || payload.node || payload.port)) {
      this.send('error', new Error('Missing exported outport information'), context);
      return;
    }
    return graph.addOutport(payload["public"], payload.node, payload.port, payload.metadata);
  };

  GraphProtocol.prototype.removeOutport = function(graph, payload, context) {
    if (!payload["public"]) {
      this.send('error', new Error('Missing exported outport name'), context);
      return;
    }
    return graph.removeOutport(payload["public"]);
  };

  return GraphProtocol;

})();

module.exports = GraphProtocol;

});
require.register("noflo-noflo-runtime-base/src/protocol/Network.js", function(exports, require, module){
var NetworkProtocol, noflo, prepareSocketEvent;

noflo = require('noflo');

prepareSocketEvent = function(event, req) {
  var payload;
  payload = {
    id: event.id,
    graph: req.graph
  };
  if (event.socket.from) {
    payload.src = {
      node: event.socket.from.process.id,
      port: event.socket.from.port
    };
  }
  if (event.socket.to) {
    payload.tgt = {
      node: event.socket.to.process.id,
      port: event.socket.to.port
    };
  }
  if (event.subgraph) {
    payload.subgraph = event.subgraph;
  }
  if (event.group) {
    payload.group = event.group;
  }
  if (event.data) {
    if (event.data.toJSON) {
      payload.data = event.data.toJSON();
    }
    if (event.data.toString) {
      payload.data = event.data.toString();
      if (payload.data === '[object Object]') {
        try {
          payload.data = JSON.parse(JSON.stringify(event.data));
        } catch (_error) {}
      }
    } else {
      payload.data = event.data;
    }
  }
  if (event.subgraph) {
    payload.subgraph = event.subgraph;
  }
  return payload;
};

NetworkProtocol = (function() {
  function NetworkProtocol(transport) {
    this.transport = transport;
    this.networks = {};
  }

  NetworkProtocol.prototype.send = function(topic, payload, context) {
    return this.transport.send('network', topic, payload, context);
  };

  NetworkProtocol.prototype.receive = function(topic, payload, context) {
    var graph;
    graph = this.resolveGraph(payload, context);
    if (!graph) {
      return;
    }
    switch (topic) {
      case 'start':
        return this.initNetwork(graph, payload, context);
      case 'stop':
        return this.stopNetwork(graph, payload, context);
    }
  };

  NetworkProtocol.prototype.resolveGraph = function(payload, context) {
    if (!payload.graph) {
      this.send('error', new Error('No graph specified'), context);
      return;
    }
    if (!this.transport.graph.graphs[payload.graph]) {
      this.send('error', new Error('Requested graph not found'), context);
      return;
    }
    return this.transport.graph.graphs[payload.graph];
  };

  NetworkProtocol.prototype.initNetwork = function(graph, payload, context) {
    graph.componentLoader = this.transport.component.getLoader(graph.baseDir);
    return noflo.createNetwork(graph, (function(_this) {
      return function(network) {
        _this.networks[payload.graph] = network;
        _this.subscribeNetwork(network, payload, context);
        return network.connect(function() {
          network.sendInitials();
          return graph.on('addInitial', function() {
            return network.sendInitials();
          });
        });
      };
    })(this), true);
  };

  NetworkProtocol.prototype.subscribeNetwork = function(network, payload, context) {
    network.on('start', (function(_this) {
      return function(event) {
        return _this.send('started', {
          time: event.start,
          graph: payload.graph
        }, context);
      };
    })(this));
    network.on('icon', (function(_this) {
      return function(event) {
        event.graph = payload.graph;
        return _this.send('icon', event, context);
      };
    })(this));
    network.on('connect', (function(_this) {
      return function(event) {
        return _this.send('connect', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('begingroup', (function(_this) {
      return function(event) {
        return _this.send('begingroup', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('data', (function(_this) {
      return function(event) {
        return _this.send('data', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('endgroup', (function(_this) {
      return function(event) {
        return _this.send('endgroup', prepareSocketEvent(event, payload), context);
      };
    })(this));
    network.on('disconnect', (function(_this) {
      return function(event) {
        return _this.send('disconnect', prepareSocketEvent(event, payload), context);
      };
    })(this));
    return network.on('end', (function(_this) {
      return function(event) {
        return _this.send('stopped', {
          time: new Date,
          uptime: event.uptime,
          graph: payload.graph
        }, context);
      };
    })(this));
  };

  NetworkProtocol.prototype.stopNetwork = function(graph, payload, context) {
    if (!this.networks[payload.graph]) {
      return;
    }
    return this.networks[payload.graph].stop();
  };

  return NetworkProtocol;

})();

module.exports = NetworkProtocol;

});
require.register("noflo-noflo-runtime-base/src/protocol/Component.js", function(exports, require, module){
var ComponentProtocol, noflo;

noflo = require('noflo');

ComponentProtocol = (function() {
  ComponentProtocol.prototype.loaders = {};

  function ComponentProtocol(transport) {
    this.transport = transport;
  }

  ComponentProtocol.prototype.send = function(topic, payload, context) {
    return this.transport.send('component', topic, payload, context);
  };

  ComponentProtocol.prototype.receive = function(topic, payload, context) {
    switch (topic) {
      case 'list':
        return this.listComponents(payload, context);
      case 'getsource':
        return this.getSource(payload, context);
      case 'source':
        return this.setSource(payload, context);
    }
  };

  ComponentProtocol.prototype.getLoader = function(baseDir) {
    if (!this.loaders[baseDir]) {
      this.loaders[baseDir] = new noflo.ComponentLoader(baseDir);
    }
    return this.loaders[baseDir];
  };

  ComponentProtocol.prototype.listComponents = function(payload, context) {
    var baseDir, loader;
    baseDir = this.transport.options.baseDir;
    loader = this.getLoader(baseDir);
    return loader.listComponents((function(_this) {
      return function(components) {
        return Object.keys(components).forEach(function(component) {
          return _this.processComponent(loader, component, context);
        });
      };
    })(this));
  };

  ComponentProtocol.prototype.getSource = function(payload, context) {};

  ComponentProtocol.prototype.setSource = function(payload, context) {
    var e, fullName, implementation, library, source;
    source = payload.code;
    if (payload.language === 'coffeescript') {
      if (!window.CoffeeScript) {
        return;
      }
      try {
        source = CoffeeScript.compile(payload.code, {
          bare: true
        });
      } catch (_error) {
        e = _error;
        this.send('error', new Error("" + payload.name + " L" + e.location.first_line + ", C" + e.location.first_column + ": " + e.message), context);
        return;
      }
    }
    implementation = eval("(function () { var exports = {}; " + source + "; return exports; })()");
    if (!(implementation || implementation.getComponent)) {
      this.send('error', new Error("" + payload.name + ": No component implementation available"), context);
      return;
    }
    library = payload.library ? payload.library : '';
    fullName = payload.name;
    if (library) {
      fullName = "" + library + "/" + fullName;
    }
    return Object.keys(this.loaders).forEach((function(_this) {
      return function(baseDir) {
        var loader;
        loader = _this.getLoader(baseDir);
        return loader.listComponents(function(components) {
          loader.registerComponent(library, payload.name, implementation);
          return _this.processComponent(loader, fullName, context);
        });
      };
    })(this));
  };

  ComponentProtocol.prototype.processComponent = function(loader, component, context) {
    return loader.load(component, (function(_this) {
      return function(instance) {
        if (!instance.isReady()) {
          instance.once('ready', function() {
            return _this.sendComponent(component, instance, context);
          });
          return;
        }
        return _this.sendComponent(component, instance, context);
      };
    })(this), true);
  };

  ComponentProtocol.prototype.sendComponent = function(component, instance, context) {
    var icon, inPorts, outPorts, port, portName, _ref, _ref1;
    inPorts = [];
    outPorts = [];
    _ref = instance.inPorts;
    for (portName in _ref) {
      port = _ref[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      inPorts.push({
        id: portName,
        type: port.getDataType ? port.getDataType() : void 0,
        required: port.isRequired ? port.isRequired() : void 0,
        addressable: port.isAddressable ? port.isAddressable() : void 0,
        description: port.getDescription ? port.getDescription() : void 0
      });
    }
    _ref1 = instance.outPorts;
    for (portName in _ref1) {
      port = _ref1[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      outPorts.push({
        id: portName,
        type: port.getDataType ? port.getDataType() : void 0,
        required: port.isRequired ? port.isRequired() : void 0,
        addressable: port.isAddressable ? port.isAddressable() : void 0,
        description: port.getDescription ? port.getDescription() : void 0
      });
    }
    icon = instance.getIcon ? instance.getIcon() : 'blank';
    return this.send('component', {
      name: component,
      description: instance.description,
      subgraph: instance.isSubgraph(),
      icon: icon,
      inPorts: inPorts,
      outPorts: outPorts
    }, context);
  };

  ComponentProtocol.prototype.registerGraph = function(id, graph, context) {
    var loader, send;
    send = (function(_this) {
      return function() {
        return _this.processComponent(loader, id, context);
      };
    })(this);
    loader = this.getLoader(graph.baseDir);
    loader.listComponents((function(_this) {
      return function(components) {
        loader.registerComponent('', id, graph);
        return send();
      };
    })(this));
    graph.on('addNode', send);
    graph.on('removeNode', send);
    graph.on('renameNode', send);
    graph.on('addEdge', send);
    graph.on('removeEdge', send);
    graph.on('addInitial', send);
    return graph.on('removeInitial', send);
  };

  return ComponentProtocol;

})();

module.exports = ComponentProtocol;

});
require.register("noflo-noflo-runtime-iframe/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-runtime-iframe.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-runtime-iframe/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-runtime-iframe","description":"NoFlo runtime for execution inside an iframe","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-runtime-iframe","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*","noflo/noflo-runtime-base":"*","noflo/noflo-core":"*","noflo/noflo-flow":"*"},"scripts":["index.js"],"json":["component.json"],"files":["runtime/component.js","html/component.html","runtime/network.js","html/network.html"]}');
});
require.register("noflo-noflo-ajax/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-ajax.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-ajax/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-ajax","description":"AJAX components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-ajax","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Get.coffee","components/GetJsonP.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"globe","components":{"Get":"components/Get.coffee","GetJsonP":"components/GetJsonP.coffee"}}}');
});
require.register("noflo-noflo-ajax/components/Get.js", function(exports, require, module){
var Get, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Get = (function(_super) {
  __extends(Get, _super);

  function Get() {
    this.inPorts = {
      url: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    Get.__super__.constructor.call(this, 'url');
  }

  Get.prototype.doAsync = function(url, callback) {
    var req;
    req = new XMLHttpRequest;
    req.onreadystatechange = (function(_this) {
      return function() {
        if (req.readyState === 4) {
          if (req.status === 200) {
            _this.outPorts.out.beginGroup(url);
            _this.outPorts.out.send(req.responseText);
            _this.outPorts.out.endGroup();
            _this.outPorts.out.disconnect();
            return callback();
          } else {
            return callback(new Error("Error loading " + url));
          }
        }
      };
    })(this);
    req.open('GET', url, true);
    return req.send(null);
  };

  return Get;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new Get;
};

});
require.register("noflo-noflo-ajax/components/GetJsonP.js", function(exports, require, module){
var GetJsonP, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetJsonP = (function(_super) {
  __extends(GetJsonP, _super);

  function GetJsonP() {
    this.inPorts = {
      url: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    GetJsonP.__super__.constructor.call(this, 'url');
  }

  GetJsonP.prototype.doAsync = function(url, callback) {
    var body, id, s;
    id = 'noflo' + (Math.random() * 100).toString().replace(/\./g, '');
    body = document.querySelector('body');
    s = document.createElement('script');
    window[id] = (function(_this) {
      return function(data) {
        _this.outPorts.out.beginGroup(url);
        _this.outPorts.out.send(data);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        delete window[id];
        body.removeChild(s);
        return callback();
      };
    })(this);
    s.type = 'application/javascript';
    if (url.indexOf('?') === -1) {
      url = "" + url + "?callback=?";
    }
    s.src = url.replace('callback=?', "callback=" + id);
    return body.appendChild(s);
  };

  return GetJsonP;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetJsonP;
};

});
require.register("noflo-noflo-core/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of core.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-core/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-core","description":"NoFlo Essentials","repo":"noflo/noflo-core","version":"0.1.0","author":{"name":"Henri Bergius","email":"henri.bergius@iki.fi"},"contributors":[{"name":"Kenneth Kan","email":"kenhkan@gmail.com"},{"name":"Ryan Shaw","email":"ryanshaw@unc.edu"}],"keywords":[],"dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/Callback.coffee","components/DisconnectAfterPacket.coffee","components/Drop.coffee","components/Group.coffee","components/Kick.coffee","components/Merge.coffee","components/Output.coffee","components/Repeat.coffee","components/RepeatAsync.coffee","components/Split.coffee","components/RunInterval.coffee","components/RunTimeout.coffee","components/MakeFunction.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"Callback":"components/Callback.coffee","DisconnectAfterPacket":"components/DisconnectAfterPacket.coffee","Drop":"components/Drop.coffee","Group":"components/Group.coffee","Kick":"components/Kick.coffee","Merge":"components/Merge.coffee","Output":"components/Output.coffee","Repeat":"components/Repeat.coffee","RepeatAsync":"components/RepeatAsync.coffee","Split":"components/Split.coffee","RunInterval":"components/RunInterval.coffee","RunTimeout":"components/RunTimeout.coffee","MakeFunction":"components/MakeFunction.coffee"}}}');
});
require.register("noflo-noflo-core/components/Callback.js", function(exports, require, module){
var Callback, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore')._;

Callback = (function(_super) {
  __extends(Callback, _super);

  Callback.prototype.description = 'This component calls a given callback function for each IP it receives.  The Callback component is typically used to connect NoFlo with external Node.js code.';

  Callback.prototype.icon = 'sign-out';

  function Callback() {
    this.callback = null;
    this.inPorts = {
      "in": new noflo.Port('all'),
      callback: new noflo.Port('function')
    };
    this.outPorts = {
      error: new noflo.Port('object')
    };
    this.inPorts.callback.on('data', (function(_this) {
      return function(data) {
        if (!_.isFunction(data)) {
          _this.error('The provided callback must be a function');
          return;
        }
        return _this.callback = data;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (!_this.callback) {
          _this.error('No callback provided');
          return;
        }
        return _this.callback(data);
      };
    })(this));
  }

  Callback.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return Callback;

})(noflo.Component);

exports.getComponent = function() {
  return new Callback;
};

});
require.register("noflo-noflo-core/components/DisconnectAfterPacket.js", function(exports, require, module){
var DisconnectAfterPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DisconnectAfterPacket = (function(_super) {
  __extends(DisconnectAfterPacket, _super);

  DisconnectAfterPacket.prototype.description = 'Forwards any packets, but also sends a disconnect after each of them';

  DisconnectAfterPacket.prototype.icon = 'pause';

  function DisconnectAfterPacket() {
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.outPorts.out.send(data);
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
  }

  return DisconnectAfterPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new DisconnectAfterPacket;
};

});
require.register("noflo-noflo-core/components/Drop.js", function(exports, require, module){
var Drop, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Drop = (function(_super) {
  __extends(Drop, _super);

  Drop.prototype.description = 'This component drops every packet it receives with no action';

  Drop.prototype.icon = 'trash-o';

  function Drop() {
    this.inPorts = {
      "in": new noflo.ArrayPort('all')
    };
    this.outPorts = {};
  }

  return Drop;

})(noflo.Component);

exports.getComponent = function() {
  return new Drop;
};

});
require.register("noflo-noflo-core/components/Group.js", function(exports, require, module){
var Group, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Group = (function(_super) {
  __extends(Group, _super);

  Group.prototype.description = 'Adds a set of groups around the packets received at each connection';

  Group.prototype.icon = 'tags';

  function Group() {
    this.groups = [];
    this.newGroups = [];
    this.threshold = null;
    this.inPorts = {
      "in": new noflo.ArrayPort('all'),
      group: new noflo.ArrayPort('string'),
      threshold: new noflo.Port('integer')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        var group, _i, _len, _ref, _results;
        _ref = _this.newGroups;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _results.push(_this.outPorts.out.beginGroup(group));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var group, _i, _len, _ref;
        _ref = _this.newGroups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.endGroup();
        }
        _this.outPorts.out.disconnect();
        return _this.groups = [];
      };
    })(this));
    this.inPorts.group.on('data', (function(_this) {
      return function(data) {
        var diff;
        if (_this.threshold) {
          diff = _this.newGroups.length - _this.threshold + 1;
          if (diff > 0) {
            _this.newGroups = _this.newGroups.slice(diff);
          }
        }
        return _this.newGroups.push(data);
      };
    })(this));
    this.inPorts.threshold.on('data', (function(_this) {
      return function(threshold) {
        _this.threshold = threshold;
      };
    })(this));
  }

  return Group;

})(noflo.Component);

exports.getComponent = function() {
  return new Group;
};

});
require.register("noflo-noflo-core/components/Kick.js", function(exports, require, module){
var Kick, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Kick = (function(_super) {
  __extends(Kick, _super);

  Kick.prototype.description = 'This component generates a single packet and sends it to the output port. Mostly usable for debugging, but can also be useful for starting up networks.';

  Kick.prototype.icon = 'share';

  function Kick() {
    this.data = {
      packet: null,
      group: []
    };
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port('bang'),
      data: new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function() {
        return _this.data.group = _this.groups.slice(0);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.sendKick(_this.data);
        return _this.groups = [];
      };
    })(this));
    this.inPorts.data.on('data', (function(_this) {
      return function(data) {
        return _this.data.packet = data;
      };
    })(this));
  }

  Kick.prototype.sendKick = function(kick) {
    var group, _i, _j, _len, _len1, _ref, _ref1;
    _ref = kick.group;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(kick.packet);
    _ref1 = kick.group;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      this.outPorts.out.endGroup();
    }
    return this.outPorts.out.disconnect();
  };

  return Kick;

})(noflo.Component);

exports.getComponent = function() {
  return new Kick;
};

});
require.register("noflo-noflo-core/components/Merge.js", function(exports, require, module){
var Merge, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Merge = (function(_super) {
  __extends(Merge, _super);

  Merge.prototype.description = 'This component receives data on multiple input ports and sends the same data out to the connected output port';

  Merge.prototype.icon = 'compress';

  function Merge() {
    this.inPorts = {
      "in": new noflo.ArrayPort('all')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var socket, _i, _len, _ref;
        _ref = _this.inPorts["in"].sockets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          socket = _ref[_i];
          if (socket.connected) {
            return;
          }
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Merge;

})(noflo.Component);

exports.getComponent = function() {
  return new Merge;
};

});
require.register("noflo-noflo-core/components/Output.js", function(exports, require, module){
var Output, noflo, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

if (!noflo.isBrowser()) {
  util = require('util');
} else {
  util = {
    inspect: function(data) {
      return data;
    }
  };
}

Output = (function(_super) {
  __extends(Output, _super);

  Output.prototype.description = 'This component receives input on a single inport, and sends the data items directly to console.log';

  Output.prototype.icon = 'bug';

  function Output() {
    this.options = null;
    this.inPorts = {
      "in": new noflo.ArrayPort('all'),
      options: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.log(data);
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.disconnect();
        }
      };
    })(this));
    this.inPorts.options.on('data', (function(_this) {
      return function(data) {
        return _this.setOptions(data);
      };
    })(this));
  }

  Output.prototype.setOptions = function(options) {
    var key, value, _results;
    if (typeof options !== 'object') {
      throw new Error('Options is not an object');
    }
    if (this.options == null) {
      this.options = {};
    }
    _results = [];
    for (key in options) {
      if (!__hasProp.call(options, key)) continue;
      value = options[key];
      _results.push(this.options[key] = value);
    }
    return _results;
  };

  Output.prototype.log = function(data) {
    if (this.options != null) {
      return console.log(util.inspect(data, this.options.showHidden, this.options.depth, this.options.colors));
    } else {
      return console.log(data);
    }
  };

  return Output;

})(noflo.Component);

exports.getComponent = function() {
  return new Output();
};

});
require.register("noflo-noflo-core/components/Repeat.js", function(exports, require, module){
var Repeat, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Repeat = (function(_super) {
  __extends(Repeat, _super);

  Repeat.prototype.description = 'Forwards packets and metadata in the same way it receives them';

  Repeat.prototype.icon = 'forward';

  function Repeat() {
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Repeat;

})(noflo.Component);

exports.getComponent = function() {
  return new Repeat();
};

});
require.register("noflo-noflo-core/components/RepeatAsync.js", function(exports, require, module){
var RepeatAsync, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RepeatAsync = (function(_super) {
  __extends(RepeatAsync, _super);

  RepeatAsync.prototype.description = "Like 'Repeat', except repeat on next tick";

  RepeatAsync.prototype.icon = 'step-forward';

  function RepeatAsync() {
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var groups, later;
        groups = _this.groups;
        later = function() {
          var group, _i, _j, _len, _len1;
          for (_i = 0, _len = groups.length; _i < _len; _i++) {
            group = groups[_i];
            _this.outPorts.out.beginGroup(group);
          }
          _this.outPorts.out.send(data);
          for (_j = 0, _len1 = groups.length; _j < _len1; _j++) {
            group = groups[_j];
            _this.outPorts.out.endGroup();
          }
          return _this.outPorts.out.disconnect();
        };
        return setTimeout(later, 0);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
  }

  return RepeatAsync;

})(noflo.Component);

exports.getComponent = function() {
  return new RepeatAsync;
};

});
require.register("noflo-noflo-core/components/Split.js", function(exports, require, module){
var Split, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Split = (function(_super) {
  __extends(Split, _super);

  Split.prototype.description = 'This component receives data on a single input port and sends the same data out to all connected output ports';

  Split.prototype.icon = 'expand';

  function Split() {
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Split;

})(noflo.Component);

exports.getComponent = function() {
  return new Split;
};

});
require.register("noflo-noflo-core/components/RunInterval.js", function(exports, require, module){
var RunInterval, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RunInterval = (function(_super) {
  __extends(RunInterval, _super);

  RunInterval.prototype.description = 'Send a packet at the given interval';

  RunInterval.prototype.icon = 'clock-o';

  function RunInterval() {
    this.timer = null;
    this.interval = null;
    this.inPorts = {
      interval: new noflo.Port('number'),
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('bang')
    };
    this.inPorts.interval.on('data', (function(_this) {
      return function(interval) {
        _this.interval = interval;
        if (_this.timer != null) {
          clearInterval(_this.timer);
          return _this.timer = setInterval(function() {
            return _this.outPorts.out.send(true);
          }, _this.interval);
        }
      };
    })(this));
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        if (_this.timer != null) {
          clearInterval(_this.timer);
        }
        _this.outPorts.out.connect();
        return _this.timer = setInterval(function() {
          return _this.outPorts.out.send(true);
        }, _this.interval);
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        if (!_this.timer) {
          return;
        }
        clearInterval(_this.timer);
        _this.timer = null;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  RunInterval.prototype.shutdown = function() {
    if (this.timer != null) {
      return clearInterval(this.timer);
    }
  };

  return RunInterval;

})(noflo.Component);

exports.getComponent = function() {
  return new RunInterval;
};

});
require.register("noflo-noflo-core/components/RunTimeout.js", function(exports, require, module){
var RunTimeout, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RunTimeout = (function(_super) {
  __extends(RunTimeout, _super);

  RunTimeout.prototype.description = 'Send a packet after the given time in ms';

  RunTimeout.prototype.icon = 'clock-o';

  function RunTimeout() {
    this.timer = null;
    this.time = null;
    this.inPorts = {
      time: new noflo.Port('number'),
      start: new noflo.Port('bang'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('bang')
    };
    this.inPorts.time.on('data', (function(_this) {
      return function(time) {
        _this.time = time;
        if (_this.timer != null) {
          clearTimeout(_this.timer);
          return _this.timer = setTimeout(function() {
            return _this.outPorts.out.send(true);
          }, _this.time);
        }
      };
    })(this));
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        if (_this.timer != null) {
          clearTimeout(_this.timer);
        }
        _this.outPorts.out.connect();
        return _this.timer = setTimeout(function() {
          _this.outPorts.out.send(true);
          return _this.outPorts.out.disconnect();
        }, _this.time);
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        if (!_this.timer) {
          return;
        }
        clearTimeout(_this.timer);
        _this.timer = null;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  RunTimeout.prototype.shutdown = function() {
    if (this.timer != null) {
      return clearTimeout(this.timer);
    }
  };

  return RunTimeout;

})(noflo.Component);

exports.getComponent = function() {
  return new RunTimeout;
};

});
require.register("noflo-noflo-core/components/MakeFunction.js", function(exports, require, module){
var MakeFunction, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MakeFunction = (function(_super) {
  __extends(MakeFunction, _super);

  MakeFunction.prototype.description = 'Evaluates a function each time data hits the "in" port and sends the return value to "out". Within the function "x" will be the variable from the in port. For example, to make a ^2 function input "return x*x;" to the function port.';

  MakeFunction.prototype.icon = 'code';

  function MakeFunction() {
    this.f = null;
    this.inPorts = {
      "in": new noflo.Port('all'),
      "function": new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      "function": new noflo.Port('function'),
      error: new noflo.Port('object')
    };
    this.inPorts["function"].on('data', (function(_this) {
      return function(data) {
        var error;
        if (typeof data === "function") {
          _this.f = data;
        } else {
          try {
            _this.f = Function("x", data);
          } catch (_error) {
            error = _error;
            _this.error('Error creating function: ' + data);
          }
        }
        if (_this.f && _this.outPorts["function"].isAttached()) {
          return _this.outPorts["function"].send(_this.f);
        }
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var error;
        if (!_this.f) {
          _this.error('No function defined');
          return;
        }
        try {
          return _this.outPorts.out.send(_this.f(data));
        } catch (_error) {
          error = _error;
          return _this.error('Error evaluating function.');
        }
      };
    })(this));
  }

  MakeFunction.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return MakeFunction;

})(noflo.Component);

exports.getComponent = function() {
  return new MakeFunction;
};

});
require.register("noflo-noflo-css/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-css/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-css","description":"Cascading Style Sheets components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-css","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/MoveElement.coffee","components/RotateElement.coffee","components/SetElementTop.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"css3","components":{"MoveElement":"components/MoveElement.coffee","RotateElement":"components/RotateElement.coffee","SetElementTop":"components/SetElementTop.coffee"}}}');
});
require.register("noflo-noflo-css/components/MoveElement.js", function(exports, require, module){
var MoveElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MoveElement = (function(_super) {
  __extends(MoveElement, _super);

  MoveElement.prototype.description = 'Change the coordinates of a DOM element';

  MoveElement.prototype.icon = 'arrows';

  function MoveElement() {
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      point: new noflo.Port('object'),
      x: new noflo.Port('number'),
      y: new noflo.Port('number'),
      z: new noflo.Port('number')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.element = element;
      };
    })(this));
    this.inPorts.point.on('data', (function(_this) {
      return function(point) {
        _this.setPosition('left', "" + point.x + "px");
        return _this.setPosition('top', "" + point.y + "px");
      };
    })(this));
    this.inPorts.x.on('data', (function(_this) {
      return function(x) {
        return _this.setPosition('left', "" + x + "px");
      };
    })(this));
    this.inPorts.y.on('data', (function(_this) {
      return function(y) {
        return _this.setPosition('top', "" + y + "px");
      };
    })(this));
    this.inPorts.z.on('data', (function(_this) {
      return function(z) {
        return _this.setPosition('zIndex', z);
      };
    })(this));
  }

  MoveElement.prototype.setPosition = function(attr, value) {
    this.element.style.position = 'absolute';
    return this.element.style[attr] = value;
  };

  return MoveElement;

})(noflo.Component);

exports.getComponent = function() {
  return new MoveElement;
};

});
require.register("noflo-noflo-css/components/RotateElement.js", function(exports, require, module){
var RotateElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RotateElement = (function(_super) {
  __extends(RotateElement, _super);

  RotateElement.prototype.description = 'Change the coordinates of a DOM element';

  RotateElement.prototype.icon = 'rotate-right';

  function RotateElement() {
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      percent: new noflo.Port('number'),
      degrees: new noflo.Port('number')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.element = element;
      };
    })(this));
    this.inPorts.percent.on('data', (function(_this) {
      return function(percent) {
        var degrees;
        if (!_this.element) {
          return;
        }
        degrees = 360 * percent % 360;
        return _this.setRotation(_this.element, degrees);
      };
    })(this));
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        if (!_this.element) {
          return;
        }
        return _this.setRotation(_this.element, degrees);
      };
    })(this));
  }

  RotateElement.prototype.setRotation = function(element, degrees) {
    return this.setVendor(element, "transform", "rotate(" + degrees + "deg)");
  };

  RotateElement.prototype.setVendor = function(element, property, value) {
    var propertyCap;
    propertyCap = property.charAt(0).toUpperCase() + property.substr(1);
    element.style["webkit" + propertyCap] = value;
    element.style["moz" + propertyCap] = value;
    element.style["ms" + propertyCap] = value;
    element.style["o" + propertyCap] = value;
    return element.style[property] = value;
  };

  return RotateElement;

})(noflo.Component);

exports.getComponent = function() {
  return new RotateElement;
};

});
require.register("noflo-noflo-css/components/SetElementTop.js", function(exports, require, module){
var SetElementTop, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetElementTop = (function(_super) {
  __extends(SetElementTop, _super);

  SetElementTop.prototype.description = 'Set element\'s CSS top';

  SetElementTop.prototype.icon = 'arrows-v';

  function SetElementTop() {
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      top: new noflo.Port('number')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.element = element;
      };
    })(this));
    this.inPorts.top.on('data', (function(_this) {
      return function(top) {
        if (!_this.element) {
          return;
        }
        _this.element.style.position = 'absolute';
        return _this.element.style.top = "" + top + "px";
      };
    })(this));
  }

  return SetElementTop;

})(noflo.Component);

exports.getComponent = function() {
  return new SetElementTop;
};

});
require.register("noflo-noflo-dom/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-dom/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-dom","description":"Document Object Model components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-dom","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/AddClass.coffee","components/AppendChild.coffee","components/CreateElement.coffee","components/CreateFragment.coffee","components/GetAttribute.coffee","components/GetElement.coffee","components/HasClass.coffee","components/ReadHtml.coffee","components/RemoveElement.coffee","components/SetAttribute.coffee","components/WriteHtml.coffee","components/RemoveClass.coffee","components/RequestAnimationFrame.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"html5","components":{"AddClass":"components/AddClass.coffee","AppendChild":"components/AppendChild.coffee","CreateElement":"components/CreateElement.coffee","CreateFragment":"components/CreateFragment.coffee","GetAttribute":"components/GetAttribute.coffee","GetElement":"components/GetElement.coffee","HasClass":"components/HasClass.coffee","WriteHtml":"components/WriteHtml.coffee","ReadHtml":"components/ReadHtml.coffee","RemoveElement":"components/RemoveElement.coffee","SetAttribute":"components/SetAttribute.coffee","RemoveClass":"components/RemoveClass.coffee","RequestAnimationFrame":"components/RequestAnimationFrame.coffee"}}}');
});
require.register("noflo-noflo-dom/components/AddClass.js", function(exports, require, module){
var AddClass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

AddClass = (function(_super) {
  __extends(AddClass, _super);

  AddClass.prototype.description = 'Add a class to an element';

  function AddClass() {
    this.element = null;
    this["class"] = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      "class": new noflo.Port('string')
    };
    this.outPorts = {};
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this["class"]) {
          return _this.addClass();
        }
      };
    })(this));
    this.inPorts["class"].on('data', (function(_this) {
      return function(data) {
        _this["class"] = data;
        if (_this.element) {
          return _this.addClass();
        }
      };
    })(this));
  }

  AddClass.prototype.addClass = function() {
    return this.element.classList.add(this["class"]);
  };

  return AddClass;

})(noflo.Component);

exports.getComponent = function() {
  return new AddClass;
};

});
require.register("noflo-noflo-dom/components/AppendChild.js", function(exports, require, module){
var AppendChild, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

AppendChild = (function(_super) {
  __extends(AppendChild, _super);

  AppendChild.prototype.description = 'Append elements as children of a parent element';

  function AppendChild() {
    this.parent = null;
    this.children = [];
    this.inPorts = {
      parent: new noflo.Port('object'),
      child: new noflo.Port('object')
    };
    this.outPorts = {};
    this.inPorts.parent.on('data', (function(_this) {
      return function(data) {
        _this.parent = data;
        if (_this.children.length) {
          return _this.append();
        }
      };
    })(this));
    this.inPorts.child.on('data', (function(_this) {
      return function(data) {
        if (!_this.parent) {
          _this.children.push(data);
          return;
        }
        return _this.parent.appendChild(data);
      };
    })(this));
  }

  AppendChild.prototype.append = function() {
    var child, _i, _len, _ref;
    _ref = this.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      this.parent.appendChild(child);
    }
    return this.children = [];
  };

  return AppendChild;

})(noflo.Component);

exports.getComponent = function() {
  return new AppendChild;
};

});
require.register("noflo-noflo-dom/components/CreateElement.js", function(exports, require, module){
var CreateElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateElement = (function(_super) {
  __extends(CreateElement, _super);

  CreateElement.prototype.description = 'Create a new DOM Element';

  function CreateElement() {
    this.tagName = null;
    this.container = null;
    this.inPorts = {
      tagname: new noflo.Port('string'),
      container: new noflo.Port('object')
    };
    this.outPorts = {
      element: new noflo.Port('object')
    };
    this.inPorts.tagname.on('data', (function(_this) {
      return function(tagName) {
        _this.tagName = tagName;
        return _this.createElement();
      };
    })(this));
    this.inPorts.tagname.on('disconnect', (function(_this) {
      return function() {
        if (!_this.inPorts.container.isAttached()) {
          return _this.outPorts.element.disconnect();
        }
      };
    })(this));
    this.inPorts.container.on('data', (function(_this) {
      return function(container) {
        _this.container = container;
        return _this.createElement();
      };
    })(this));
    this.inPorts.container.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.element.disconnect();
      };
    })(this));
  }

  CreateElement.prototype.createElement = function() {
    var el;
    if (!this.tagName) {
      return;
    }
    if (this.inPorts.container.isAttached()) {
      if (!this.container) {
        return;
      }
    }
    el = document.createElement(this.tagName);
    if (this.container) {
      this.container.appendChild(el);
    }
    return this.outPorts.element.send(el);
  };

  return CreateElement;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateElement;
};

});
require.register("noflo-noflo-dom/components/CreateFragment.js", function(exports, require, module){
var CreateFragment, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateFragment = (function(_super) {
  __extends(CreateFragment, _super);

  CreateFragment.prototype.description = 'Create a new DOM DocumentFragment';

  function CreateFragment() {
    this.inPorts = {
      "in": new noflo.Port('bang')
    };
    this.outPorts = {
      fragment: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function() {
        return _this.outPorts.fragment.send(document.createDocumentFragment());
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.fragment.disconnect();
      };
    })(this));
  }

  return CreateFragment;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateFragment;
};

});
require.register("noflo-noflo-dom/components/GetAttribute.js", function(exports, require, module){
var GetAttribute, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetAttribute = (function(_super) {
  __extends(GetAttribute, _super);

  function GetAttribute() {
    this.attribute = null;
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      attribute: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this.attribute) {
          return _this.getAttribute();
        }
      };
    })(this));
    this.inPorts.attribute.on('data', (function(_this) {
      return function(data) {
        _this.attribute = data;
        if (_this.element) {
          return _this.getAttribute();
        }
      };
    })(this));
  }

  GetAttribute.prototype.getAttribute = function() {
    var value;
    value = this.element.getAttribute(this.attribute);
    this.outPorts.out.beginGroup(this.attribute);
    this.outPorts.out.send(value);
    this.outPorts.out.endGroup();
    return this.outPorts.out.disconnect();
  };

  return GetAttribute;

})(noflo.Component);

exports.getComponent = function() {
  return new GetAttribute;
};

});
require.register("noflo-noflo-dom/components/GetElement.js", function(exports, require, module){
var GetElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetElement = (function(_super) {
  __extends(GetElement, _super);

  GetElement.prototype.description = 'Get a DOM element matching a query';

  function GetElement() {
    this.container = null;
    this.inPorts = {
      "in": new noflo.Port('object'),
      selector: new noflo.Port('string')
    };
    this.outPorts = {
      element: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (typeof data.querySelector !== 'function') {
          _this.error('Given container doesn\'t support querySelectors');
          return;
        }
        return _this.container = data;
      };
    })(this));
    this.inPorts.selector.on('data', (function(_this) {
      return function(data) {
        return _this.select(data);
      };
    })(this));
  }

  GetElement.prototype.select = function(selector) {
    var el, element, _i, _len;
    if (this.container) {
      el = this.container.querySelectorAll(selector);
    } else {
      el = document.querySelectorAll(selector);
    }
    if (!el.length) {
      this.error("No element matching '" + selector + "' found");
      return;
    }
    for (_i = 0, _len = el.length; _i < _len; _i++) {
      element = el[_i];
      this.outPorts.element.send(element);
    }
    return this.outPorts.element.disconnect();
  };

  GetElement.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return GetElement;

})(noflo.Component);

exports.getComponent = function() {
  return new GetElement;
};

});
require.register("noflo-noflo-dom/components/HasClass.js", function(exports, require, module){
var HasClass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

HasClass = (function(_super) {
  __extends(HasClass, _super);

  HasClass.prototype.description = 'Check if an element has a given class';

  function HasClass() {
    this.element = null;
    this["class"] = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      "class": new noflo.Port('string')
    };
    this.outPorts = {
      element: new noflo.Port('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this["class"]) {
          return _this.checkClass();
        }
      };
    })(this));
    this.inPorts.element.on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.element.disconnect();
        if (!_this.outPorts.missed.isAttached()) {
          return;
        }
        return _this.outPorts.missed.disconnect();
      };
    })(this));
    this.inPorts["class"].on('data', (function(_this) {
      return function(data) {
        _this["class"] = data;
        if (_this.element) {
          return _this.checkClass();
        }
      };
    })(this));
  }

  HasClass.prototype.checkClass = function() {
    if (this.element.classList.contains(this["class"])) {
      this.outPorts.element.send(this.element);
      return;
    }
    if (!this.outPorts.missed.isAttached()) {
      return;
    }
    return this.outPorts.missed.send(this.element);
  };

  return HasClass;

})(noflo.Component);

exports.getComponent = function() {
  return new HasClass;
};

});
require.register("noflo-noflo-dom/components/ReadHtml.js", function(exports, require, module){
var ReadHtml, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ReadHtml = (function(_super) {
  __extends(ReadHtml, _super);

  ReadHtml.prototype.description = 'Read HTML from an existing element';

  function ReadHtml() {
    this.inPorts = {
      container: new noflo.Port('object')
    };
    this.outPorts = {
      html: new noflo.Port('string')
    };
    this.inPorts.container.on('data', (function(_this) {
      return function(data) {
        _this.outPorts.html.send(data.innerHTML);
        return _this.outPorts.html.disconnect();
      };
    })(this));
  }

  return ReadHtml;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadHtml;
};

});
require.register("noflo-noflo-dom/components/RemoveElement.js", function(exports, require, module){
var RemoveElement, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RemoveElement = (function(_super) {
  __extends(RemoveElement, _super);

  RemoveElement.prototype.description = 'Remove an element from DOM';

  function RemoveElement() {
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        if (!element.parentNode) {
          return;
        }
        return element.parentNode.removeChild(element);
      };
    })(this));
  }

  return RemoveElement;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveElement;
};

});
require.register("noflo-noflo-dom/components/SetAttribute.js", function(exports, require, module){
var SetAttribute, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetAttribute = (function(_super) {
  __extends(SetAttribute, _super);

  function SetAttribute() {
    this.attribute = null;
    this.value = null;
    this.element = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      attribute: new noflo.Port('string'),
      value: new noflo.Port('string')
    };
    this.outPorts = {
      element: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        _this.element = element;
        if (_this.attribute && _this.value) {
          return _this.setAttribute();
        }
      };
    })(this));
    this.inPorts.attribute.on('data', (function(_this) {
      return function(attribute) {
        _this.attribute = attribute;
        if (_this.element && _this.value) {
          return _this.setAttribute();
        }
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.value = _this.normalizeValue(value);
        if (_this.attribute && _this.element) {
          return _this.setAttribute();
        }
      };
    })(this));
  }

  SetAttribute.prototype.setAttribute = function() {
    this.element.setAttribute(this.attribute, this.value);
    this.value = null;
    if (this.outPorts.element.isAttached()) {
      this.outPorts.element.send(this.element);
      return this.outPorts.element.disconnect();
    }
  };

  SetAttribute.prototype.normalizeValue = function(value) {
    var key, newVal, val;
    if (typeof value === 'object') {
      if (toString.call(value) !== '[object Array]') {
        newVal = [];
        for (key in value) {
          val = value[key];
          newVal.push(val);
        }
        value = newVal;
      }
      return value.join(' ');
    }
    return value;
  };

  return SetAttribute;

})(noflo.Component);

exports.getComponent = function() {
  return new SetAttribute;
};

});
require.register("noflo-noflo-dom/components/WriteHtml.js", function(exports, require, module){
var WriteHtml, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

WriteHtml = (function(_super) {
  __extends(WriteHtml, _super);

  WriteHtml.prototype.description = 'Write HTML inside an existing element';

  function WriteHtml() {
    this.container = null;
    this.html = null;
    this.inPorts = {
      html: new noflo.Port('string'),
      container: new noflo.Port('object')
    };
    this.outPorts = {
      container: new noflo.Port('object')
    };
    this.inPorts.html.on('data', (function(_this) {
      return function(data) {
        _this.html = data;
        if (_this.container) {
          return _this.writeHtml();
        }
      };
    })(this));
    this.inPorts.container.on('data', (function(_this) {
      return function(data) {
        _this.container = data;
        if (_this.html !== null) {
          return _this.writeHtml();
        }
      };
    })(this));
  }

  WriteHtml.prototype.writeHtml = function() {
    this.container.innerHTML = this.html;
    this.html = null;
    if (this.outPorts.container.isAttached()) {
      this.outPorts.container.send(this.container);
      return this.outPorts.container.disconnect();
    }
  };

  return WriteHtml;

})(noflo.Component);

exports.getComponent = function() {
  return new WriteHtml;
};

});
require.register("noflo-noflo-dom/components/RemoveClass.js", function(exports, require, module){
var RemoveClass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RemoveClass = (function(_super) {
  __extends(RemoveClass, _super);

  RemoveClass.prototype.description = 'Remove a class from an element';

  function RemoveClass() {
    this.element = null;
    this["class"] = null;
    this.inPorts = {
      element: new noflo.Port('object'),
      "class": new noflo.Port('string')
    };
    this.outPorts = {};
    this.inPorts.element.on('data', (function(_this) {
      return function(data) {
        _this.element = data;
        if (_this["class"]) {
          return _this.removeClass();
        }
      };
    })(this));
    this.inPorts["class"].on('data', (function(_this) {
      return function(data) {
        _this["class"] = data;
        if (_this.element) {
          return _this.removeClass();
        }
      };
    })(this));
  }

  RemoveClass.prototype.removeClass = function() {
    return this.element.classList.remove(this["class"]);
  };

  return RemoveClass;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveClass;
};

});
require.register("noflo-noflo-dom/components/RequestAnimationFrame.js", function(exports, require, module){
var RequestAnimationFrame, noflo, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
  return window.setTimeout(function() {
    return callback(+new Date());
  }, 1000 / 60);
};

RequestAnimationFrame = (function(_super) {
  __extends(RequestAnimationFrame, _super);

  RequestAnimationFrame.prototype.description = 'Sends bangs that correspond with screen refresh rate.';

  RequestAnimationFrame.prototype.icon = 'film';

  function RequestAnimationFrame() {
    this.running = false;
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('bang')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function(data) {
        _this.running = true;
        return _this.animate();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function(data) {
        return _this.running = false;
      };
    })(this));
  }

  RequestAnimationFrame.prototype.animate = function() {
    if (this.running) {
      requestAnimationFrame(this.animate.bind(this));
      return this.outPorts.out.send(true);
    }
  };

  RequestAnimationFrame.prototype.shutdown = function() {
    return this.running = false;
  };

  return RequestAnimationFrame;

})(noflo.Component);

exports.getComponent = function() {
  return new RequestAnimationFrame;
};

});
require.register("noflo-noflo-flow/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of flow.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-flow/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-flow","description":"Flow Control for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-dom","version":"0.2.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Concat.coffee","components/Gate.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"random","components":{"Concat":"components/Concat.coffee","Gate":"components/Gate.coffee"}}}');
});
require.register("noflo-noflo-flow/components/Concat.js", function(exports, require, module){
var Concat, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Concat = (function(_super) {
  __extends(Concat, _super);

  Concat.prototype.description = 'Gathers data from all incoming connections and sends them together in order of connection';

  function Concat() {
    var subscribed;
    this.buffers = {};
    this.hasConnected = {};
    this.inPorts = {
      "in": new noflo.ArrayPort
    };
    this.outPorts = {
      out: new noflo.Port
    };
    subscribed = false;
    this.inPorts["in"].on('connect', (function(_this) {
      return function(socket) {
        var id, _i, _len, _ref;
        _this.hasConnected[_this.inPorts["in"].sockets.indexOf(socket)] = true;
        if (!subscribed) {
          _ref = _this.inPorts["in"].sockets;
          for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
            socket = _ref[id];
            _this.subscribeSocket(id);
          }
          return subscribed = true;
        }
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var socket, _i, _len, _ref;
        _ref = _this.inPorts["in"].sockets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          socket = _ref[_i];
          if (socket.isConnected()) {
            return;
          }
        }
        _this.clearBuffers();
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  Concat.prototype.clearBuffers = function() {
    var data, id, _ref;
    _ref = this.buffers;
    for (id in _ref) {
      data = _ref[id];
      if (!this.hasConnected[id]) {
        return;
      }
    }
    this.buffers = {};
    return this.hasConnected = {};
  };

  Concat.prototype.subscribeSocket = function(id) {
    this.buffers[id] = [];
    return this.inPorts["in"].sockets[id].on('data', (function(_this) {
      return function(data) {
        if (typeof _this.buffers[id] !== 'object') {
          _this.buffers[id] = [];
        }
        _this.buffers[id].push(data);
        return _this.checkSend();
      };
    })(this));
  };

  Concat.prototype.checkSend = function() {
    var buffer, id, socket, _i, _len, _ref, _ref1, _results;
    _ref = this.inPorts["in"].sockets;
    for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
      socket = _ref[id];
      if (!this.buffers[id]) {
        return;
      }
      if (!this.buffers[id].length) {
        return;
      }
    }
    _ref1 = this.buffers;
    _results = [];
    for (id in _ref1) {
      buffer = _ref1[id];
      _results.push(this.outPorts.out.send(buffer.shift()));
    }
    return _results;
  };

  return Concat;

})(noflo.Component);

exports.getComponent = function() {
  return new Concat;
};

});
require.register("noflo-noflo-flow/components/Gate.js", function(exports, require, module){
var Gate, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Gate = (function(_super) {
  __extends(Gate, _super);

  Gate.prototype.description = 'This component forwards received packets when the gate is open';

  Gate.prototype.icon = 'pause';

  function Gate() {
    this.open = false;
    this.inPorts = {
      "in": new noflo.Port('all'),
      open: new noflo.Port('bang'),
      close: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.connect();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (!_this.open) {
          return;
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.open.on('data', (function(_this) {
      return function() {
        _this.open = true;
        return _this.setIcon('play');
      };
    })(this));
    this.inPorts.close.on('data', (function(_this) {
      return function() {
        _this.open = false;
        _this.outPorts.out.disconnect();
        return _this.setIcon('pause');
      };
    })(this));
  }

  return Gate;

})(noflo.Component);

exports.getComponent = function() {
  return new Gate;
};

});
require.register("noflo-noflo-gestures/graphs/DetectDrag.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectDrag"},"exports":[{"private":"receivegesture_3bwyo.in","public":"in"},{"private":"checkmindistance_zsyhq.comparison","public":"distance"},{"private":"sendpass_lskxq.out","public":"pass"},{"private":"sendfail_64mm2.out","public":"fail"},{"private":"checkmaxspeed_sojti.comparison","public":"maxspeed"}],"processes":{"ReceiveGesture_3bwyo":{"component":"core/Repeat","metadata":{"x":-605,"y":82,"label":"ReceiveGesture"}},"core/Split_qfhom":{"component":"core/Split","metadata":{"x":-605,"y":159,"label":"core/Split"}},"SendPass_lskxq":{"component":"strings/SendString","metadata":{"x":1143,"y":28,"label":"SendPass"}},"SendFail_64mm2":{"component":"strings/SendString","metadata":{"x":1145,"y":305,"label":"SendFail"}},"Failures_13q8s":{"component":"core/Merge","metadata":{"x":941,"y":311,"label":"Failures"}},"GetDistance_bjx0s":{"component":"objects/GetObjectKey","metadata":{"x":526,"y":161,"label":"GetDistance"}},"CheckMinDistance_zsyhq":{"component":"math/Compare","metadata":{"x":900,"y":160,"label":"CheckMinDistance"}},"GetIndividualPointer_hv93t":{"component":"objects/SplitObject","metadata":{"x":-410,"y":159,"label":"GetIndividualPointer"}},"SplitDistance_vreyf":{"component":"core/Split","metadata":{"x":711.9999999999998,"y":160,"label":"SplitDistance"}},"SplitPointer_8rn9q":{"component":"core/Split","metadata":{"x":-223.5000000000008,"y":159.16666666666666,"label":"SplitPointer"}},"SendPointer_b4unv":{"component":"strings/SendString","metadata":{"x":340.3333333333328,"y":160.16666666666669,"label":"SendPointer"}},"GetSpeed_o56fp":{"component":"objects/GetObjectKey","metadata":{"x":-40.49999999999977,"y":159,"label":"GetSpeed"}},"CheckMaxSpeed_sojti":{"component":"math/Compare","metadata":{"x":150.50000000000023,"y":161,"label":"CheckMaxSpeed"}}},"connections":[{"src":{"process":"ReceiveGesture_3bwyo","port":"out"},"tgt":{"process":"core/Split_qfhom","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendPass_lskxq","port":"string"},"metadata":{"route":9}},{"src":{"process":"Failures_13q8s","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_bjx0s","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMinDistance_zsyhq","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"GetIndividualPointer_hv93t","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetDistance_bjx0s","port":"out"},"tgt":{"process":"SplitDistance_vreyf","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitDistance_vreyf","port":"out"},"tgt":{"process":"CheckMinDistance_zsyhq","port":"value"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_hv93t","port":"out"},"tgt":{"process":"SplitPointer_8rn9q","port":"in"},"metadata":{"route":8}},{"src":{"process":"CheckMinDistance_zsyhq","port":"pass"},"tgt":{"process":"SendPass_lskxq","port":"in"},"metadata":{"route":5}},{"src":{"process":"SendPointer_b4unv","port":"out"},"tgt":{"process":"GetDistance_bjx0s","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"SendPointer_b4unv","port":"string"},"metadata":{"route":9}},{"src":{"process":"CheckMaxSpeed_sojti","port":"pass"},"tgt":{"process":"SendPointer_b4unv","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_o56fp","port":"out"},"tgt":{"process":"CheckMaxSpeed_sojti","port":"value"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"GetSpeed_o56fp","port":"in"},"metadata":{"route":8}},{"src":{"process":"GetSpeed_o56fp","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMaxSpeed_sojti","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"data":"distance","tgt":{"process":"GetDistance_bjx0s","port":"key"}},{"data":">=","tgt":{"process":"CheckMinDistance_zsyhq","port":"operator"}},{"data":"<=","tgt":{"process":"CheckMaxSpeed_sojti","port":"operator"}},{"data":"speed","tgt":{"process":"GetSpeed_o56fp","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectSwipe.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectSwipe"},"exports":[{"private":"receivegesture_7fxc3.in","public":"in"},{"private":"sendpass_iuc21.out","public":"pass"},{"private":"sendfail_n9iay.out","public":"fail"},{"private":"checkspeed_cru21.comparison","public":"speed"},{"private":"checkdistance_786cc.comparison","public":"distance"}],"processes":{"ReceiveGesture_7fxc3":{"component":"core/Repeat","metadata":{"x":277,"y":124,"label":"ReceiveGesture"}},"GetIndividualPointer_9o878":{"component":"objects/SplitObject","metadata":{"x":473,"y":217,"label":"GetIndividualPointer"}},"SendPass_iuc21":{"component":"strings/SendString","metadata":{"x":2060,"y":113,"label":"SendPass"}},"GetSpeed_26n6h":{"component":"objects/GetObjectKey","metadata":{"x":863,"y":216,"label":"GetSpeed"}},"DetectionFailed_uj7oh":{"component":"core/Merge","metadata":{"x":1850,"y":337,"label":"DetectionFailed"}},"core/Split_cbjyy":{"component":"core/Split","metadata":{"x":273,"y":216,"label":"core/Split"}},"SendFail_n9iay":{"component":"strings/SendString","metadata":{"x":2062,"y":337.16666666666663,"label":"SendFail"}},"CheckSpeed_cru21":{"component":"math/Compare","metadata":{"x":1055.6666666666665,"y":215.66666666666666,"label":"CheckSpeed"}},"strings/SendString_75se6":{"component":"strings/SendString","metadata":{"x":1250.6666666666665,"y":216.66666666666666,"label":"strings/SendString"}},"GetDistance_zdjyf":{"component":"objects/GetObjectKey","metadata":{"x":1445.6666666666665,"y":215.66666666666666,"label":"GetDistance"}},"CheckDistance_786cc":{"component":"math/Compare","metadata":{"x":1648,"y":216,"label":"CheckDistance"}},"core/Split_x6p93":{"component":"core/Split","metadata":{"x":667.9999999999986,"y":215.66666666666663,"label":"core/Split"}}},"connections":[{"src":{"process":"GetSpeed_26n6h","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"pass"},"tgt":{"process":"strings/SendString_75se6","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_26n6h","port":"out"},"tgt":{"process":"CheckSpeed_cru21","port":"value"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"strings/SendString_75se6","port":"out"},"tgt":{"process":"GetDistance_zdjyf","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetDistance_zdjyf","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckDistance_786cc","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_zdjyf","port":"out"},"tgt":{"process":"CheckDistance_786cc","port":"value"},"metadata":{"route":5}},{"src":{"process":"CheckDistance_786cc","port":"pass"},"tgt":{"process":"SendPass_iuc21","port":"in"},"metadata":{"route":5}},{"src":{"process":"DetectionFailed_uj7oh","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReceiveGesture_7fxc3","port":"out"},"tgt":{"process":"core/Split_cbjyy","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendPass_iuc21","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"GetIndividualPointer_9o878","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_9o878","port":"out"},"tgt":{"process":"core/Split_x6p93","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"strings/SendString_75se6","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"GetSpeed_26n6h","port":"in"},"metadata":{"route":9}},{"data":"speed","tgt":{"process":"GetSpeed_26n6h","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_zdjyf","port":"key"}},{"data":">=","tgt":{"process":"CheckSpeed_cru21","port":"operator"}},{"data":">=","tgt":{"process":"CheckDistance_786cc","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectPinch.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectPinch"},"exports":[{"private":"core/split_ewbre.in","public":"in"},{"private":"sendpass_cf0pu.out","public":"pass"},{"private":"sendfail_vmi5n.out","public":"fail"}],"processes":{"core/Split_ewbre":{"component":"core/Split","metadata":{"x":740,"y":151,"label":"core/Split"}},"SendFail_vmi5n":{"component":"strings/SendString","metadata":{"x":1423,"y":259,"label":"SendFail"}},"SendPass_cf0pu":{"component":"strings/SendString","metadata":{"x":1421,"y":65,"label":"SendPass"}},"objects/Size_jjmmg":{"component":"objects/Size","metadata":{"x":939,"y":150,"label":"objects/Size"}},"math/Compare_hk3su":{"component":"math/Compare","metadata":{"x":1146,"y":147,"label":"math/Compare"}}},"connections":[{"src":{"process":"objects/Size_jjmmg","port":"out"},"tgt":{"process":"math/Compare_hk3su","port":"value"},"metadata":{"route":9}},{"src":{"process":"math/Compare_hk3su","port":"pass"},"tgt":{"process":"SendPass_cf0pu","port":"in"},"metadata":{"route":5}},{"src":{"process":"math/Compare_hk3su","port":"fail"},"tgt":{"process":"SendFail_vmi5n","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendFail_vmi5n","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendPass_cf0pu","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"objects/Size_jjmmg","port":"in"},"metadata":{"route":9}},{"data":1,"tgt":{"process":"math/Compare_hk3su","port":"comparison"}},{"data":">","tgt":{"process":"math/Compare_hk3su","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/FilterByTarget.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"FilterByTarget"},"exports":[{"private":"StartEvent_rjg24.in","public":"started"},{"private":"GetTarget_7cfim.object","public":"startevent"},{"private":"MoveEvent_reuhl.in","public":"move"},{"private":"VerifyTarget_ty3p5.accept","public":"accept"},{"private":"TargetElement_9tv87.out","public":"target"},{"private":"OnTarget_l85x9.out","public":"ontarget"},{"private":"AllowedMoves_y6ulv.out","public":"move"}],"processes":{"GetTarget_7cfim":{"component":"objects/GetObjectKey","metadata":{"x":634,"y":210,"label":"GetTarget"}},"MoveEvent_reuhl":{"component":"core/Repeat","metadata":{"x":425,"y":362,"label":"MoveEvent"}},"SplitTarget_sqlg0":{"component":"core/Split","metadata":{"x":836,"y":212,"label":"SplitTarget"}},"StartEvent_rjg24":{"component":"core/Repeat","metadata":{"x":426.00000000000006,"y":213,"label":"StartEvent"}},"VerifyTarget_ty3p5":{"component":"objects/FilterPropertyValue","metadata":{"x":1051.3333333333335,"y":211.33333333333331,"label":"VerifyTarget"}},"AllowedMoves_y6ulv":{"component":"flow/Gate","metadata":{"x":1508.6666666666665,"y":212.5,"label":"AllowedMoves"}},"SplitOnTarget_xmi67":{"component":"core/Split","metadata":{"x":1275.833333333334,"y":209.66666666666669,"label":"SplitOnTarget"}},"OnTarget_l85x9":{"component":"core/Repeat","metadata":{"x":1509.833333333334,"y":118.66666666666669,"label":"OnTarget"}},"TargetElement_9tv87":{"component":"core/Repeat","metadata":{"x":1507.833333333334,"y":26.666666666666686,"label":"TargetElement"}}},"connections":[{"src":{"process":"GetTarget_7cfim","port":"out"},"tgt":{"process":"SplitTarget_sqlg0","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartEvent_rjg24","port":"out"},"tgt":{"process":"GetTarget_7cfim","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"VerifyTarget_ty3p5","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveEvent_reuhl","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"in"},"metadata":{"route":2}},{"src":{"process":"VerifyTarget_ty3p5","port":"missed"},"tgt":{"process":"AllowedMoves_y6ulv","port":"close"},"metadata":{"route":1}},{"src":{"process":"VerifyTarget_ty3p5","port":"out"},"tgt":{"process":"SplitOnTarget_xmi67","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"OnTarget_l85x9","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"TargetElement_9tv87","port":"in"},"metadata":{"route":5}},{"data":"target","tgt":{"process":"GetTarget_7cfim","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/GestureToObject.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"Behavior"},"exports":[{"private":"listengestures_ns8li.element","public":"element"},{"private":"gesturedatatoobject_yh3yq.out","public":"out"}],"processes":{"ListenGestures_ns8li":{"component":"gestures/ListenGestures","metadata":{"x":609,"y":139,"label":"ListenGestures"}},"GestureDataToObject_yh3yq":{"component":"groups/CollectObject","metadata":{"x":1252,"y":159,"label":"GestureDataToObject"}},"SplitEnd_akdq1":{"component":"core/Split","metadata":{"x":847.1666666666667,"y":85.66666666666666,"label":"SplitEnd"}},"ClearOnEnd_9w9o":{"component":"core/RepeatAsync","metadata":{"x":1051.1666666666667,"y":88.66666666666666,"label":"ClearOnEnd"}},"SplitSpeed_2jnkm":{"component":"core/Split","metadata":{"x":849.5,"y":147.5,"label":"SplitSpeed"}},"SplitStart_hr2rx":{"component":"core/Split","metadata":{"x":845.833333333333,"y":23.50000000000003,"label":"SplitStart"}},"ReleaseMoveOrEnd_ahcs5":{"component":"core/Merge","metadata":{"x":1050.3333333333326,"y":157.83333333333331,"label":"ReleaseMoveOrEnd"}}},"connections":[{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ClearOnEnd_9w9o","port":"in"},"metadata":{"route":1}},{"src":{"process":"ClearOnEnd_9w9o","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"clear"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"end"},"tgt":{"process":"SplitEnd_akdq1","port":"in"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"start"},"tgt":{"process":"SplitStart_hr2rx","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitStart_hr2rx","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"startpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"elements"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":7}},{"src":{"process":"ListenGestures_ns8li","port":"angle"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"distance"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"movepoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"current"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"duration"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"endpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"speed"},"tgt":{"process":"SplitSpeed_2jnkm","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReleaseMoveOrEnd_ahcs5","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"release"},"metadata":{"route":8}},{"data":"elements","tgt":{"process":"GestureDataToObject_yh3yq","port":"allpackets"}},{"data":"startelement,startpoint,elements,angle,distance,speed,movepoint,current,duration,endelement,endpoint","tgt":{"process":"GestureDataToObject_yh3yq","port":"keys"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenGestures.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"ListenGestures"},"exports":[{"private":"gestures/listenpointer_8ftd1.element","public":"element"},{"private":"movepoint_fjlur.out","public":"movepoint"},{"private":"distance_kwk39.out","public":"distance"},{"private":"gestureelements_yvm9m.out","public":"elements"},{"private":"angle_43qpo.out","public":"angle"},{"private":"speed_e99jq.out","public":"speed"},{"private":"getstartelement_w7m64.out","public":"start"},{"private":"startpoint_u8int.out","public":"startpoint"},{"private":"getendelement_slbp9.out","public":"end"},{"private":"getendingpoint_dettb.client","public":"endpoint"},{"private":"currentelement_cu0q5.out","public":"current"},{"private":"duration_qyevv.out","public":"duration"}],"processes":{"GestureStart_r8vr5":{"component":"core/Split","metadata":{"x":466,"y":-31,"label":"GestureStart"}},"GetStartingPoint_pidfs":{"component":"interaction/ReadCoordinates","metadata":{"x":765,"y":-191,"label":"GetStartingPoint"}},"GetMovePoint_9dia9":{"component":"interaction/ReadCoordinates","metadata":{"x":1368,"y":136,"label":"GetMovePoint"}},"core/Split_baeeb":{"component":"core/Split","metadata":{"x":1563,"y":137,"label":"core/Split"}},"core/Split_4ds1h":{"component":"core/Split","metadata":{"x":973,"y":-191,"label":"core/Split"}},"GestureAngle_dwjj":{"component":"math/CalculateAngle","metadata":{"x":1939,"y":-127,"label":"GestureAngle"}},"GestureDistance_esqkc":{"component":"math/CalculateDistance","metadata":{"x":1934,"y":20,"label":"GestureDistance"}},"LastMove_p5yj7":{"component":"core/Kick","metadata":{"x":1062,"y":176,"label":"LastMove"}},"GestureEnd_qqx8o":{"component":"core/Split","metadata":{"x":460,"y":162,"label":"GestureEnd"}},"GestureMove_hy46s":{"component":"core/Split","metadata":{"x":463,"y":65,"label":"GestureMove"}},"AllTouchedElements_i3x74":{"component":"packets/UniquePacket","metadata":{"x":1445,"y":6,"label":"AllTouchedElements"}},"GetMoveElement_iaexm":{"component":"objects/GetObjectKey","metadata":{"x":1059,"y":6,"label":"GetMoveElement"}},"GetStartElement_w7m64":{"component":"objects/GetObjectKey","metadata":{"x":968,"y":-404.66666666666663,"label":"GetStartElement"}},"MoveDate_6bjnl":{"component":"objects/CreateDate","metadata":{"x":2145,"y":164,"label":"MoveDate"}},"StartDate_swbwu":{"component":"objects/CreateDate","metadata":{"x":968,"y":-281,"label":"StartDate"}},"math/Subtract_j5v20":{"component":"math/Subtract","metadata":{"x":2516,"y":-193,"label":"math/Subtract"}},"SetStart_ql51c":{"component":"strings/SendString","metadata":{"x":765,"y":-284,"label":"SetStart"}},"math/Divide_x4gc8":{"component":"math/Divide","metadata":{"x":2939,"y":-199,"label":"math/Divide"}},"core/Split_x0a12":{"component":"core/Split","metadata":{"x":2151,"y":23,"label":"core/Split"}},"objects/CallMethod_iu7k2":{"component":"objects/CallMethod","metadata":{"x":2348,"y":167,"label":"objects/CallMethod"}},"objects/CallMethod_rtfd2":{"component":"objects/CallMethod","metadata":{"x":2139,"y":-274,"label":"objects/CallMethod"}},"Distance_kwk39":{"component":"core/Repeat","metadata":{"x":2580,"y":20,"label":"Distance"}},"GestureElements_yvm9m":{"component":"core/Repeat","metadata":{"x":1639,"y":4,"label":"GestureElements"}},"Angle_43qpo":{"component":"core/Repeat","metadata":{"x":2312,"y":-121,"label":"Angle"}},"Speed_e99jq":{"component":"core/Repeat","metadata":{"x":3362,"y":-171,"label":"Speed"}},"MovePoint_fjlur":{"component":"core/Repeat","metadata":{"x":1939,"y":262,"label":"MovePoint"}},"StartPoint_u8int":{"component":"core/Repeat","metadata":{"x":1382,"y":-189,"label":"StartPoint"}},"gestures/ListenPointer_8ftd1":{"component":"gestures/ListenPointer","metadata":{"x":213,"y":-1,"label":"gestures/ListenPointer"}},"GetEndElement_slbp9":{"component":"objects/GetObjectKey","metadata":{"x":1367.3333333333335,"y":283.3333333333335,"label":"GetEndElement"}},"core/RepeatAsync_c56tj":{"component":"core/RepeatAsync","metadata":{"x":1058.666666666667,"y":312.33333333333326,"label":"core/RepeatAsync"}},"strings/SendString_t6gby":{"component":"strings/SendString","metadata":{"x":1935,"y":166.33333333333337,"label":"strings/SendString"}},"groups/SendByGroup_z06kk":{"component":"groups/SendByGroup","metadata":{"x":556,"y":-151.66666666666669,"label":"groups/SendByGroup"}},"core/Split_ekxij":{"component":"core/Split","metadata":{"x":3158.5,"y":-166.33333333333343,"label":"core/Split"}},"core/Split_eph3d":{"component":"core/Split","metadata":{"x":2123.333333333334,"y":-122.66666666666669,"label":"core/Split"}},"core/Split_3elep":{"component":"core/Split","metadata":{"x":2731.1666666666697,"y":-171.83333333333258,"label":"core/Split"}},"core/Split_8l3yu":{"component":"core/Split","metadata":{"x":1251.3333333333333,"y":7.166666666666629,"label":"core/Split"}},"CurrentElement_cu0q5":{"component":"core/Repeat","metadata":{"x":1599.833333333333,"y":-192.00000000000006,"label":"CurrentElement"}},"Duration_qyevv":{"component":"core/Repeat","metadata":{"x":2937.833333333333,"y":-295.83333333333326,"label":"Duration"}},"GetEndingPoint_dettb":{"component":"interaction/ReadCoordinates","metadata":{"x":727.8333333333331,"y":335.3333333333333,"label":"GetEndingPoint"}},"core/Merge_6so":{"component":"core/Merge","metadata":{"x":1196.666666666667,"y":-188.99999999999983,"label":"core/Merge"}},"interaction/ReadCoordinates_82cb1":{"component":"interaction/ReadCoordinates","metadata":{"x":767.3333333333339,"y":-85.83333333333314,"label":"interaction/ReadCoordinates"}},"core/Drop_sa8z5":{"component":"core/Drop","metadata":{"x":1596.833333333333,"y":326.0000000000001,"label":"core/Drop"}},"core/Merge_lqxll":{"component":"core/Merge","metadata":{"x":768.9999999999995,"y":-403.66666666666663,"label":"core/Merge"}},"groups/SendByGroup_8yaj":{"component":"groups/SendByGroup","metadata":{"x":1166.999999999999,"y":-286.83333333333326,"label":"groups/SendByGroup"}}},"connections":[{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"destination"},"metadata":{"route":3}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"destination"},"metadata":{"route":3}},{"src":{"process":"GetMovePoint_9dia9","port":"client"},"tgt":{"process":"core/Split_baeeb","port":"in"},"metadata":{"route":3}},{"src":{"process":"GetStartingPoint_pidfs","port":"client"},"tgt":{"process":"core/Split_4ds1h","port":"in"},"metadata":{"route":5}},{"src":{"process":"SetStart_ql51c","port":"out"},"tgt":{"process":"StartDate_swbwu","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureDistance_esqkc","port":"distance"},"tgt":{"process":"core/Split_x0a12","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"dividend"},"metadata":{"route":9}},{"src":{"process":"objects/CallMethod_iu7k2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"minuend"},"metadata":{"route":3}},{"src":{"process":"MoveDate_6bjnl","port":"out"},"tgt":{"process":"objects/CallMethod_iu7k2","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"Distance_kwk39","port":"in"},"metadata":{"route":9}},{"src":{"process":"AllTouchedElements_i3x74","port":"out"},"tgt":{"process":"GestureElements_yvm9m","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"MovePoint_fjlur","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"end"},"tgt":{"process":"GestureEnd_qqx8o","port":"in"},"metadata":{"route":1}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"move"},"tgt":{"process":"GestureMove_hy46s","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"start"},"tgt":{"process":"GestureStart_r8vr5","port":"in"},"metadata":{"route":5}},{"src":{"process":"LastMove_p5yj7","port":"out"},"tgt":{"process":"GetEndElement_slbp9","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"core/RepeatAsync_c56tj","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"strings/SendString_t6gby","port":"in"},"metadata":{"route":3}},{"src":{"process":"strings/SendString_t6gby","port":"out"},"tgt":{"process":"MoveDate_6bjnl","port":"in"},"metadata":{"route":4}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"GetStartingPoint_pidfs","port":"event"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"data"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMoveElement_iaexm","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMovePoint_9dia9","port":"event"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"Speed_e99jq","port":"in"},"metadata":{"route":8}},{"src":{"process":"math/Divide_x4gc8","port":"quotient"},"tgt":{"process":"core/Split_ekxij","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/RepeatAsync_c56tj","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"clear"},"metadata":{"route":1}},{"src":{"process":"GestureAngle_dwjj","port":"angle"},"tgt":{"process":"core/Split_eph3d","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"Angle_43qpo","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"clear"},"metadata":{"route":0}},{"src":{"process":"math/Subtract_j5v20","port":"difference"},"tgt":{"process":"core/Split_3elep","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"divisor"},"metadata":{"route":9}},{"src":{"process":"GetMoveElement_iaexm","port":"out"},"tgt":{"process":"core/Split_8l3yu","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"CurrentElement_cu0q5","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"Duration_qyevv","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"GetEndingPoint_dettb","port":"event"},"metadata":{"route":1}},{"src":{"process":"objects/CallMethod_rtfd2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"subtrahend"},"metadata":{"route":5}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_6so","port":"out"},"tgt":{"process":"StartPoint_u8int","port":"in"},"metadata":{"route":5}},{"src":{"process":"interaction/ReadCoordinates_82cb1","port":"client"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"interaction/ReadCoordinates_82cb1","port":"event"},"metadata":{"route":5}},{"src":{"process":"GetEndElement_slbp9","port":"missed"},"tgt":{"process":"core/Drop_sa8z5","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_lqxll","port":"out"},"tgt":{"process":"GetStartElement_w7m64","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_8yaj","port":"out"},"tgt":{"process":"objects/CallMethod_rtfd2","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartDate_swbwu","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"SetStart_ql51c","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"in"},"metadata":{"route":3}},{"data":"target","tgt":{"process":"GetMoveElement_iaexm","port":"key"}},{"data":"target","tgt":{"process":"GetStartElement_w7m64","port":"key"}},{"data":"now","tgt":{"process":"SetStart_ql51c","port":"string"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_iu7k2","port":"method"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_rtfd2","port":"method"}},{"data":"target","tgt":{"process":"GetEndElement_slbp9","port":"key"}},{"data":"now","tgt":{"process":"strings/SendString_t6gby","port":"string"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenPointer.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"ListenPointer"},"exports":[{"private":"Listen_1025g.element","public":"element"},{"private":"Listen_1025g.capture","public":"capture"},{"private":"StartEvent_x8itv.out","public":"start"},{"private":"MoveEvent_qa3pp.out","public":"move"},{"private":"EndEvent_hmwp9.out","public":"end"}],"processes":{"Listen_1025g":{"component":"interaction/ListenPointer","metadata":{"x":500,"y":-65,"label":"Listen"}},"End_vom22":{"component":"core/Merge","metadata":{"x":843,"y":96,"label":"End"}},"Start_86u3g":{"component":"core/Split","metadata":{"x":848,"y":-157,"label":"Start"}},"MoveOnlyDuringGesture_986zt":{"component":"flow/Gate","metadata":{"x":1106,"y":-40,"label":"MoveOnlyDuringGesture"}},"EndOnlyOnce_vexfn":{"component":"flow/Gate","metadata":{"x":1107,"y":75,"label":"EndOnlyOnce"}},"SplitEnd_cnfy6":{"component":"core/Split","metadata":{"x":1407,"y":79,"label":"SplitEnd"}},"Asynchronize_x0hqm":{"component":"core/RepeatAsync","metadata":{"x":1404,"y":171.33333333333331,"label":"Asynchronize"}},"StartEvent_x8itv":{"component":"core/Repeat","metadata":{"x":1662,"y":-162,"label":"StartEvent"}},"MoveEvent_qa3pp":{"component":"core/Repeat","metadata":{"x":1662,"y":-35,"label":"MoveEvent"}},"EndEvent_hmwp9":{"component":"core/Repeat","metadata":{"x":1659,"y":75,"label":"EndEvent"}}},"connections":[{"src":{"process":"Listen_1025g","port":"leave"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"cancel"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"up"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"down"},"tgt":{"process":"Start_86u3g","port":"in"},"metadata":{"route":5}},{"src":{"process":"Listen_1025g","port":"move"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"in"},"metadata":{"route":3}},{"src":{"process":"End_vom22","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"in"},"metadata":{"route":1}},{"src":{"process":"EndOnlyOnce_vexfn","port":"out"},"tgt":{"process":"SplitEnd_cnfy6","port":"in"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"Asynchronize_x0hqm","port":"in"},"metadata":{"route":1}},{"src":{"process":"Asynchronize_x0hqm","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"StartEvent_x8itv","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveOnlyDuringGesture_986zt","port":"out"},"tgt":{"process":"MoveEvent_qa3pp","port":"in"},"metadata":{"route":3}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"EndEvent_hmwp9","port":"in"},"metadata":{"route":1}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectCardinalDirection"},"exports":[{"private":"receivegesture_thbmw.in","public":"in"},{"private":"sendeast_218qx.out","public":"east"},{"private":"sendsouth_wx2b5.out","public":"south"},{"private":"sendwest_rkdz9.out","public":"west"},{"private":"sendnorth_c562k.out","public":"north"},{"private":"fail_5b0qo.out","public":"fail"},{"private":"checkmaxdistance_cebq5.comparison","public":"maxdistance"}],"processes":{"ReceiveGesture_thbmw":{"component":"core/Repeat","metadata":{"x":-294,"y":134,"label":"ReceiveGesture"}},"SplitGesture_dkk87":{"component":"core/Split","metadata":{"x":-296,"y":214,"label":"SplitGesture"}},"SendNorth_c562k":{"component":"strings/SendString","metadata":{"x":1733,"y":447,"label":"SendNorth"}},"SendEast_218qx":{"component":"strings/SendString","metadata":{"x":1721,"y":-5,"label":"SendEast"}},"RouteDirection_apgsp":{"component":"gestures/CardinalRouter","metadata":{"x":1469,"y":195,"label":"RouteDirection"}},"GetIndividualPointer_ozjfa":{"component":"objects/SplitObject","metadata":{"x":-86,"y":214,"label":"GetIndividualPointer"}},"GetStartPoint_bhrl2":{"component":"objects/GetObjectKey","metadata":{"x":879,"y":157,"label":"GetStartPoint"}},"GetCurrentPoint_rwwt0":{"component":"objects/GetObjectKey","metadata":{"x":877,"y":259,"label":"GetCurrentPoint"}},"GetGestureAngle_djpr6":{"component":"math/CalculateAngle","metadata":{"x":1083,"y":193,"label":"GetGestureAngle"}},"SendWest_rkdz9":{"component":"strings/SendString","metadata":{"x":1730.8333333333333,"y":348.33333333333337,"label":"SendWest"}},"SendSouth_wx2b5":{"component":"strings/SendString","metadata":{"x":1721.8333333333333,"y":107.33333333333337,"label":"SendSouth"}},"Fail_5b0qo":{"component":"core/Merge","metadata":{"x":1738.1666666666665,"y":564,"label":"Fail"}},"core/Split_n3qif":{"component":"core/Split","metadata":{"x":1276.999999999999,"y":193.66666666666669,"label":"core/Split"}},"GetDistance_owyyb":{"component":"objects/GetObjectKey","metadata":{"x":304,"y":216,"label":"GetDistance"}},"CheckMaxDistance_cebq5":{"component":"math/Compare","metadata":{"x":499,"y":214,"label":"CheckMaxDistance"}},"SendPointer_v0eqv":{"component":"strings/SendString","metadata":{"x":688,"y":214,"label":"SendPointer"}},"SplitPointer_v0u8k":{"component":"core/Split","metadata":{"x":109.00000000000006,"y":215.33333333333331,"label":"SplitPointer"}}},"connections":[{"src":{"process":"GetStartPoint_bhrl2","port":"object"},"tgt":{"process":"GetCurrentPoint_rwwt0","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetStartPoint_bhrl2","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"origin"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"destination"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendEast_218qx","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendWest_rkdz9","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendNorth_c562k","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendSouth_wx2b5","port":"string"},"metadata":{"route":9}},{"src":{"process":"RouteDirection_apgsp","port":"n"},"tgt":{"process":"SendNorth_c562k","port":"in"},"metadata":{"route":4}},{"src":{"process":"RouteDirection_apgsp","port":"w"},"tgt":{"process":"SendWest_rkdz9","port":"in"},"metadata":{"route":5}},{"src":{"process":"RouteDirection_apgsp","port":"s"},"tgt":{"process":"SendSouth_wx2b5","port":"in"},"metadata":{"route":6}},{"src":{"process":"RouteDirection_apgsp","port":"e"},"tgt":{"process":"SendEast_218qx","port":"in"},"metadata":{"route":7}},{"src":{"process":"ReceiveGesture_thbmw","port":"out"},"tgt":{"process":"SplitGesture_dkk87","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"GetIndividualPointer_ozjfa","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetStartPoint_bhrl2","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetGestureAngle_djpr6","port":"angle"},"tgt":{"process":"core/Split_n3qif","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"RouteDirection_apgsp","port":"degrees"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GetIndividualPointer_ozjfa","port":"out"},"tgt":{"process":"SplitPointer_v0u8k","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"SendPointer_v0eqv","port":"string"},"metadata":{"route":9}},{"src":{"process":"SendPointer_v0eqv","port":"out"},"tgt":{"process":"GetStartPoint_bhrl2","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"pass"},"tgt":{"process":"SendPointer_v0eqv","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"fail"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_owyyb","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"GetDistance_owyyb","port":"in"},"metadata":{"route":0}},{"src":{"process":"GetDistance_owyyb","port":"out"},"tgt":{"process":"CheckMaxDistance_cebq5","port":"value"},"metadata":{"route":9}},{"data":"startpoint","tgt":{"process":"GetStartPoint_bhrl2","port":"key"}},{"data":"movepoint","tgt":{"process":"GetCurrentPoint_rwwt0","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_owyyb","port":"key"}},{"data":"<=","tgt":{"process":"CheckMaxDistance_cebq5","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-gestures.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-gestures/graphs/DetectDrag.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectDrag"},"exports":[{"private":"receivegesture_3bwyo.in","public":"in"},{"private":"checkmindistance_zsyhq.comparison","public":"distance"},{"private":"sendpass_lskxq.out","public":"pass"},{"private":"sendfail_64mm2.out","public":"fail"},{"private":"checkmaxspeed_sojti.comparison","public":"maxspeed"}],"processes":{"ReceiveGesture_3bwyo":{"component":"core/Repeat","metadata":{"x":-605,"y":82,"label":"ReceiveGesture"}},"core/Split_qfhom":{"component":"core/Split","metadata":{"x":-605,"y":159,"label":"core/Split"}},"SendPass_lskxq":{"component":"strings/SendString","metadata":{"x":1143,"y":28,"label":"SendPass"}},"SendFail_64mm2":{"component":"strings/SendString","metadata":{"x":1145,"y":305,"label":"SendFail"}},"Failures_13q8s":{"component":"core/Merge","metadata":{"x":941,"y":311,"label":"Failures"}},"GetDistance_bjx0s":{"component":"objects/GetObjectKey","metadata":{"x":526,"y":161,"label":"GetDistance"}},"CheckMinDistance_zsyhq":{"component":"math/Compare","metadata":{"x":900,"y":160,"label":"CheckMinDistance"}},"GetIndividualPointer_hv93t":{"component":"objects/SplitObject","metadata":{"x":-410,"y":159,"label":"GetIndividualPointer"}},"SplitDistance_vreyf":{"component":"core/Split","metadata":{"x":711.9999999999998,"y":160,"label":"SplitDistance"}},"SplitPointer_8rn9q":{"component":"core/Split","metadata":{"x":-223.5000000000008,"y":159.16666666666666,"label":"SplitPointer"}},"SendPointer_b4unv":{"component":"strings/SendString","metadata":{"x":340.3333333333328,"y":160.16666666666669,"label":"SendPointer"}},"GetSpeed_o56fp":{"component":"objects/GetObjectKey","metadata":{"x":-40.49999999999977,"y":159,"label":"GetSpeed"}},"CheckMaxSpeed_sojti":{"component":"math/Compare","metadata":{"x":150.50000000000023,"y":161,"label":"CheckMaxSpeed"}}},"connections":[{"src":{"process":"ReceiveGesture_3bwyo","port":"out"},"tgt":{"process":"core/Split_qfhom","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"SendPass_lskxq","port":"string"},"metadata":{"route":9}},{"src":{"process":"Failures_13q8s","port":"out"},"tgt":{"process":"SendFail_64mm2","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_bjx0s","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMinDistance_zsyhq","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_qfhom","port":"out"},"tgt":{"process":"GetIndividualPointer_hv93t","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetDistance_bjx0s","port":"out"},"tgt":{"process":"SplitDistance_vreyf","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitDistance_vreyf","port":"out"},"tgt":{"process":"CheckMinDistance_zsyhq","port":"value"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_hv93t","port":"out"},"tgt":{"process":"SplitPointer_8rn9q","port":"in"},"metadata":{"route":8}},{"src":{"process":"CheckMinDistance_zsyhq","port":"pass"},"tgt":{"process":"SendPass_lskxq","port":"in"},"metadata":{"route":5}},{"src":{"process":"SendPointer_b4unv","port":"out"},"tgt":{"process":"GetDistance_bjx0s","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"SendPointer_b4unv","port":"string"},"metadata":{"route":9}},{"src":{"process":"CheckMaxSpeed_sojti","port":"pass"},"tgt":{"process":"SendPointer_b4unv","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_o56fp","port":"out"},"tgt":{"process":"CheckMaxSpeed_sojti","port":"value"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_8rn9q","port":"out"},"tgt":{"process":"GetSpeed_o56fp","port":"in"},"metadata":{"route":8}},{"src":{"process":"GetSpeed_o56fp","port":"missed"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckMaxSpeed_sojti","port":"fail"},"tgt":{"process":"Failures_13q8s","port":"in"},"metadata":{"route":1}},{"data":"distance","tgt":{"process":"GetDistance_bjx0s","port":"key"}},{"data":">=","tgt":{"process":"CheckMinDistance_zsyhq","port":"operator"}},{"data":"<=","tgt":{"process":"CheckMaxSpeed_sojti","port":"operator"}},{"data":"speed","tgt":{"process":"GetSpeed_o56fp","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectSwipe.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectSwipe"},"exports":[{"private":"receivegesture_7fxc3.in","public":"in"},{"private":"sendpass_iuc21.out","public":"pass"},{"private":"sendfail_n9iay.out","public":"fail"},{"private":"checkspeed_cru21.comparison","public":"speed"},{"private":"checkdistance_786cc.comparison","public":"distance"}],"processes":{"ReceiveGesture_7fxc3":{"component":"core/Repeat","metadata":{"x":277,"y":124,"label":"ReceiveGesture"}},"GetIndividualPointer_9o878":{"component":"objects/SplitObject","metadata":{"x":473,"y":217,"label":"GetIndividualPointer"}},"SendPass_iuc21":{"component":"strings/SendString","metadata":{"x":2060,"y":113,"label":"SendPass"}},"GetSpeed_26n6h":{"component":"objects/GetObjectKey","metadata":{"x":863,"y":216,"label":"GetSpeed"}},"DetectionFailed_uj7oh":{"component":"core/Merge","metadata":{"x":1850,"y":337,"label":"DetectionFailed"}},"core/Split_cbjyy":{"component":"core/Split","metadata":{"x":273,"y":216,"label":"core/Split"}},"SendFail_n9iay":{"component":"strings/SendString","metadata":{"x":2062,"y":337.16666666666663,"label":"SendFail"}},"CheckSpeed_cru21":{"component":"math/Compare","metadata":{"x":1055.6666666666665,"y":215.66666666666666,"label":"CheckSpeed"}},"strings/SendString_75se6":{"component":"strings/SendString","metadata":{"x":1250.6666666666665,"y":216.66666666666666,"label":"strings/SendString"}},"GetDistance_zdjyf":{"component":"objects/GetObjectKey","metadata":{"x":1445.6666666666665,"y":215.66666666666666,"label":"GetDistance"}},"CheckDistance_786cc":{"component":"math/Compare","metadata":{"x":1648,"y":216,"label":"CheckDistance"}},"core/Split_x6p93":{"component":"core/Split","metadata":{"x":667.9999999999986,"y":215.66666666666663,"label":"core/Split"}}},"connections":[{"src":{"process":"GetSpeed_26n6h","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"pass"},"tgt":{"process":"strings/SendString_75se6","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetSpeed_26n6h","port":"out"},"tgt":{"process":"CheckSpeed_cru21","port":"value"},"metadata":{"route":1}},{"src":{"process":"CheckSpeed_cru21","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"strings/SendString_75se6","port":"out"},"tgt":{"process":"GetDistance_zdjyf","port":"in"},"metadata":{"route":5}},{"src":{"process":"GetDistance_zdjyf","port":"missed"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"CheckDistance_786cc","port":"fail"},"tgt":{"process":"DetectionFailed_uj7oh","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_zdjyf","port":"out"},"tgt":{"process":"CheckDistance_786cc","port":"value"},"metadata":{"route":5}},{"src":{"process":"CheckDistance_786cc","port":"pass"},"tgt":{"process":"SendPass_iuc21","port":"in"},"metadata":{"route":5}},{"src":{"process":"DetectionFailed_uj7oh","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReceiveGesture_7fxc3","port":"out"},"tgt":{"process":"core/Split_cbjyy","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendPass_iuc21","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"SendFail_n9iay","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_cbjyy","port":"out"},"tgt":{"process":"GetIndividualPointer_9o878","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetIndividualPointer_9o878","port":"out"},"tgt":{"process":"core/Split_x6p93","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"strings/SendString_75se6","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_x6p93","port":"out"},"tgt":{"process":"GetSpeed_26n6h","port":"in"},"metadata":{"route":9}},{"data":"speed","tgt":{"process":"GetSpeed_26n6h","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_zdjyf","port":"key"}},{"data":">=","tgt":{"process":"CheckSpeed_cru21","port":"operator"}},{"data":">=","tgt":{"process":"CheckDistance_786cc","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectPinch.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectPinch"},"exports":[{"private":"core/split_ewbre.in","public":"in"},{"private":"sendpass_cf0pu.out","public":"pass"},{"private":"sendfail_vmi5n.out","public":"fail"}],"processes":{"core/Split_ewbre":{"component":"core/Split","metadata":{"x":740,"y":151,"label":"core/Split"}},"SendFail_vmi5n":{"component":"strings/SendString","metadata":{"x":1423,"y":259,"label":"SendFail"}},"SendPass_cf0pu":{"component":"strings/SendString","metadata":{"x":1421,"y":65,"label":"SendPass"}},"objects/Size_jjmmg":{"component":"objects/Size","metadata":{"x":939,"y":150,"label":"objects/Size"}},"math/Compare_hk3su":{"component":"math/Compare","metadata":{"x":1146,"y":147,"label":"math/Compare"}}},"connections":[{"src":{"process":"objects/Size_jjmmg","port":"out"},"tgt":{"process":"math/Compare_hk3su","port":"value"},"metadata":{"route":9}},{"src":{"process":"math/Compare_hk3su","port":"pass"},"tgt":{"process":"SendPass_cf0pu","port":"in"},"metadata":{"route":5}},{"src":{"process":"math/Compare_hk3su","port":"fail"},"tgt":{"process":"SendFail_vmi5n","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendFail_vmi5n","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"SendPass_cf0pu","port":"string"},"metadata":{"route":9}},{"src":{"process":"core/Split_ewbre","port":"out"},"tgt":{"process":"objects/Size_jjmmg","port":"in"},"metadata":{"route":9}},{"data":1,"tgt":{"process":"math/Compare_hk3su","port":"comparison"}},{"data":">","tgt":{"process":"math/Compare_hk3su","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/graphs/FilterByTarget.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"FilterByTarget"},"exports":[{"private":"StartEvent_rjg24.in","public":"started"},{"private":"GetTarget_7cfim.object","public":"startevent"},{"private":"MoveEvent_reuhl.in","public":"move"},{"private":"VerifyTarget_ty3p5.accept","public":"accept"},{"private":"TargetElement_9tv87.out","public":"target"},{"private":"OnTarget_l85x9.out","public":"ontarget"},{"private":"AllowedMoves_y6ulv.out","public":"move"}],"processes":{"GetTarget_7cfim":{"component":"objects/GetObjectKey","metadata":{"x":634,"y":210,"label":"GetTarget"}},"MoveEvent_reuhl":{"component":"core/Repeat","metadata":{"x":425,"y":362,"label":"MoveEvent"}},"SplitTarget_sqlg0":{"component":"core/Split","metadata":{"x":836,"y":212,"label":"SplitTarget"}},"StartEvent_rjg24":{"component":"core/Repeat","metadata":{"x":426.00000000000006,"y":213,"label":"StartEvent"}},"VerifyTarget_ty3p5":{"component":"objects/FilterPropertyValue","metadata":{"x":1051.3333333333335,"y":211.33333333333331,"label":"VerifyTarget"}},"AllowedMoves_y6ulv":{"component":"flow/Gate","metadata":{"x":1508.6666666666665,"y":212.5,"label":"AllowedMoves"}},"SplitOnTarget_xmi67":{"component":"core/Split","metadata":{"x":1275.833333333334,"y":209.66666666666669,"label":"SplitOnTarget"}},"OnTarget_l85x9":{"component":"core/Repeat","metadata":{"x":1509.833333333334,"y":118.66666666666669,"label":"OnTarget"}},"TargetElement_9tv87":{"component":"core/Repeat","metadata":{"x":1507.833333333334,"y":26.666666666666686,"label":"TargetElement"}}},"connections":[{"src":{"process":"GetTarget_7cfim","port":"out"},"tgt":{"process":"SplitTarget_sqlg0","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartEvent_rjg24","port":"out"},"tgt":{"process":"GetTarget_7cfim","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"VerifyTarget_ty3p5","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveEvent_reuhl","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"in"},"metadata":{"route":2}},{"src":{"process":"VerifyTarget_ty3p5","port":"missed"},"tgt":{"process":"AllowedMoves_y6ulv","port":"close"},"metadata":{"route":1}},{"src":{"process":"VerifyTarget_ty3p5","port":"out"},"tgt":{"process":"SplitOnTarget_xmi67","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"AllowedMoves_y6ulv","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitOnTarget_xmi67","port":"out"},"tgt":{"process":"OnTarget_l85x9","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitTarget_sqlg0","port":"out"},"tgt":{"process":"TargetElement_9tv87","port":"in"},"metadata":{"route":5}},{"data":"target","tgt":{"process":"GetTarget_7cfim","port":"key"}}]}');
});
require.register("noflo-noflo-gestures/graphs/GestureToObject.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"Behavior"},"exports":[{"private":"listengestures_ns8li.element","public":"element"},{"private":"gesturedatatoobject_yh3yq.out","public":"out"}],"processes":{"ListenGestures_ns8li":{"component":"gestures/ListenGestures","metadata":{"x":609,"y":139,"label":"ListenGestures"}},"GestureDataToObject_yh3yq":{"component":"groups/CollectObject","metadata":{"x":1252,"y":159,"label":"GestureDataToObject"}},"SplitEnd_akdq1":{"component":"core/Split","metadata":{"x":847.1666666666667,"y":85.66666666666666,"label":"SplitEnd"}},"ClearOnEnd_9w9o":{"component":"core/RepeatAsync","metadata":{"x":1051.1666666666667,"y":88.66666666666666,"label":"ClearOnEnd"}},"SplitSpeed_2jnkm":{"component":"core/Split","metadata":{"x":849.5,"y":147.5,"label":"SplitSpeed"}},"SplitStart_hr2rx":{"component":"core/Split","metadata":{"x":845.833333333333,"y":23.50000000000003,"label":"SplitStart"}},"ReleaseMoveOrEnd_ahcs5":{"component":"core/Merge","metadata":{"x":1050.3333333333326,"y":157.83333333333331,"label":"ReleaseMoveOrEnd"}}},"connections":[{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ClearOnEnd_9w9o","port":"in"},"metadata":{"route":1}},{"src":{"process":"ClearOnEnd_9w9o","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"clear"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"end"},"tgt":{"process":"SplitEnd_akdq1","port":"in"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"start"},"tgt":{"process":"SplitStart_hr2rx","port":"in"},"metadata":{"route":5}},{"src":{"process":"SplitStart_hr2rx","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"startpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":5}},{"src":{"process":"ListenGestures_ns8li","port":"elements"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":7}},{"src":{"process":"ListenGestures_ns8li","port":"angle"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"distance"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"ListenGestures_ns8li","port":"movepoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"current"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":3}},{"src":{"process":"ListenGestures_ns8li","port":"duration"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":9}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"endpoint"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"collect"},"metadata":{"route":1}},{"src":{"process":"ListenGestures_ns8li","port":"speed"},"tgt":{"process":"SplitSpeed_2jnkm","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitSpeed_2jnkm","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":8}},{"src":{"process":"SplitEnd_akdq1","port":"out"},"tgt":{"process":"ReleaseMoveOrEnd_ahcs5","port":"in"},"metadata":{"route":1}},{"src":{"process":"ReleaseMoveOrEnd_ahcs5","port":"out"},"tgt":{"process":"GestureDataToObject_yh3yq","port":"release"},"metadata":{"route":8}},{"data":"elements","tgt":{"process":"GestureDataToObject_yh3yq","port":"allpackets"}},{"data":"startelement,startpoint,elements,angle,distance,speed,movepoint,current,duration,endelement,endpoint","tgt":{"process":"GestureDataToObject_yh3yq","port":"keys"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenGestures.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"ListenGestures"},"exports":[{"private":"gestures/listenpointer_8ftd1.element","public":"element"},{"private":"movepoint_fjlur.out","public":"movepoint"},{"private":"distance_kwk39.out","public":"distance"},{"private":"gestureelements_yvm9m.out","public":"elements"},{"private":"angle_43qpo.out","public":"angle"},{"private":"speed_e99jq.out","public":"speed"},{"private":"getstartelement_w7m64.out","public":"start"},{"private":"startpoint_u8int.out","public":"startpoint"},{"private":"getendelement_slbp9.out","public":"end"},{"private":"getendingpoint_dettb.client","public":"endpoint"},{"private":"currentelement_cu0q5.out","public":"current"},{"private":"duration_qyevv.out","public":"duration"}],"processes":{"GestureStart_r8vr5":{"component":"core/Split","metadata":{"x":466,"y":-31,"label":"GestureStart"}},"GetStartingPoint_pidfs":{"component":"interaction/ReadCoordinates","metadata":{"x":765,"y":-191,"label":"GetStartingPoint"}},"GetMovePoint_9dia9":{"component":"interaction/ReadCoordinates","metadata":{"x":1368,"y":136,"label":"GetMovePoint"}},"core/Split_baeeb":{"component":"core/Split","metadata":{"x":1563,"y":137,"label":"core/Split"}},"core/Split_4ds1h":{"component":"core/Split","metadata":{"x":973,"y":-191,"label":"core/Split"}},"GestureAngle_dwjj":{"component":"math/CalculateAngle","metadata":{"x":1939,"y":-127,"label":"GestureAngle"}},"GestureDistance_esqkc":{"component":"math/CalculateDistance","metadata":{"x":1934,"y":20,"label":"GestureDistance"}},"LastMove_p5yj7":{"component":"core/Kick","metadata":{"x":1062,"y":176,"label":"LastMove"}},"GestureEnd_qqx8o":{"component":"core/Split","metadata":{"x":460,"y":162,"label":"GestureEnd"}},"GestureMove_hy46s":{"component":"core/Split","metadata":{"x":463,"y":65,"label":"GestureMove"}},"AllTouchedElements_i3x74":{"component":"packets/UniquePacket","metadata":{"x":1445,"y":6,"label":"AllTouchedElements"}},"GetMoveElement_iaexm":{"component":"objects/GetObjectKey","metadata":{"x":1059,"y":6,"label":"GetMoveElement"}},"GetStartElement_w7m64":{"component":"objects/GetObjectKey","metadata":{"x":968,"y":-404.66666666666663,"label":"GetStartElement"}},"MoveDate_6bjnl":{"component":"objects/CreateDate","metadata":{"x":2145,"y":164,"label":"MoveDate"}},"StartDate_swbwu":{"component":"objects/CreateDate","metadata":{"x":968,"y":-281,"label":"StartDate"}},"math/Subtract_j5v20":{"component":"math/Subtract","metadata":{"x":2516,"y":-193,"label":"math/Subtract"}},"SetStart_ql51c":{"component":"strings/SendString","metadata":{"x":765,"y":-284,"label":"SetStart"}},"math/Divide_x4gc8":{"component":"math/Divide","metadata":{"x":2939,"y":-199,"label":"math/Divide"}},"core/Split_x0a12":{"component":"core/Split","metadata":{"x":2151,"y":23,"label":"core/Split"}},"objects/CallMethod_iu7k2":{"component":"objects/CallMethod","metadata":{"x":2348,"y":167,"label":"objects/CallMethod"}},"objects/CallMethod_rtfd2":{"component":"objects/CallMethod","metadata":{"x":2139,"y":-274,"label":"objects/CallMethod"}},"Distance_kwk39":{"component":"core/Repeat","metadata":{"x":2580,"y":20,"label":"Distance"}},"GestureElements_yvm9m":{"component":"core/Repeat","metadata":{"x":1639,"y":4,"label":"GestureElements"}},"Angle_43qpo":{"component":"core/Repeat","metadata":{"x":2312,"y":-121,"label":"Angle"}},"Speed_e99jq":{"component":"core/Repeat","metadata":{"x":3362,"y":-171,"label":"Speed"}},"MovePoint_fjlur":{"component":"core/Repeat","metadata":{"x":1939,"y":262,"label":"MovePoint"}},"StartPoint_u8int":{"component":"core/Repeat","metadata":{"x":1382,"y":-189,"label":"StartPoint"}},"gestures/ListenPointer_8ftd1":{"component":"gestures/ListenPointer","metadata":{"x":213,"y":-1,"label":"gestures/ListenPointer"}},"GetEndElement_slbp9":{"component":"objects/GetObjectKey","metadata":{"x":1367.3333333333335,"y":283.3333333333335,"label":"GetEndElement"}},"core/RepeatAsync_c56tj":{"component":"core/RepeatAsync","metadata":{"x":1058.666666666667,"y":312.33333333333326,"label":"core/RepeatAsync"}},"strings/SendString_t6gby":{"component":"strings/SendString","metadata":{"x":1935,"y":166.33333333333337,"label":"strings/SendString"}},"groups/SendByGroup_z06kk":{"component":"groups/SendByGroup","metadata":{"x":556,"y":-151.66666666666669,"label":"groups/SendByGroup"}},"core/Split_ekxij":{"component":"core/Split","metadata":{"x":3158.5,"y":-166.33333333333343,"label":"core/Split"}},"core/Split_eph3d":{"component":"core/Split","metadata":{"x":2123.333333333334,"y":-122.66666666666669,"label":"core/Split"}},"core/Split_3elep":{"component":"core/Split","metadata":{"x":2731.1666666666697,"y":-171.83333333333258,"label":"core/Split"}},"core/Split_8l3yu":{"component":"core/Split","metadata":{"x":1251.3333333333333,"y":7.166666666666629,"label":"core/Split"}},"CurrentElement_cu0q5":{"component":"core/Repeat","metadata":{"x":1599.833333333333,"y":-192.00000000000006,"label":"CurrentElement"}},"Duration_qyevv":{"component":"core/Repeat","metadata":{"x":2937.833333333333,"y":-295.83333333333326,"label":"Duration"}},"GetEndingPoint_dettb":{"component":"interaction/ReadCoordinates","metadata":{"x":727.8333333333331,"y":335.3333333333333,"label":"GetEndingPoint"}},"core/Merge_6so":{"component":"core/Merge","metadata":{"x":1196.666666666667,"y":-188.99999999999983,"label":"core/Merge"}},"interaction/ReadCoordinates_82cb1":{"component":"interaction/ReadCoordinates","metadata":{"x":767.3333333333339,"y":-85.83333333333314,"label":"interaction/ReadCoordinates"}},"core/Drop_sa8z5":{"component":"core/Drop","metadata":{"x":1596.833333333333,"y":326.0000000000001,"label":"core/Drop"}},"core/Merge_lqxll":{"component":"core/Merge","metadata":{"x":768.9999999999995,"y":-403.66666666666663,"label":"core/Merge"}},"groups/SendByGroup_8yaj":{"component":"groups/SendByGroup","metadata":{"x":1166.999999999999,"y":-286.83333333333326,"label":"groups/SendByGroup"}}},"connections":[{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"destination"},"metadata":{"route":3}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"origin"},"metadata":{"route":5}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"destination"},"metadata":{"route":3}},{"src":{"process":"GetMovePoint_9dia9","port":"client"},"tgt":{"process":"core/Split_baeeb","port":"in"},"metadata":{"route":3}},{"src":{"process":"GetStartingPoint_pidfs","port":"client"},"tgt":{"process":"core/Split_4ds1h","port":"in"},"metadata":{"route":5}},{"src":{"process":"SetStart_ql51c","port":"out"},"tgt":{"process":"StartDate_swbwu","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureDistance_esqkc","port":"distance"},"tgt":{"process":"core/Split_x0a12","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"dividend"},"metadata":{"route":9}},{"src":{"process":"objects/CallMethod_iu7k2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"minuend"},"metadata":{"route":3}},{"src":{"process":"MoveDate_6bjnl","port":"out"},"tgt":{"process":"objects/CallMethod_iu7k2","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"Distance_kwk39","port":"in"},"metadata":{"route":9}},{"src":{"process":"AllTouchedElements_i3x74","port":"out"},"tgt":{"process":"GestureElements_yvm9m","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"MovePoint_fjlur","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"end"},"tgt":{"process":"GestureEnd_qqx8o","port":"in"},"metadata":{"route":1}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"move"},"tgt":{"process":"GestureMove_hy46s","port":"in"},"metadata":{"route":3}},{"src":{"process":"gestures/ListenPointer_8ftd1","port":"start"},"tgt":{"process":"GestureStart_r8vr5","port":"in"},"metadata":{"route":5}},{"src":{"process":"LastMove_p5yj7","port":"out"},"tgt":{"process":"GetEndElement_slbp9","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"core/RepeatAsync_c56tj","port":"in"},"metadata":{"route":1}},{"src":{"process":"core/Split_baeeb","port":"out"},"tgt":{"process":"strings/SendString_t6gby","port":"in"},"metadata":{"route":3}},{"src":{"process":"strings/SendString_t6gby","port":"out"},"tgt":{"process":"MoveDate_6bjnl","port":"in"},"metadata":{"route":4}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"GetStartingPoint_pidfs","port":"event"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_z06kk","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"LastMove_p5yj7","port":"data"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMoveElement_iaexm","port":"in"},"metadata":{"route":3}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"GetMovePoint_9dia9","port":"event"},"metadata":{"route":3}},{"src":{"process":"core/Split_x0a12","port":"out"},"tgt":{"process":"GestureDistance_esqkc","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"Speed_e99jq","port":"in"},"metadata":{"route":8}},{"src":{"process":"math/Divide_x4gc8","port":"quotient"},"tgt":{"process":"core/Split_ekxij","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_ekxij","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"clear"},"metadata":{"route":0}},{"src":{"process":"core/RepeatAsync_c56tj","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"clear"},"metadata":{"route":1}},{"src":{"process":"GestureAngle_dwjj","port":"angle"},"tgt":{"process":"core/Split_eph3d","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"Angle_43qpo","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_eph3d","port":"out"},"tgt":{"process":"GestureAngle_dwjj","port":"clear"},"metadata":{"route":0}},{"src":{"process":"math/Subtract_j5v20","port":"difference"},"tgt":{"process":"core/Split_3elep","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Divide_x4gc8","port":"divisor"},"metadata":{"route":9}},{"src":{"process":"GetMoveElement_iaexm","port":"out"},"tgt":{"process":"core/Split_8l3yu","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"AllTouchedElements_i3x74","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_8l3yu","port":"out"},"tgt":{"process":"CurrentElement_cu0q5","port":"in"},"metadata":{"route":3}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"Duration_qyevv","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_3elep","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GestureEnd_qqx8o","port":"out"},"tgt":{"process":"GetEndingPoint_dettb","port":"event"},"metadata":{"route":1}},{"src":{"process":"objects/CallMethod_rtfd2","port":"out"},"tgt":{"process":"math/Subtract_j5v20","port":"subtrahend"},"metadata":{"route":5}},{"src":{"process":"core/Split_4ds1h","port":"out"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_6so","port":"out"},"tgt":{"process":"StartPoint_u8int","port":"in"},"metadata":{"route":5}},{"src":{"process":"interaction/ReadCoordinates_82cb1","port":"client"},"tgt":{"process":"core/Merge_6so","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"interaction/ReadCoordinates_82cb1","port":"event"},"metadata":{"route":5}},{"src":{"process":"GetEndElement_slbp9","port":"missed"},"tgt":{"process":"core/Drop_sa8z5","port":"in"},"metadata":{"route":1}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"core/Merge_lqxll","port":"out"},"tgt":{"process":"GetStartElement_w7m64","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_z06kk","port":"out"},"tgt":{"process":"core/Merge_lqxll","port":"in"},"metadata":{"route":5}},{"src":{"process":"groups/SendByGroup_8yaj","port":"out"},"tgt":{"process":"objects/CallMethod_rtfd2","port":"in"},"metadata":{"route":5}},{"src":{"process":"StartDate_swbwu","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"data"},"metadata":{"route":5}},{"src":{"process":"GestureStart_r8vr5","port":"out"},"tgt":{"process":"SetStart_ql51c","port":"in"},"metadata":{"route":5}},{"src":{"process":"GestureMove_hy46s","port":"out"},"tgt":{"process":"groups/SendByGroup_8yaj","port":"in"},"metadata":{"route":3}},{"data":"target","tgt":{"process":"GetMoveElement_iaexm","port":"key"}},{"data":"target","tgt":{"process":"GetStartElement_w7m64","port":"key"}},{"data":"now","tgt":{"process":"SetStart_ql51c","port":"string"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_iu7k2","port":"method"}},{"data":"getTime","tgt":{"process":"objects/CallMethod_rtfd2","port":"method"}},{"data":"target","tgt":{"process":"GetEndElement_slbp9","port":"key"}},{"data":"now","tgt":{"process":"strings/SendString_t6gby","port":"string"}}]}');
});
require.register("noflo-noflo-gestures/graphs/ListenPointer.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"name":"ListenPointer"},"exports":[{"private":"Listen_1025g.element","public":"element"},{"private":"Listen_1025g.capture","public":"capture"},{"private":"StartEvent_x8itv.out","public":"start"},{"private":"MoveEvent_qa3pp.out","public":"move"},{"private":"EndEvent_hmwp9.out","public":"end"}],"processes":{"Listen_1025g":{"component":"interaction/ListenPointer","metadata":{"x":500,"y":-65,"label":"Listen"}},"End_vom22":{"component":"core/Merge","metadata":{"x":843,"y":96,"label":"End"}},"Start_86u3g":{"component":"core/Split","metadata":{"x":848,"y":-157,"label":"Start"}},"MoveOnlyDuringGesture_986zt":{"component":"flow/Gate","metadata":{"x":1106,"y":-40,"label":"MoveOnlyDuringGesture"}},"EndOnlyOnce_vexfn":{"component":"flow/Gate","metadata":{"x":1107,"y":75,"label":"EndOnlyOnce"}},"SplitEnd_cnfy6":{"component":"core/Split","metadata":{"x":1407,"y":79,"label":"SplitEnd"}},"Asynchronize_x0hqm":{"component":"core/RepeatAsync","metadata":{"x":1404,"y":171.33333333333331,"label":"Asynchronize"}},"StartEvent_x8itv":{"component":"core/Repeat","metadata":{"x":1662,"y":-162,"label":"StartEvent"}},"MoveEvent_qa3pp":{"component":"core/Repeat","metadata":{"x":1662,"y":-35,"label":"MoveEvent"}},"EndEvent_hmwp9":{"component":"core/Repeat","metadata":{"x":1659,"y":75,"label":"EndEvent"}}},"connections":[{"src":{"process":"Listen_1025g","port":"leave"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"cancel"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"up"},"tgt":{"process":"End_vom22","port":"in"},"metadata":{"route":1}},{"src":{"process":"Listen_1025g","port":"down"},"tgt":{"process":"Start_86u3g","port":"in"},"metadata":{"route":5}},{"src":{"process":"Listen_1025g","port":"move"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"in"},"metadata":{"route":3}},{"src":{"process":"End_vom22","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"in"},"metadata":{"route":1}},{"src":{"process":"EndOnlyOnce_vexfn","port":"out"},"tgt":{"process":"SplitEnd_cnfy6","port":"in"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"Asynchronize_x0hqm","port":"in"},"metadata":{"route":1}},{"src":{"process":"Asynchronize_x0hqm","port":"out"},"tgt":{"process":"EndOnlyOnce_vexfn","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"open"},"metadata":{"route":5}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"MoveOnlyDuringGesture_986zt","port":"close"},"metadata":{"route":1}},{"src":{"process":"Start_86u3g","port":"out"},"tgt":{"process":"StartEvent_x8itv","port":"in"},"metadata":{"route":5}},{"src":{"process":"MoveOnlyDuringGesture_986zt","port":"out"},"tgt":{"process":"MoveEvent_qa3pp","port":"in"},"metadata":{"route":3}},{"src":{"process":"SplitEnd_cnfy6","port":"out"},"tgt":{"process":"EndEvent_hmwp9","port":"in"},"metadata":{"route":1}}]}');
});
require.register("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", function(exports, require, module){
module.exports = JSON.parse('{"properties":{"environment":{"runtime":"html","src":"./preview/iframe.html","width":"300","height":"300","content":""},"name":"DetectCardinalDirection"},"exports":[{"private":"receivegesture_thbmw.in","public":"in"},{"private":"sendeast_218qx.out","public":"east"},{"private":"sendsouth_wx2b5.out","public":"south"},{"private":"sendwest_rkdz9.out","public":"west"},{"private":"sendnorth_c562k.out","public":"north"},{"private":"fail_5b0qo.out","public":"fail"},{"private":"checkmaxdistance_cebq5.comparison","public":"maxdistance"}],"processes":{"ReceiveGesture_thbmw":{"component":"core/Repeat","metadata":{"x":-294,"y":134,"label":"ReceiveGesture"}},"SplitGesture_dkk87":{"component":"core/Split","metadata":{"x":-296,"y":214,"label":"SplitGesture"}},"SendNorth_c562k":{"component":"strings/SendString","metadata":{"x":1733,"y":447,"label":"SendNorth"}},"SendEast_218qx":{"component":"strings/SendString","metadata":{"x":1721,"y":-5,"label":"SendEast"}},"RouteDirection_apgsp":{"component":"gestures/CardinalRouter","metadata":{"x":1469,"y":195,"label":"RouteDirection"}},"GetIndividualPointer_ozjfa":{"component":"objects/SplitObject","metadata":{"x":-86,"y":214,"label":"GetIndividualPointer"}},"GetStartPoint_bhrl2":{"component":"objects/GetObjectKey","metadata":{"x":879,"y":157,"label":"GetStartPoint"}},"GetCurrentPoint_rwwt0":{"component":"objects/GetObjectKey","metadata":{"x":877,"y":259,"label":"GetCurrentPoint"}},"GetGestureAngle_djpr6":{"component":"math/CalculateAngle","metadata":{"x":1083,"y":193,"label":"GetGestureAngle"}},"SendWest_rkdz9":{"component":"strings/SendString","metadata":{"x":1730.8333333333333,"y":348.33333333333337,"label":"SendWest"}},"SendSouth_wx2b5":{"component":"strings/SendString","metadata":{"x":1721.8333333333333,"y":107.33333333333337,"label":"SendSouth"}},"Fail_5b0qo":{"component":"core/Merge","metadata":{"x":1738.1666666666665,"y":564,"label":"Fail"}},"core/Split_n3qif":{"component":"core/Split","metadata":{"x":1276.999999999999,"y":193.66666666666669,"label":"core/Split"}},"GetDistance_owyyb":{"component":"objects/GetObjectKey","metadata":{"x":304,"y":216,"label":"GetDistance"}},"CheckMaxDistance_cebq5":{"component":"math/Compare","metadata":{"x":499,"y":214,"label":"CheckMaxDistance"}},"SendPointer_v0eqv":{"component":"strings/SendString","metadata":{"x":688,"y":214,"label":"SendPointer"}},"SplitPointer_v0u8k":{"component":"core/Split","metadata":{"x":109.00000000000006,"y":215.33333333333331,"label":"SplitPointer"}}},"connections":[{"src":{"process":"GetStartPoint_bhrl2","port":"object"},"tgt":{"process":"GetCurrentPoint_rwwt0","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetStartPoint_bhrl2","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"origin"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"destination"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendEast_218qx","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendWest_rkdz9","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendNorth_c562k","port":"string"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"SendSouth_wx2b5","port":"string"},"metadata":{"route":9}},{"src":{"process":"RouteDirection_apgsp","port":"n"},"tgt":{"process":"SendNorth_c562k","port":"in"},"metadata":{"route":4}},{"src":{"process":"RouteDirection_apgsp","port":"w"},"tgt":{"process":"SendWest_rkdz9","port":"in"},"metadata":{"route":5}},{"src":{"process":"RouteDirection_apgsp","port":"s"},"tgt":{"process":"SendSouth_wx2b5","port":"in"},"metadata":{"route":6}},{"src":{"process":"RouteDirection_apgsp","port":"e"},"tgt":{"process":"SendEast_218qx","port":"in"},"metadata":{"route":7}},{"src":{"process":"ReceiveGesture_thbmw","port":"out"},"tgt":{"process":"SplitGesture_dkk87","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitGesture_dkk87","port":"out"},"tgt":{"process":"GetIndividualPointer_ozjfa","port":"in"},"metadata":{"route":9}},{"src":{"process":"GetCurrentPoint_rwwt0","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetStartPoint_bhrl2","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetGestureAngle_djpr6","port":"angle"},"tgt":{"process":"core/Split_n3qif","port":"in"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"RouteDirection_apgsp","port":"degrees"},"metadata":{"route":9}},{"src":{"process":"core/Split_n3qif","port":"out"},"tgt":{"process":"GetGestureAngle_djpr6","port":"clear"},"metadata":{"route":0}},{"src":{"process":"GetIndividualPointer_ozjfa","port":"out"},"tgt":{"process":"SplitPointer_v0u8k","port":"in"},"metadata":{"route":9}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"SendPointer_v0eqv","port":"string"},"metadata":{"route":9}},{"src":{"process":"SendPointer_v0eqv","port":"out"},"tgt":{"process":"GetStartPoint_bhrl2","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"pass"},"tgt":{"process":"SendPointer_v0eqv","port":"in"},"metadata":{"route":9}},{"src":{"process":"CheckMaxDistance_cebq5","port":"fail"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"GetDistance_owyyb","port":"missed"},"tgt":{"process":"Fail_5b0qo","port":"in"},"metadata":{"route":1}},{"src":{"process":"SplitPointer_v0u8k","port":"out"},"tgt":{"process":"GetDistance_owyyb","port":"in"},"metadata":{"route":0}},{"src":{"process":"GetDistance_owyyb","port":"out"},"tgt":{"process":"CheckMaxDistance_cebq5","port":"value"},"metadata":{"route":9}},{"data":"startpoint","tgt":{"process":"GetStartPoint_bhrl2","port":"key"}},{"data":"movepoint","tgt":{"process":"GetCurrentPoint_rwwt0","port":"key"}},{"data":"distance","tgt":{"process":"GetDistance_owyyb","port":"key"}},{"data":"<=","tgt":{"process":"CheckMaxDistance_cebq5","port":"operator"}}]}');
});
require.register("noflo-noflo-gestures/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-gestures","description":"Gesture recognition components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-gestures","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*","noflo/noflo-interaction":"*","noflo/noflo-math":"*","noflo/noflo-flow":"*","noflo/noflo-groups":"*","noflo/noflo-packets":"*","noflo/noflo-objects":"*","noflo/noflo-dom":"*","noflo/noflo-strings":"*","noflo/noflo-core":"*"},"scripts":["components/CalculateCenter.coffee","components/CalculateScale.coffee","components/CardinalRouter.coffee","components/DegreesToCardinal.coffee","components/DegreesToCompass.coffee","components/DetectScratch.coffee","components/DetectTarget.coffee","graphs/DetectDrag.json","graphs/DetectSwipe.json","graphs/DetectPinch.json","graphs/FilterByTarget.json","graphs/GestureToObject.json","graphs/ListenGestures.json","graphs/ListenPointer.json","graphs/DetectCardinalDirection.json","index.js"],"json":["graphs/DetectDrag.json","graphs/DetectSwipe.json","graphs/DetectPinch.json","graphs/FilterByTarget.json","graphs/GestureToObject.json","graphs/ListenGestures.json","graphs/ListenPointer.json","graphs/DetectCardinalDirection.json","component.json"],"noflo":{"icon":"hand-o-right","components":{"CalculateCenter":"components/CalculateCenter.coffee","CalculateScale":"components/CalculateScale.coffee","CardinalRouter":"components/CardinalRouter.coffee","DegreesToCardinal":"components/DegreesToCardinal.coffee","DegreesToCompass":"components/DegreesToCompass.coffee","DetectScratch":"components/DetectScratch.coffee","DetectTarget":"components/DetectTarget.coffee"},"graphs":{"DetectDrag":"graphs/DetectDrag.json","DetectSwipe":"graphs/DetectSwipe.json","DetectPinch":"graphs/DetectPinch.json","FilterByTarget":"graphs/FilterByTarget.json","GestureToObject":"graphs/GestureToObject.json","ListenGestures":"graphs/ListenGestures.json","ListenPointer":"graphs/ListenPointer.json","DetectCardinalDirection":"graphs/DetectCardinalDirection.json"}}}');
});
require.register("noflo-noflo-gestures/components/CalculateCenter.js", function(exports, require, module){
var CalculateCenter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CalculateCenter = (function(_super) {
  __extends(CalculateCenter, _super);

  CalculateCenter.prototype.description = 'Calculate the center point for a gesture';

  function CalculateCenter() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      center: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(gesture) {
        return _this.outPorts.center.send(_this.calculateCenter(gesture));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.center.disconnect();
      };
    })(this));
  }

  CalculateCenter.prototype.calculateCenter = function(gesture) {
    var center, id, startX, startY, touch;
    if (Object.keys(gesture).length === 1) {
      return gesture.startpoint;
    }
    startX = [];
    startY = [];
    for (id in gesture) {
      touch = gesture[id];
      if (!touch) {
        continue;
      }
      if (!touch.startpoint) {
        continue;
      }
      startX.push(touch.startpoint.x);
      startY.push(touch.startpoint.y);
    }
    return center = {
      x: Math.min.apply(Math, startX) + Math.max.apply(Math, startX) / 2,
      y: Math.min.apply(Math, startY) + Math.max.apply(Math, startY) / 2
    };
  };

  return CalculateCenter;

})(noflo.Component);

exports.getComponent = function() {
  return new CalculateCenter;
};

});
require.register("noflo-noflo-gestures/components/CalculateScale.js", function(exports, require, module){
var CalculateScale, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CalculateScale = (function(_super) {
  __extends(CalculateScale, _super);

  CalculateScale.prototype.description = 'Calculate the scale based on gestural movement';

  function CalculateScale() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      scale: new noflo.Port('number')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(gesture) {
        return _this.outPorts.scale.send(_this.calculateScale(gesture));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.scale.disconnect();
      };
    })(this));
  }

  CalculateScale.prototype.calculateScale = function(gesture) {
    var id, movePoints, scale, startPoints, touch;
    if (Object.keys(gesture).length === 1) {
      return 1;
    }
    startPoints = [];
    movePoints = [];
    for (id in gesture) {
      touch = gesture[id];
      if (touch.startpoint) {
        startPoints.push(touch.startpoint);
      }
      if (touch.movepoint) {
        movePoints.push(touch.movepoint);
      }
    }
    if (startPoints.length < 2 || movePoints.length < 2) {
      return 1;
    }
    scale = this.calculateDistance(movePoints[0], movePoints[1]) / this.calculateDistance(startPoints[0], startPoints[1]);
    return scale;
  };

  CalculateScale.prototype.calculateDistance = function(origin, destination) {
    var deltaX, deltaY, distance;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    origin = null;
    destination = null;
    distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    return distance;
  };

  return CalculateScale;

})(noflo.Component);

exports.getComponent = function() {
  return new CalculateScale;
};

});
require.register("noflo-noflo-gestures/components/CardinalRouter.js", function(exports, require, module){
var CardinalRouter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CardinalRouter = (function(_super) {
  __extends(CardinalRouter, _super);

  CardinalRouter.prototype.description = 'Route values based on their cardinal directions';

  CardinalRouter.prototype.icon = 'compass';

  function CardinalRouter() {
    var headings;
    this.inPorts = {
      degrees: new noflo.Port('number')
    };
    this.outPorts = {
      e: new noflo.Port('number'),
      s: new noflo.Port('number'),
      w: new noflo.Port('number'),
      n: new noflo.Port('number')
    };
    headings = ['e', 's', 'w', 'n'];
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        var heading, index;
        index = degrees - 45;
        if (index < 0) {
          index = index + 360;
        }
        index = parseInt(index / 90);
        heading = headings[index];
        if (!_this.outPorts[heading].isAttached()) {
          return;
        }
        _this.outPorts[heading].send(degrees);
        return _this.outPorts[heading].disconnect();
      };
    })(this));
  }

  return CardinalRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new CardinalRouter;
};

});
require.register("noflo-noflo-gestures/components/DegreesToCardinal.js", function(exports, require, module){
var DegreesToCardinal, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DegreesToCardinal = (function(_super) {
  __extends(DegreesToCardinal, _super);

  DegreesToCardinal.prototype.description = 'Convert a heading in degrees to a cardinal direction, e.g. N, S';

  DegreesToCardinal.prototype.icon = 'compass';

  function DegreesToCardinal() {
    var headings;
    this.inPorts = {
      degrees: new noflo.Port('number')
    };
    this.outPorts = {
      heading: new noflo.Port('string')
    };
    headings = ['E', 'S', 'W', 'N'];
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        var index;
        index = degrees - 45;
        if (index < 0) {
          index = index + 360;
        }
        index = parseInt(index / 90);
        return _this.outPorts.heading.send(headings[index]);
      };
    })(this));
    this.inPorts.degrees.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.heading.disconnect();
      };
    })(this));
  }

  return DegreesToCardinal;

})(noflo.Component);

exports.getComponent = function() {
  return new DegreesToCardinal;
};

});
require.register("noflo-noflo-gestures/components/DegreesToCompass.js", function(exports, require, module){
var DegreesToCompass, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DegreesToCompass = (function(_super) {
  __extends(DegreesToCompass, _super);

  DegreesToCompass.prototype.description = 'Convert a heading in degrees to a compass direction, e.g. N, SW';

  DegreesToCompass.prototype.icon = 'compass';

  function DegreesToCompass() {
    var headings;
    this.inPorts = {
      degrees: new noflo.Port('number')
    };
    this.outPorts = {
      heading: new noflo.Port('string')
    };
    headings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
    this.inPorts.degrees.on('data', (function(_this) {
      return function(degrees) {
        var index;
        index = degrees - 22.5;
        if (index < 0) {
          index = index + 360;
        }
        index = parseInt(index / 45);
        return _this.outPorts.heading.send(headings[index]);
      };
    })(this));
    this.inPorts.degrees.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.heading.disconnect();
      };
    })(this));
  }

  return DegreesToCompass;

})(noflo.Component);

exports.getComponent = function() {
  return new DegreesToCompass;
};

});
require.register("noflo-noflo-gestures/components/DetectScratch.js", function(exports, require, module){
var DetectScratch, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DetectScratch = (function(_super) {
  __extends(DetectScratch, _super);

  function DetectScratch() {
    this.minturns = 3;
    this.distance = 20;
    this.minSpeed = 0;
    this.prevPoint = null;
    this.prevAngle = null;
    this.prevTime = null;
    this.speedChecked = false;
    this.turns = 0;
    this.inPorts = {
      "in": new noflo.Port('object'),
      distance: new noflo.Port('number'),
      speed: new noflo.Port('number')
    };
    this.outPorts = {
      pass: new noflo.Port('object'),
      fail: new noflo.Port('object')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (Object.keys(data).length > 1) {
          _this.outPorts.fail.send(data);
          return;
        }
        return _this.detect(data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(data) {
        _this.outPorts.pass.disconnect();
        return _this.outPorts.fail.disconnect();
      };
    })(this));
    this.inPorts.distance.on('data', (function(_this) {
      return function(distance) {
        _this.distance = distance;
      };
    })(this));
    this.inPorts.speed.on('data', (function(_this) {
      return function(minSpeed) {
        _this.minSpeed = minSpeed;
      };
    })(this));
  }

  DetectScratch.prototype.detect = function(gesture) {
    var angle, distance, elapsed, speed, time, touch, turn;
    touch = gesture[Object.keys(gesture)[0]];
    if (touch.endpoint) {
      this.reset();
      this.outPorts.fail.send(gesture);
      return;
    }
    if (!this.prevPoint) {
      this.prevPoint = touch.startpoint;
      this.prevTime = new Date;
      return;
    }
    distance = this.calculateDistance(this.prevPoint, touch.movepoint);
    if (distance < this.distance) {
      return;
    }
    time = new Date;
    if (!this.speedChecked) {
      elapsed = time.getTime() - this.prevTime.getTime();
      speed = distance / elapsed;
      if (speed < this.minSpeed) {
        this.reset();
        this.outPorts.fail.send(gesture);
        return;
      }
      this.speedChecked = true;
    }
    angle = this.calculateAngle(this.prevPoint, touch.movepoint);
    if (!this.prevAngle) {
      this.prevAngle = angle;
      return;
    }
    turn = Math.abs(this.angleChange(this.prevAngle, angle));
    this.prevPoint = touch.movepoint;
    this.prevAngle = angle;
    if (!(turn > 130)) {
      return;
    }
    this.prevTime = time;
    this.turns++;
    if (this.turns >= this.minturns) {
      this.reset();
      return this.outPorts.pass.send(gesture);
    }
  };

  DetectScratch.prototype.calculateDistance = function(origin, destination) {
    var deltaX, deltaY, distance;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    return distance;
  };

  DetectScratch.prototype.calculateAngle = function(origin, destination) {
    var angle, deltaX, deltaY;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    angle = (Math.atan2(deltaY, deltaX) * 180 / Math.PI) + 90;
    if (angle < 0) {
      angle = angle + 360;
    }
    return angle;
  };

  DetectScratch.prototype.angleChange = function(previous, current) {
    var difference;
    difference = current - previous;
    while (difference < -180) {
      difference += 360;
    }
    while (difference > 180) {
      difference -= 360;
    }
    return difference;
  };

  DetectScratch.prototype.reset = function() {
    this.turns = 0;
    this.prevPoint = null;
    this.prevAngle = null;
    this.prevTime = null;
    return this.speedChecked = false;
  };

  return DetectScratch;

})(noflo.Component);

exports.getComponent = function() {
  return new DetectScratch;
};

});
require.register("noflo-noflo-gestures/components/DetectTarget.js", function(exports, require, module){
var DetectTarget, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DetectTarget = (function(_super) {
  __extends(DetectTarget, _super);

  DetectTarget.prototype.describe = 'Verify that the gesture target has the right properties';

  function DetectTarget() {
    this.target = null;
    this.key = 'current';
    this.inPorts = {
      "in": new noflo.Port('object'),
      key: new noflo.Port('string'),
      target: new noflo.Port('string'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      pass: new noflo.Port('object'),
      fail: new noflo.Port('object'),
      target: new noflo.Port('object')
    };
    this.inPorts.target.on('data', (function(_this) {
      return function(data) {
        var parts;
        parts = data.split('=');
        if (!_this.target) {
          _this.target = {};
        }
        return _this.target[parts[0]] = parts[1];
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        return _this.target = null;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var element, passed, touch;
        if (Object.keys(data).length > 1) {
          passed = true;
          for (touch in data) {
            element = data[touch];
            if (!_this.detectTarget(element)) {
              passed = false;
            }
          }
          if (passed) {
            if (_this.outPorts.target.isAttached()) {
              _this.outPorts.target.send(data[Object.keys(data)[0]][_this.key]);
            }
            _this.outPorts.pass.send(data);
          } else {
            _this.outPorts.fail.send(data);
          }
          return;
        }
        if (_this.detectTarget(data[Object.keys(data)[0]])) {
          if (_this.outPorts.target.isAttached()) {
            _this.outPorts.target.send(data[Object.keys(data)[0]][_this.key]);
          }
          return _this.outPorts.pass.send(data);
        } else {
          return _this.outPorts.fail.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.pass.disconnect();
        _this.outPorts.fail.disconnect();
        if (_this.outPorts.target.isAttached()) {
          return _this.outPorts.target.disconnect();
        }
      };
    })(this));
  }

  DetectTarget.prototype.detectTarget = function(element) {
    var key, value, _ref;
    if (!element[this.key]) {
      return false;
    }
    _ref = this.target;
    for (key in _ref) {
      value = _ref[key];
      if (element[this.key][key] !== value) {
        return false;
      }
    }
    return true;
  };

  return DetectTarget;

})(noflo.Component);

exports.getComponent = function() {
  return new DetectTarget;
};

});
require.register("noflo-noflo-groups/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of groups.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-groups/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-groups","description":"Group Utilities for NoFlo","keywords":["noflo","groups","utilities"],"author":"Kenneth Kan <kenhkan@gmail.com>","version":"0.1.0","repo":"kenhkan/groups","dependencies":{"component/underscore":"*","noflo/noflo":"*"},"scripts":["components/ReadGroups.coffee","components/RemoveGroups.coffee","components/Regroup.coffee","components/Group.coffee","components/GroupZip.coffee","components/FilterByGroup.coffee","components/Objectify.coffee","components/ReadGroup.coffee","components/SendByGroup.coffee","components/CollectGroups.coffee","components/CollectObject.coffee","components/FirstGroup.coffee","components/MapGroup.coffee","components/MergeGroups.coffee","components/GroupByObjectKey.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"tags","components":{"ReadGroups":"components/ReadGroups.coffee","RemoveGroups":"components/RemoveGroups.coffee","Regroup":"components/Regroup.coffee","Group":"components/Group.coffee","GroupZip":"components/GroupZip.coffee","FilterByGroup":"components/FilterByGroup.coffee","Objectify":"components/Objectify.coffee","ReadGroup":"components/ReadGroup.coffee","SendByGroup":"components/SendByGroup.coffee","CollectGroups":"components/CollectGroups.coffee","CollectObject":"components/CollectObject.coffee","FirstGroup":"components/FirstGroup.coffee","MapGroup":"components/MapGroup.coffee","MergeGroups":"components/MergeGroups.coffee","GroupByObjectKey":"components/GroupByObjectKey.coffee"}}}');
});
require.register("noflo-noflo-groups/components/ReadGroups.js", function(exports, require, module){
var ReadGroups, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

ReadGroups = (function(_super) {
  __extends(ReadGroups, _super);

  function ReadGroups() {
    this.strip = false;
    this.threshold = Infinity;
    this.inPorts = {
      "in": new noflo.ArrayPort,
      strip: new noflo.Port,
      threshold: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      group: new noflo.Port
    };
    this.inPorts.threshold.on('data', (function(_this) {
      return function(threshold) {
        return _this.threshold = parseInt(threshold);
      };
    })(this));
    this.inPorts.strip.on('data', (function(_this) {
      return function(strip) {
        return _this.strip = strip === 'true';
      };
    })(this));
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        _this.count = 0;
        return _this.groups = [];
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        var beginGroup;
        beginGroup = function() {
          _this.groups.push(group);
          if (_this.outPorts.out.isAttached()) {
            return _this.outPorts.out.beginGroup(group);
          }
        };
        if (_this.count >= _this.threshold) {
          return beginGroup(group);
        } else {
          _this.outPorts.group.send(group);
          if (!_this.strip) {
            beginGroup(group);
          }
          return _this.count++;
        }
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        if (group === _.last(_this.groups)) {
          _this.groups.pop();
          if (_this.outPorts.out.isAttached()) {
            return _this.outPorts.out.endGroup();
          }
        }
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.out.isAttached()) {
          _this.outPorts.out.disconnect();
        }
        return _this.outPorts.group.disconnect();
      };
    })(this));
  }

  return ReadGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadGroups;
};

});
require.register("noflo-noflo-groups/components/RemoveGroups.js", function(exports, require, module){
var RemoveGroups, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

RemoveGroups = (function(_super) {
  __extends(RemoveGroups, _super);

  RemoveGroups.prototype.description = "Remove a group given a string or a regex string";

  function RemoveGroups() {
    this.regexp = null;
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexp = new RegExp(regexp);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        if ((_this.regexp != null) && (group.match(_this.regexp) == null)) {
          return _this.outPorts.out.beginGroup(group);
        }
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        if ((_this.regexp != null) && (group.match(_this.regexp) == null)) {
          return _this.outPorts.out.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return RemoveGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveGroups;
};

});
require.register("noflo-noflo-groups/components/Regroup.js", function(exports, require, module){
var Regroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

Regroup = (function(_super) {
  __extends(Regroup, _super);

  Regroup.prototype.description = "Forward all the data IPs, strip all groups, and replace them with groups from another connection";

  function Regroup() {
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port,
      group: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.group.on("connect", (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
    this.inPorts.group.on("data", (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        var group, _i, _len, _ref, _results;
        _ref = _this.groups;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _results.push(_this.outPorts.out.beginGroup(group));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var group, _i, _len, _ref;
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.endGroup();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Regroup;

})(noflo.Component);

exports.getComponent = function() {
  return new Regroup;
};

});
require.register("noflo-noflo-groups/components/Group.js", function(exports, require, module){
var Group, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

Group = (function(_super) {
  __extends(Group, _super);

  function Group() {
    this.newGroups = [];
    this.inPorts = {
      "in": new noflo.Port,
      group: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        var group, _i, _len, _ref, _results;
        _ref = _this.newGroups;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _results.push(_this.outPorts.out.beginGroup(group));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var group, _i, _len, _ref;
        _ref = _this.newGroups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.endGroup();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.group.on("connect", (function(_this) {
      return function() {
        return _this.newGroups = [];
      };
    })(this));
    this.inPorts.group.on("data", (function(_this) {
      return function(group) {
        return _this.newGroups.push(group);
      };
    })(this));
  }

  return Group;

})(noflo.Component);

exports.getComponent = function() {
  return new Group;
};

});
require.register("noflo-noflo-groups/components/GroupZip.js", function(exports, require, module){
var GroupZip, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

GroupZip = (function(_super) {
  __extends(GroupZip, _super);

  function GroupZip() {
    this.newGroups = [];
    this.inPorts = {
      "in": new noflo.Port,
      group: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.count = 0;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        _this.outPorts.out.beginGroup(_this.newGroups[_this.count++]);
        _this.outPorts.out.send(data);
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.group.on("connect", (function(_this) {
      return function() {
        return _this.newGroups = [];
      };
    })(this));
    this.inPorts.group.on("data", (function(_this) {
      return function(group) {
        return _this.newGroups.push(group);
      };
    })(this));
  }

  return GroupZip;

})(noflo.Component);

exports.getComponent = function() {
  return new GroupZip;
};

});
require.register("noflo-noflo-groups/components/FilterByGroup.js", function(exports, require, module){
var FilterByGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

FilterByGroup = (function(_super) {
  __extends(FilterByGroup, _super);

  FilterByGroup.prototype.description = "Given a RegExp string, filter out groups that do not match and their children data packets/groups. Forward only the content of the matching group.";

  function FilterByGroup() {
    this.regexp = null;
    this.matchedLevel = null;
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      group: new noflo.Port,
      empty: new noflo.Port
    };
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexp = new RegExp(regexp);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.level = 0;
        return _this.hasContent = false;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        if (_this.matchedLevel != null) {
          _this.outPorts.out.beginGroup(group);
        }
        _this.level++;
        if ((_this.matchedLevel == null) && (_this.regexp != null) && (group.match(_this.regexp) != null)) {
          _this.matchedLevel = _this.level;
          if (_this.outPorts.group.isAttached()) {
            return _this.outPorts.group.send(group);
          }
        }
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_this.matchedLevel != null) {
          _this.hasContent = true;
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        if (_this.matchedLevel === _this.level) {
          _this.matchedLevel = null;
        }
        if (_this.matchedLevel != null) {
          _this.outPorts.out.endGroup();
        }
        return _this.level--;
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        if (!_this.hasContent && _this.outPorts.empty.isAttached()) {
          _this.outPorts.empty.send(null);
          _this.outPorts.empty.disconnect();
        }
        if (_this.outPorts.group.isAttached()) {
          _this.outPorts.group.disconnect();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return FilterByGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterByGroup;
};

});
require.register("noflo-noflo-groups/components/Objectify.js", function(exports, require, module){
var Objectify, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Objectify = (function(_super) {
  __extends(Objectify, _super);

  Objectify.prototype.description = "specify a regexp string, use the first match as the key of an object containing the data";

  function Objectify() {
    this.regexp = null;
    this.match = null;
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexp = new RegExp(regexp);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        if ((_this.regexp != null) && (group.match(_this.regexp) != null)) {
          _this.match = _.first(group.match(_this.regexp));
        }
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var d;
        if (_this.match != null) {
          d = data;
          data = {};
          data[_this.match] = d;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Objectify;

})(noflo.Component);

exports.getComponent = function() {
  return new Objectify;
};

});
require.register("noflo-noflo-groups/components/ReadGroup.js", function(exports, require, module){
var ReadGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ReadGroup = (function(_super) {
  __extends(ReadGroup, _super);

  function ReadGroup() {
    this.groups = [];
    this.inPorts = {
      "in": new noflo.ArrayPort
    };
    this.outPorts = {
      out: new noflo.Port,
      group: new noflo.Port
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        _this.groups.push(group);
        _this.outPorts.group.beginGroup(group);
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.beginGroup(group);
        }
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.outPorts.out.isAttached()) {
          _this.outPorts.out.send(data);
        }
        if (!_this.groups.length) {
          return;
        }
        return _this.outPorts.group.send(_this.groups.join(':'));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        _this.groups.pop();
        _this.outPorts.group.endGroup();
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        return _this.outPorts.group.disconnect();
      };
    })(this));
  }

  return ReadGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadGroup;
};

});
require.register("noflo-noflo-groups/components/SendByGroup.js", function(exports, require, module){
var SendByGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SendByGroup = (function(_super) {
  __extends(SendByGroup, _super);

  SendByGroup.prototype.description = 'Send packet held in "data" when receiving matching set of groups in "in"';

  SendByGroup.prototype.icon = 'share-square';

  function SendByGroup() {
    this.data = {};
    this.ungrouped = null;
    this.dataGroups = [];
    this.inGroups = [];
    this.inPorts = {
      "in": new noflo.Port('bang'),
      data: new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts.data.on('begingroup', (function(_this) {
      return function(group) {
        return _this.dataGroups.push(group);
      };
    })(this));
    this.inPorts.data.on('data', (function(_this) {
      return function(data) {
        if (!_this.dataGroups.length) {
          _this.ungrouped = data;
          return;
        }
        return _this.data[_this.groupId(_this.dataGroups)] = data;
      };
    })(this));
    this.inPorts.data.on('endgroup', (function(_this) {
      return function() {
        return _this.dataGroups.pop();
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.inGroups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var id;
        if (!_this.inGroups.length) {
          if (_this.ungrouped !== null) {
            _this.send(_this.ungrouped);
          }
          return;
        }
        id = _this.groupId(_this.inGroups);
        if (!_this.data[id]) {
          return;
        }
        return _this.send(_this.data[id]);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.inGroups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SendByGroup.prototype.groupId = function(groups) {
    return groups.join(':');
  };

  SendByGroup.prototype.send = function(data) {
    var group, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.inGroups;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(data);
    _ref1 = this.inGroups;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  return SendByGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new SendByGroup;
};

});
require.register("noflo-noflo-groups/components/CollectGroups.js", function(exports, require, module){
var CollectGroups, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CollectGroups = (function(_super) {
  __extends(CollectGroups, _super);

  CollectGroups.prototype.description = 'Collect packets into object keyed by its groups';

  function CollectGroups() {
    this.data = {};
    this.groups = [];
    this.parents = [];
    this.inPorts = {
      "in": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.data = {};
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        if (group === '$data') {
          _this.error('groups cannot be named \'$data\'');
          return;
        }
        _this.parents.push(_this.data);
        _this.groups.push(group);
        return _this.data = {};
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.setData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        var data;
        data = _this.data;
        _this.data = _this.parents.pop();
        return _this.addChild(_this.data, _this.groups.pop(), data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.send(_this.data);
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  CollectGroups.prototype.addChild = function(parent, child, data) {
    if (!(child in parent)) {
      return parent[child] = data;
    }
    if (Array.isArray(parent[child])) {
      return parent[child].push(data);
    }
    return parent[child] = [parent[child], data];
  };

  CollectGroups.prototype.setData = function(data) {
    var _base;
    if ((_base = this.data).$data == null) {
      _base.$data = [];
    }
    return this.data.$data.push(data);
  };

  CollectGroups.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  return CollectGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new CollectGroups;
};

});
require.register("noflo-noflo-groups/components/CollectObject.js", function(exports, require, module){
var CollectObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CollectObject = (function(_super) {
  __extends(CollectObject, _super);

  CollectObject.prototype.description = 'Collect packets to an object identified by keys organized by connection';

  function CollectObject() {
    this.keys = [];
    this.allpackets = [];
    this.data = {};
    this.groups = {};
    this.inPorts = {
      keys: new noflo.ArrayPort('string'),
      allpackets: new noflo.ArrayPort('string'),
      collect: new noflo.ArrayPort('all'),
      release: new noflo.Port('bang'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.keys.on('data', (function(_this) {
      return function(key) {
        var keys, _i, _len, _results;
        keys = key.split(',');
        if (keys.length > 1) {
          _this.keys = [];
        }
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          _results.push(_this.keys.push(key));
        }
        return _results;
      };
    })(this));
    this.inPorts.allpackets.on('data', (function(_this) {
      return function(key) {
        var allpackets, _i, _len, _results;
        allpackets = key.split(',');
        if (allpackets.length > 1) {
          _this.keys = [];
        }
        _results = [];
        for (_i = 0, _len = allpackets.length; _i < _len; _i++) {
          key = allpackets[_i];
          _results.push(_this.allpackets.push(key));
        }
        return _results;
      };
    })(this));
    this.inPorts.collect.once('connect', (function(_this) {
      return function() {
        return _this.subscribeSockets();
      };
    })(this));
    this.inPorts.release.on('data', (function(_this) {
      return function() {
        return _this.release();
      };
    })(this));
    this.inPorts.release.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        return _this.clear();
      };
    })(this));
  }

  CollectObject.prototype.release = function() {
    this.outPorts.out.send(this.data);
    return this.data = this.clone(this.data);
  };

  CollectObject.prototype.subscribeSockets = function() {
    return this.inPorts.collect.sockets.forEach((function(_this) {
      return function(socket, idx) {
        return _this.subscribeSocket(socket, idx);
      };
    })(this));
  };

  CollectObject.prototype.subscribeSocket = function(socket, id) {
    socket.on('begingroup', (function(_this) {
      return function(group) {
        if (!_this.groups[id]) {
          _this.groups[id] = [];
        }
        return _this.groups[id].push(group);
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        var groupId;
        if (!_this.keys[id]) {
          return;
        }
        groupId = _this.groupId(_this.groups[id]);
        if (!_this.data[groupId]) {
          _this.data[groupId] = {};
        }
        if (_this.allpackets.indexOf(_this.keys[id]) !== -1) {
          if (!_this.data[groupId][_this.keys[id]]) {
            _this.data[groupId][_this.keys[id]] = [];
          }
          _this.data[groupId][_this.keys[id]].push(data);
          return;
        }
        return _this.data[groupId][_this.keys[id]] = data;
      };
    })(this));
    return socket.on('endgroup', (function(_this) {
      return function() {
        if (!_this.groups[id]) {
          return;
        }
        return _this.groups[id].pop();
      };
    })(this));
  };

  CollectObject.prototype.groupId = function(groups) {
    if (!groups.length) {
      return 'ungrouped';
    }
    return groups[0];
  };

  CollectObject.prototype.clone = function(data) {
    var groupName, groupedData, name, newData, value;
    newData = {};
    for (groupName in data) {
      groupedData = data[groupName];
      newData[groupName] = {};
      for (name in groupedData) {
        value = groupedData[name];
        if (!groupedData.hasOwnProperty(name)) {
          continue;
        }
        newData[groupName][name] = value;
      }
    }
    return newData;
  };

  CollectObject.prototype.clear = function() {
    this.data = {};
    return this.groups = {};
  };

  return CollectObject;

})(noflo.Component);

exports.getComponent = function() {
  return new CollectObject;
};

});
require.register("noflo-noflo-groups/components/FirstGroup.js", function(exports, require, module){
var FirstGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FirstGroup = (function(_super) {
  __extends(FirstGroup, _super);

  function FirstGroup() {
    this.depth = 0;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        if (_this.depth === 0) {
          _this.outPorts.out.beginGroup(group);
        }
        return _this.depth++;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        _this.depth--;
        if (_this.depth === 0) {
          return _this.outPorts.out.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.depth = 0;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return FirstGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new FirstGroup;
};

});
require.register("noflo-noflo-groups/components/MapGroup.js", function(exports, require, module){
var MapGroup, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MapGroup = (function(_super) {
  __extends(MapGroup, _super);

  function MapGroup() {
    this.map = {};
    this.regexps = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.mapGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MapGroup.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.map = map;
      return;
    }
    mapParts = map.split('=');
    return this.map[mapParts[0]] = mapParts[1];
  };

  MapGroup.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    return this.regexps[mapParts[0]] = mapParts[1];
  };

  MapGroup.prototype.mapGroup = function(group) {
    var expression, matched, regexp, replacement, _ref;
    if (this.map[group]) {
      this.outPorts.out.beginGroup(this.map[group]);
      return;
    }
    _ref = this.regexps;
    for (expression in _ref) {
      replacement = _ref[expression];
      regexp = new RegExp(expression);
      matched = regexp.exec(group);
      if (!matched) {
        continue;
      }
      group = group.replace(regexp, replacement);
    }
    return this.outPorts.out.beginGroup(group);
  };

  return MapGroup;

})(noflo.Component);

exports.getComponent = function() {
  return new MapGroup;
};

});
require.register("noflo-noflo-groups/components/MergeGroups.js", function(exports, require, module){
var MergeGroups, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore')._;

MergeGroups = (function(_super) {
  __extends(MergeGroups, _super);

  function MergeGroups() {
    this.groups = {};
    this.data = {};
    this.inPorts = {
      "in": new noflo.ArrayPort
    };
    this.outPorts = {
      out: new noflo.ArrayPort
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group, socket) {
        return _this.addGroup(socket, group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data, socket) {
        _this.registerData(socket, data);
        return _this.checkBuffer(socket);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group, socket) {
        _this.checkBuffer(socket);
        return _this.removeGroup(socket);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(socket, socketId) {
        return _this.checkBuffer(socketId);
      };
    })(this));
  }

  MergeGroups.prototype.addGroup = function(socket, group) {
    if (!this.groups[socket]) {
      this.groups[socket] = [];
    }
    return this.groups[socket].push(group);
  };

  MergeGroups.prototype.removeGroup = function(socket) {
    return this.groups[socket].pop();
  };

  MergeGroups.prototype.groupId = function(socket) {
    if (!this.groups[socket]) {
      return null;
    }
    return this.groups[socket].join(':');
  };

  MergeGroups.prototype.registerData = function(socket, data) {
    var id;
    id = this.groupId(socket);
    if (!id) {
      return;
    }
    if (!this.data[id]) {
      this.data[id] = {};
    }
    return this.data[id][socket] = data;
  };

  MergeGroups.prototype.checkBuffer = function(socket) {
    var id, socketId, _i, _len, _ref;
    id = this.groupId(socket);
    if (!id) {
      return;
    }
    if (!this.data[id]) {
      return;
    }
    _ref = this.inPorts["in"].sockets;
    for (socketId = _i = 0, _len = _ref.length; _i < _len; socketId = ++_i) {
      socket = _ref[socketId];
      if (!this.data[id][socketId]) {
        return;
      }
    }
    this.outPorts.out.beginGroup(id);
    this.outPorts.out.send(this.data[id]);
    this.outPorts.out.endGroup();
    this.outPorts.out.disconnect();
    return delete this.data[id];
  };

  return MergeGroups;

})(noflo.Component);

exports.getComponent = function() {
  return new MergeGroups;
};

});
require.register("noflo-noflo-groups/components/GroupByObjectKey.js", function(exports, require, module){
var GroupByObjectKey, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GroupByObjectKey = (function(_super) {
  __extends(GroupByObjectKey, _super);

  function GroupByObjectKey() {
    this.data = [];
    this.key = null;
    this.inPorts = {
      "in": new noflo.Port(),
      key: new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.data = [];
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.key) {
          return _this.getKey(data);
        }
        return _this.data.push(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          _this.outPorts.out.disconnect();
          return;
        }
        if (!_this.key) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        return _this.key = data;
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  GroupByObjectKey.prototype.getKey = function(data) {
    var group;
    if (!this.key) {
      throw new Error('Key not defined');
    }
    if (typeof data !== 'object') {
      throw new Error('Data is not an object');
    }
    group = data[this.key];
    if (typeof data[this.key] !== 'string') {
      group = 'undefined';
    }
    if (typeof data[this.key] === 'boolean') {
      if (data[this.key]) {
        group = this.key;
      }
    }
    this.outPorts.out.beginGroup(group);
    this.outPorts.out.send(data);
    return this.outPorts.out.endGroup();
  };

  return GroupByObjectKey;

})(noflo.Component);

exports.getComponent = function() {
  return new GroupByObjectKey;
};

});
require.register("noflo-noflo-interaction/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-interaction/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-interaction","description":"User interaction components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-interaction","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/ListenChange.coffee","components/ListenDrag.coffee","components/ListenHash.coffee","components/ListenKeyboard.coffee","components/ListenKeyboardShortcuts.coffee","components/ListenMouse.coffee","components/ListenPointer.coffee","components/ListenResize.coffee","components/ListenScroll.coffee","components/ListenSpeech.coffee","components/ListenTouch.coffee","components/SetHash.coffee","components/ReadCoordinates.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"user","components":{"ListenChange":"components/ListenChange.coffee","ListenDrag":"components/ListenDrag.coffee","ListenHash":"components/ListenHash.coffee","ListenKeyboard":"components/ListenKeyboard.coffee","ListenKeyboardShortcuts":"components/ListenKeyboardShortcuts.coffee","ListenMouse":"components/ListenMouse.coffee","ListenPointer":"components/ListenPointer.coffee","ListenResize":"components/ListenResize.coffee","ListenScroll":"components/ListenScroll.coffee","ListenSpeech":"components/ListenSpeech.coffee","ListenTouch":"components/ListenTouch.coffee","ReadCoordinates":"components/ReadCoordinates.coffee","SetHash":"components/SetHash.coffee"}}}');
});
require.register("noflo-noflo-interaction/components/ListenChange.js", function(exports, require, module){
var ListenChange, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenChange = (function(_super) {
  __extends(ListenChange, _super);

  ListenChange.prototype.description = 'Listen to mouse events on a DOM element';

  function ListenChange() {
    this.change = __bind(this.change, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      value: new noflo.ArrayPort('all')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenChange.prototype.subscribe = function(element) {
    return element.addEventListener('change', this.change, false);
  };

  ListenChange.prototype.change = function(event) {
    if (!this.outPorts.value.sockets.length) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.value.send(event.target.value);
    return this.outPorts.value.disconnect();
  };

  return ListenChange;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenChange;
};

});
require.register("noflo-noflo-interaction/components/ListenDrag.js", function(exports, require, module){
var ListenDrag, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenDrag = (function(_super) {
  __extends(ListenDrag, _super);

  ListenDrag.prototype.description = 'Listen to drag events on a DOM element';

  function ListenDrag() {
    this.dragend = __bind(this.dragend, this);
    this.dragmove = __bind(this.dragmove, this);
    this.dragstart = __bind(this.dragstart, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      start: new noflo.ArrayPort('object'),
      movex: new noflo.ArrayPort('number'),
      movey: new noflo.ArrayPort('number'),
      end: new noflo.ArrayPort('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenDrag.prototype.subscribe = function(element) {
    element.addEventListener('dragstart', this.dragstart, false);
    element.addEventListener('drag', this.dragmove, false);
    return element.addEventListener('dragend', this.dragend, false);
  };

  ListenDrag.prototype.dragstart = function(event) {
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.start.send(event);
    return this.outPorts.start.disconnect();
  };

  ListenDrag.prototype.dragmove = function(event) {
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.movex.send(event.clientX);
    return this.outPorts.movey.send(event.clientY);
  };

  ListenDrag.prototype.dragend = function(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.outPorts.movex.isConnected()) {
      this.outPorts.movex.disconnect();
    }
    if (this.outPorts.movey.isConnected()) {
      this.outPorts.movey.disconnect();
    }
    this.outPorts.end.send(event);
    return this.outPorts.end.disconnect();
  };

  return ListenDrag;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenDrag;
};

});
require.register("noflo-noflo-interaction/components/ListenHash.js", function(exports, require, module){
var ListenHash, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenHash = (function(_super) {
  __extends(ListenHash, _super);

  ListenHash.prototype.description = 'Listen for hash changes in browser\'s URL bar';

  function ListenHash() {
    this.hashChange = __bind(this.hashChange, this);
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      initial: new noflo.Port('string'),
      change: new noflo.Port('string')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.subscribe();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.unsubscribe();
      };
    })(this));
  }

  ListenHash.prototype.subscribe = function() {
    var initialHash;
    window.addEventListener('hashchange', this.hashChange, false);
    if (this.outPorts.initial.isAttached()) {
      initialHash = window.location.hash.substr(1);
      this.outPorts.initial.send(initialHash);
      return this.outPorts.initial.disconnect();
    }
  };

  ListenHash.prototype.unsubscribe = function() {
    window.removeEventListener('hashchange', this.hashChange, false);
    return this.outPorts.change.disconnect();
  };

  ListenHash.prototype.hashChange = function(event) {
    var newHash, oldHash;
    oldHash = event.oldURL.split('#')[1];
    newHash = event.newURL.split('#')[1];
    if (!newHash) {
      newHash = '';
    }
    if (oldHash) {
      this.outPorts.change.beginGroup(oldHash);
    }
    this.outPorts.change.send(newHash);
    if (oldHash) {
      return this.outPorts.change.endGroup(oldHash);
    }
  };

  ListenHash.prototype.shutdown = function() {
    return this.unsubscribe();
  };

  return ListenHash;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenHash;
};

});
require.register("noflo-noflo-interaction/components/ListenKeyboard.js", function(exports, require, module){
var ListenKeyboard, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenKeyboard = (function(_super) {
  __extends(ListenKeyboard, _super);

  ListenKeyboard.prototype.description = 'Listen for key presses on a given DOM element';

  ListenKeyboard.prototype.icon = 'keyboard-o';

  function ListenKeyboard() {
    this.keypress = __bind(this.keypress, this);
    this.elements = [];
    this.inPorts = {
      element: new noflo.Port('object'),
      stop: new noflo.Port('object')
    };
    this.outPorts = {
      keypress: new noflo.Port('integer')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function(element) {
        return _this.unsubscribe(element);
      };
    })(this));
  }

  ListenKeyboard.prototype.subscribe = function(element) {
    element.addEventListener('keypress', this.keypress, false);
    return this.elements.push(element);
  };

  ListenKeyboard.prototype.unsubscribe = function(element) {
    if (-1 === this.elements.indexOf(element)) {
      return;
    }
    element.removeEventListener('keypress', this.keypress, false);
    return this.elements.splice(this.elements.indexOf(element), 1);
  };

  ListenKeyboard.prototype.keypress = function(event) {
    if (!this.outPorts.keypress.isAttached()) {
      return;
    }
    this.outPorts.keypress.send(event.keyCode);
    return this.outPorts.keypress.disconnect();
  };

  ListenKeyboard.prototype.shutdown = function() {
    var element, _i, _len, _ref, _results;
    _ref = this.elements;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      _results.push(this.unsubscribe(element));
    }
    return _results;
  };

  return ListenKeyboard;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenKeyboard;
};

});
require.register("noflo-noflo-interaction/components/ListenKeyboardShortcuts.js", function(exports, require, module){
var ListenKeyboardShortcuts, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenKeyboardShortcuts = (function(_super) {
  __extends(ListenKeyboardShortcuts, _super);

  ListenKeyboardShortcuts.prototype.description = 'Listen for keyboard shortcuts and route them';

  ListenKeyboardShortcuts.prototype.icon = 'keyboard-o';

  function ListenKeyboardShortcuts() {
    this.keypress = __bind(this.keypress, this);
    this.keys = [];
    this.ignoreInput = true;
    this.inPorts = {
      keys: new noflo.Port('string'),
      ignoreinput: new noflo.Port('boolean'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      shortcut: new noflo.ArrayPort('bang'),
      missed: new noflo.Port('integer')
    };
    this.inPorts.keys.on('data', (function(_this) {
      return function(data) {
        _this.keys = _this.normalizeKeys(data);
        return _this.subscribe();
      };
    })(this));
    this.inPorts.ignoreinput.on('data', (function(_this) {
      return function(data) {
        return _this.ignoreInput = String(data) === 'true';
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.unsubscribe();
      };
    })(this));
  }

  ListenKeyboardShortcuts.prototype.subscribe = function() {
    return document.addEventListener('keydown', this.keypress, false);
  };

  ListenKeyboardShortcuts.prototype.unsubscribe = function() {
    return document.removeEventListener('keydown', this.keypress, false);
  };

  ListenKeyboardShortcuts.prototype.normalizeKeys = function(data) {
    var index, key, keys, _i, _len;
    keys = data.split(',');
    for (index = _i = 0, _len = keys.length; _i < _len; index = ++_i) {
      key = keys[index];
      switch (key) {
        case '-':
          keys[index] = 189;
          break;
        case '=':
          keys[index] = 187;
          break;
        case '0':
          keys[index] = 48;
          break;
        case 'a':
          keys[index] = 65;
          break;
        case 'x':
          keys[index] = 88;
          break;
        case 'c':
          keys[index] = 67;
          break;
        case 'v':
          keys[index] = 86;
          break;
        case 'z':
          keys[index] = 90;
          break;
        case 'r':
          keys[index] = 82;
          break;
        case 's':
          keys[index] = 83;
      }
    }
    return keys;
  };

  ListenKeyboardShortcuts.prototype.validateTarget = function(event) {
    if (!this.ignoreInput) {
      return true;
    }
    if (event.target.tagName === 'TEXTAREA') {
      return false;
    }
    if (event.target.tagName === 'INPUT') {
      return false;
    }
    if (String(event.target.contentEditable) === 'true') {
      return false;
    }
    return true;
  };

  ListenKeyboardShortcuts.prototype.keypress = function(event) {
    var route;
    if (!(event.ctrlKey || event.metaKey)) {
      return;
    }
    if (!this.validateTarget(event)) {
      return;
    }
    route = this.keys.indexOf(event.keyCode);
    if (route === -1) {
      if (this.outPorts.missed.isAttached()) {
        this.outPorts.missed.send(event.keyCode);
        this.outPorts.missed.disconnect();
      }
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.shortcut.send(event.keyCode, route);
    return this.outPorts.shortcut.disconnect();
  };

  ListenKeyboardShortcuts.prototype.shutdown = function() {
    return this.unsubscribe();
  };

  return ListenKeyboardShortcuts;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenKeyboardShortcuts;
};

});
require.register("noflo-noflo-interaction/components/ListenMouse.js", function(exports, require, module){
var ListenMouse, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenMouse = (function(_super) {
  __extends(ListenMouse, _super);

  ListenMouse.prototype.description = 'Listen to mouse events on a DOM element';

  function ListenMouse() {
    this.dblclick = __bind(this.dblclick, this);
    this.click = __bind(this.click, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      click: new noflo.ArrayPort('object'),
      dblclick: new noflo.ArrayPort('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenMouse.prototype.subscribe = function(element) {
    element.addEventListener('click', this.click, false);
    return element.addEventListener('dblclick', this.dblclick, false);
  };

  ListenMouse.prototype.click = function(event) {
    if (!this.outPorts.click.sockets.length) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.click.send(event);
    this.outPorts.click.disconnect();
    return this.updateIcon();
  };

  ListenMouse.prototype.dblclick = function(event) {
    if (!this.outPorts.dblclick.sockets.length) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    this.outPorts.dblclick.send(event);
    this.outPorts.dblclick.disconnect();
    return this.updateIcon();
  };

  ListenMouse.prototype.updateIcon = function() {
    if (!this.setIcon) {
      return;
    }
    if (this.timeout) {
      return;
    }
    this.originalIcon = this.getIcon();
    this.setIcon('exclamation-circle');
    return this.timeout = setTimeout((function(_this) {
      return function() {
        _this.setIcon(_this.originalIcon);
        return _this.timeout = null;
      };
    })(this), 200);
  };

  return ListenMouse;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenMouse;
};

});
require.register("noflo-noflo-interaction/components/ListenPointer.js", function(exports, require, module){
var ListenPointer, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenPointer = (function(_super) {
  __extends(ListenPointer, _super);

  ListenPointer.prototype.description = 'Listen to pointer events on a DOM element';

  function ListenPointer() {
    this.pointerLeave = __bind(this.pointerLeave, this);
    this.pointerEnter = __bind(this.pointerEnter, this);
    this.pointerOut = __bind(this.pointerOut, this);
    this.pointerOver = __bind(this.pointerOver, this);
    this.pointerMove = __bind(this.pointerMove, this);
    this.pointerCancel = __bind(this.pointerCancel, this);
    this.pointerUp = __bind(this.pointerUp, this);
    this.pointerDown = __bind(this.pointerDown, this);
    this.action = 'none';
    this.capture = false;
    this.propagate = false;
    this.elements = [];
    this.inPorts = {
      element: new noflo.Port('object'),
      action: new noflo.Port('string'),
      capture: new noflo.Port('boolean'),
      propagate: new noflo.Port('boolean')
    };
    this.outPorts = {
      down: new noflo.Port('object'),
      up: new noflo.Port('object'),
      cancel: new noflo.Port('object'),
      move: new noflo.Port('object'),
      over: new noflo.Port('object'),
      out: new noflo.Port('object'),
      enter: new noflo.Port('object'),
      leave: new noflo.Port('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
    this.inPorts.action.on('data', (function(_this) {
      return function(action) {
        _this.action = action;
      };
    })(this));
    this.inPorts.capture.on('data', (function(_this) {
      return function(capture) {
        _this.capture = capture;
      };
    })(this));
    this.inPorts.propagate.on('data', (function(_this) {
      return function(propagate) {
        _this.propagate = propagate;
      };
    })(this));
  }

  ListenPointer.prototype.subscribe = function(element) {
    if (element.setAttribute) {
      element.setAttribute('touch-action', this.action);
    }
    element.addEventListener('pointerdown', this.pointerDown, this.capture);
    element.addEventListener('pointerup', this.pointerUp, this.capture);
    element.addEventListener('pointercancel', this.pointerCancel, this.capture);
    element.addEventListener('pointermove', this.pointerMove, this.capture);
    element.addEventListener('pointerover', this.pointerOver, this.capture);
    element.addEventListener('pointerout', this.pointerOut, this.capture);
    element.addEventListener('pointerenter', this.pointerEnter, this.capture);
    element.addEventListener('pointerleave', this.pointerLeave, this.capture);
    return this.elements.push(element);
  };

  ListenPointer.prototype.unsubscribe = function(element) {
    var name, port, _ref, _results;
    if (element.removeAttribute) {
      element.removeAttribute('touch-action');
    }
    element.removeEventListener('pointerdown', this.pointerDown, this.capture);
    element.removeEventListener('pointerup', this.pointerUp, this.capture);
    element.removeEventListener('pointercancel', this.pointerCancel, this.capture);
    element.removeEventListener('pointermove', this.pointerMove, this.capture);
    element.removeEventListener('pointerover', this.pointerOver, this.capture);
    element.removeEventListener('pointerout', this.pointerOut, this.capture);
    element.removeEventListener('pointerenter', this.pointerEnter, this.capture);
    element.removeEventListener('pointerleave', this.pointerLeave, this.capture);
    _ref = this.outPorts;
    _results = [];
    for (name in _ref) {
      port = _ref[name];
      if (!port.isAttached()) {
        continue;
      }
      _results.push(port.disconnect());
    }
    return _results;
  };

  ListenPointer.prototype.shutdown = function() {
    var element, _i, _len, _ref;
    _ref = this.elements;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      this.unsubscribe(element);
    }
    return this.elements = [];
  };

  ListenPointer.prototype.pointerDown = function(event) {
    return this.handle(event, 'down');
  };

  ListenPointer.prototype.pointerUp = function(event) {
    return this.handle(event, 'up');
  };

  ListenPointer.prototype.pointerCancel = function(event) {
    return this.handle(event, 'cancel');
  };

  ListenPointer.prototype.pointerMove = function(event) {
    return this.handle(event, 'move');
  };

  ListenPointer.prototype.pointerOver = function(event) {
    return this.handle(event, 'over');
  };

  ListenPointer.prototype.pointerOut = function(event) {
    return this.handle(event, 'out');
  };

  ListenPointer.prototype.pointerEnter = function(event) {
    return this.handle(event, 'enter');
  };

  ListenPointer.prototype.pointerLeave = function(event) {
    return this.handle(event, 'leave');
  };

  ListenPointer.prototype.handle = function(event, type) {
    var name, port, _ref, _results;
    event.preventDefault();
    if (!this.propagate) {
      event.stopPropagation();
    }
    if (!this.outPorts[type].isAttached()) {
      return;
    }
    this.outPorts[type].beginGroup(event.pointerId);
    this.outPorts[type].send(event);
    this.outPorts[type].endGroup();
    if (type === 'up' || type === 'cancel' || type === 'leave') {
      _ref = this.outPorts;
      _results = [];
      for (name in _ref) {
        port = _ref[name];
        if (!port.isAttached()) {
          continue;
        }
        _results.push(port.disconnect());
      }
      return _results;
    }
  };

  return ListenPointer;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenPointer;
};

});
require.register("noflo-noflo-interaction/components/ListenResize.js", function(exports, require, module){
var ListenResize, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenResize = (function(_super) {
  __extends(ListenResize, _super);

  ListenResize.prototype.description = 'Listen to window resize events';

  ListenResize.prototype.icon = 'desktop';

  function ListenResize() {
    this.sendSize = __bind(this.sendSize, this);
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      width: new noflo.Port('number'),
      height: new noflo.Port('number')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        _this.sendSize();
        return _this.subscribe();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.unsubscribe();
      };
    })(this));
  }

  ListenResize.prototype.subscribe = function() {
    return window.addEventListener('resize', this.sendSize, false);
  };

  ListenResize.prototype.unsubscribe = function() {
    return window.removeEventListener('resize', this.sendSize, false);
  };

  ListenResize.prototype.sendSize = function() {
    if (this.outPorts.width.isAttached()) {
      this.outPorts.width.send(window.innerWidth);
      this.outPorts.width.disconnect();
    }
    if (this.outPorts.height.isAttached()) {
      this.outPorts.height.send(window.innerHeight);
      return this.outPorts.height.disconnect();
    }
  };

  ListenResize.prototype.shutdown = function() {
    return this.unsubscribe();
  };

  return ListenResize;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenResize;
};

});
require.register("noflo-noflo-interaction/components/ListenScroll.js", function(exports, require, module){
var ListenScroll, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenScroll = (function(_super) {
  __extends(ListenScroll, _super);

  ListenScroll.prototype.description = 'Listen to scroll events on the browser window';

  function ListenScroll() {
    this.scroll = __bind(this.scroll, this);
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      top: new noflo.Port('number'),
      bottom: new noflo.Port('number'),
      left: new noflo.Port('number'),
      right: new noflo.Port('number')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.subscribe();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.unsubscribe();
      };
    })(this));
  }

  ListenScroll.prototype.subscribe = function() {
    return window.addEventListener('scroll', this.scroll, false);
  };

  ListenScroll.prototype.unsubscribe = function() {
    return window.removeEventListenr('scroll', this.scroll, false);
  };

  ListenScroll.prototype.scroll = function(event) {
    var bottom, left, right, top;
    top = window.scrollY;
    left = window.scrollX;
    if (this.outPorts.top.isAttached()) {
      this.outPorts.top.send(top);
      this.outPorts.top.disconnect();
    }
    if (this.outPorts.bottom.isAttached()) {
      bottom = top + window.innerHeight;
      this.outPorts.bottom.send(bottom);
      this.outPorts.bottom.disconnect();
    }
    if (this.outPorts.left.isAttached()) {
      this.outPorts.left.send(left);
      this.outPorts.left.disconnect();
    }
    if (this.outPorts.right.isAttached()) {
      right = left + window.innerWidth;
      this.outPorts.right.send(right);
      return this.outPorts.right.disconnect();
    }
  };

  ListenScroll.prototype.shutdown = function() {
    return this.unsubscribe();
  };

  return ListenScroll;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenScroll;
};

});
require.register("noflo-noflo-interaction/components/ListenSpeech.js", function(exports, require, module){
var ListenSpeech, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenSpeech = (function(_super) {
  __extends(ListenSpeech, _super);

  ListenSpeech.prototype.description = 'Listen for user\'s microphone and recognize phrases';

  function ListenSpeech() {
    this.handleError = __bind(this.handleError, this);
    this.handleResult = __bind(this.handleResult, this);
    this.recognition = false;
    this.sent = [];
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      result: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.startListening();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.stopListening();
      };
    })(this));
  }

  ListenSpeech.prototype.startListening = function() {
    if (!window.webkitSpeechRecognition) {
      this.handleError(new Error('Speech recognition support not available'));
    }
    this.recognition = new window.webkitSpeechRecognition;
    this.recognition.continuous = true;
    this.recognition.start();
    this.outPorts.result.connect();
    this.recognition.onresult = this.handleResult;
    return this.recognition.onerror = this.handleError;
  };

  ListenSpeech.prototype.handleResult = function(event) {
    var idx, result, _i, _len, _ref, _results;
    _ref = event.results;
    _results = [];
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      result = _ref[idx];
      if (!result.isFinal) {
        continue;
      }
      if (this.sent.indexOf(idx) !== -1) {
        continue;
      }
      this.outPorts.result.send(result[0].transcript);
      _results.push(this.sent.push(idx));
    }
    return _results;
  };

  ListenSpeech.prototype.handleError = function(error) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(error);
      this.outPorts.error.disconnect();
      return;
    }
    throw error;
  };

  ListenSpeech.prototype.stopListening = function() {
    if (!this.recognition) {
      return;
    }
    this.outPorts.result.disconnect();
    this.recognition.stop();
    this.recognition = null;
    return this.sent = [];
  };

  ListenSpeech.prototype.shutdown = function() {
    return this.stopListening();
  };

  return ListenSpeech;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenSpeech;
};

});
require.register("noflo-noflo-interaction/components/ListenTouch.js", function(exports, require, module){
var ListenTouch, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenTouch = (function(_super) {
  __extends(ListenTouch, _super);

  ListenTouch.prototype.description = 'Listen to touch events on a DOM element';

  function ListenTouch() {
    this.touchend = __bind(this.touchend, this);
    this.touchmove = __bind(this.touchmove, this);
    this.touchstart = __bind(this.touchstart, this);
    this.inPorts = {
      element: new noflo.Port('object')
    };
    this.outPorts = {
      start: new noflo.ArrayPort('object'),
      movex: new noflo.ArrayPort('number'),
      movey: new noflo.ArrayPort('number'),
      end: new noflo.ArrayPort('object')
    };
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  ListenTouch.prototype.subscribe = function(element) {
    element.addEventListener('touchstart', this.touchstart, false);
    element.addEventListener('touchmove', this.touchmove, false);
    return element.addEventListener('touchend', this.touchend, false);
  };

  ListenTouch.prototype.touchstart = function(event) {
    var idx, touch, _i, _len, _ref;
    event.preventDefault();
    event.stopPropagation();
    if (!event.changedTouches) {
      return;
    }
    if (!event.changedTouches.length) {
      return;
    }
    _ref = event.changedTouches;
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      touch = _ref[idx];
      this.outPorts.start.beginGroup(idx);
      this.outPorts.start.send(event);
      this.outPorts.start.endGroup();
    }
    return this.outPorts.start.disconnect();
  };

  ListenTouch.prototype.touchmove = function(event) {
    var idx, touch, _i, _len, _ref, _results;
    event.preventDefault();
    event.stopPropagation();
    if (!event.changedTouches) {
      return;
    }
    if (!event.changedTouches.length) {
      return;
    }
    _ref = event.changedTouches;
    _results = [];
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      touch = _ref[idx];
      this.outPorts.movex.beginGroup(idx);
      this.outPorts.movex.send(touch.pageX);
      this.outPorts.movex.endGroup();
      this.outPorts.movey.beginGroup(idx);
      this.outPorts.movey.send(touch.pageY);
      _results.push(this.outPorts.movey.endGroup());
    }
    return _results;
  };

  ListenTouch.prototype.touchend = function(event) {
    var idx, touch, _i, _len, _ref;
    event.preventDefault();
    event.stopPropagation();
    if (!event.changedTouches) {
      return;
    }
    if (!event.changedTouches.length) {
      return;
    }
    if (this.outPorts.movex.isConnected()) {
      this.outPorts.movex.disconnect();
    }
    if (this.outPorts.movey.isConnected()) {
      this.outPorts.movey.disconnect();
    }
    _ref = event.changedTouches;
    for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
      touch = _ref[idx];
      this.outPorts.end.beginGroup(idx);
      this.outPorts.end.send(event);
      this.outPorts.end.endGroup();
    }
    return this.outPorts.end.disconnect();
  };

  return ListenTouch;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenTouch;
};

});
require.register("noflo-noflo-interaction/components/SetHash.js", function(exports, require, module){
var SetHash, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetHash = (function(_super) {
  __extends(SetHash, _super);

  function SetHash() {
    this.inPorts = {
      hash: new noflo.ArrayPort('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.hash.on('data', (function(_this) {
      return function(data) {
        window.location.hash = "#" + data;
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts.hash.on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.disconnect();
        }
      };
    })(this));
  }

  return SetHash;

})(noflo.Component);

exports.getComponent = function() {
  return new SetHash;
};

});
require.register("noflo-noflo-interaction/components/ReadCoordinates.js", function(exports, require, module){
var ReadCoordinates, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ReadCoordinates = (function(_super) {
  __extends(ReadCoordinates, _super);

  ReadCoordinates.prototype.description = 'Read the coordinates from a DOM event';

  function ReadCoordinates() {
    this.inPorts = {
      event: new noflo.Port('object')
    };
    this.outPorts = {
      screen: new noflo.Port('object'),
      client: new noflo.Port('object'),
      page: new noflo.Port('object')
    };
    this.inPorts.event.on('begingroup', (function(_this) {
      return function(group) {
        if (_this.outPorts.screen.isAttached()) {
          _this.outPorts.screen.beginGroup(group);
        }
        if (_this.outPorts.client.isAttached()) {
          _this.outPorts.client.beginGroup(group);
        }
        if (_this.outPorts.page.isAttached()) {
          return _this.outPorts.page.beginGroup(group);
        }
      };
    })(this));
    this.inPorts.event.on('data', (function(_this) {
      return function(data) {
        return _this.read(data);
      };
    })(this));
    this.inPorts.event.on('endgroup', (function(_this) {
      return function() {
        if (_this.outPorts.screen.isAttached()) {
          _this.outPorts.screen.endGroup();
        }
        if (_this.outPorts.client.isAttached()) {
          _this.outPorts.client.endGroup();
        }
        if (_this.outPorts.page.isAttached()) {
          return _this.outPorts.page.endGroup();
        }
      };
    })(this));
    this.inPorts.event.on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.screen.isAttached()) {
          _this.outPorts.screen.disconnect();
        }
        if (_this.outPorts.client.isAttached()) {
          _this.outPorts.client.disconnect();
        }
        if (_this.outPorts.page.isAttached()) {
          return _this.outPorts.page.disconnect();
        }
      };
    })(this));
  }

  ReadCoordinates.prototype.read = function(event) {
    if (!event) {
      return;
    }
    if (this.outPorts.screen.isAttached() && event.screenX !== void 0) {
      this.outPorts.screen.send({
        x: event.screenX,
        y: event.screenY
      });
    }
    if (this.outPorts.client.isAttached() && event.clientX !== void 0) {
      this.outPorts.client.send({
        x: event.clientX,
        y: event.clientY
      });
    }
    if (this.outPorts.page.isAttached() && event.pageX !== void 0) {
      return this.outPorts.page.send({
        x: event.pageX,
        y: event.pageY
      });
    }
  };

  return ReadCoordinates;

})(noflo.Component);

exports.getComponent = function() {
  return new ReadCoordinates;
};

});
require.register("noflo-noflo-localstorage/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-localstorage.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-localstorage/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-localstorage","description":"LocalStorage components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-localstorage","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/GetItem.coffee","components/ListenRemoteChanges.coffee","components/ListAdd.coffee","components/ListGet.coffee","components/ListRemove.coffee","components/RemoveItem.coffee","components/SetItem.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"html5","components":{"GetItem":"components/GetItem.coffee","ListenRemoteChanges":"components/ListenRemoteChanges.coffee","ListAdd":"components/ListAdd.coffee","ListGet":"components/ListGet.coffee","ListRemove":"components/ListRemove.coffee","RemoveItem":"components/RemoveItem.coffee","SetItem":"components/SetItem.coffee"}}}');
});
require.register("noflo-noflo-localstorage/components/GetItem.js", function(exports, require, module){
var GetItem, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetItem = (function(_super) {
  __extends(GetItem, _super);

  function GetItem() {
    this.inPorts = {
      key: new noflo.Port('string')
    };
    this.outPorts = {
      item: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        var value;
        value = localStorage.getItem(data);
        if (!value) {
          if (_this.outPorts.error.isAttached()) {
            _this.outPorts.error.send(new Error("" + data + " not found"));
            _this.outPorts.error.disconnect();
          }
          return;
        }
        _this.outPorts.item.beginGroup(data);
        _this.outPorts.item.send(value);
        return _this.outPorts.item.endGroup();
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.item.disconnect();
      };
    })(this));
  }

  return GetItem;

})(noflo.Component);

exports.getComponent = function() {
  return new GetItem;
};

});
require.register("noflo-noflo-localstorage/components/ListenRemoteChanges.js", function(exports, require, module){
var ListenChanges, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenChanges = (function(_super) {
  __extends(ListenChanges, _super);

  function ListenChanges() {
    var listener;
    this.listening = false;
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang')
    };
    this.outPorts = {
      changed: new noflo.Port('string'),
      removed: new noflo.Port('string')
    };
    listener = (function(_this) {
      return function(event) {
        if (event.newValue === null && _this.outPorts.removed.isAttached()) {
          _this.outPorts.removed.beginGroup(event.key);
          _this.outPorts.removed.send(null);
          _this.outPorts.removed.endGroup();
          return;
        }
        _this.outPorts.changed.beginGroup(event.key);
        _this.outPorts.changed.send(event.newValue);
        return _this.outPorts.changed.endGroup();
      };
    })(this);
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        if (_this.listening) {
          return;
        }
        window.addEventListener('storage', listener, false);
        return _this.listening = true;
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        if (!_this.listening) {
          return;
        }
        window.removeEventListener('storage', listener, false);
        _this.listening = false;
        _this.outPorts.changed.disconnect();
        return _this.outPorts.removed.disconnect();
      };
    })(this));
  }

  return ListenChanges;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenChanges;
};

});
require.register("noflo-noflo-localstorage/components/ListAdd.js", function(exports, require, module){
var ListAdd, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListAdd = (function(_super) {
  __extends(ListAdd, _super);

  function ListAdd() {
    this.listKey = null;
    this.key = null;
    this.inPorts = {
      list: new noflo.Port('string'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      key: new noflo.Port('string')
    };
    this.inPorts.list.on('data', (function(_this) {
      return function(listKey) {
        _this.listKey = listKey;
        return _this.add();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.add();
      };
    })(this));
  }

  ListAdd.prototype.add = function() {
    var items, list;
    if (!(this.listKey && this.key)) {
      return;
    }
    list = localStorage.getItem(this.listKey);
    if (list) {
      items = list.split(',');
    } else {
      items = [];
    }
    if (items.indexOf(this.key) === -1) {
      items.push(this.key);
      localStorage.setItem(this.listKey, items.join(','));
    }
    if (this.outPorts.key.isAttached()) {
      this.outPorts.key.send(this.key);
      this.outPorts.key.disconnect();
    }
    return this.key = null;
  };

  return ListAdd;

})(noflo.Component);

exports.getComponent = function() {
  return new ListAdd;
};

});
require.register("noflo-noflo-localstorage/components/ListGet.js", function(exports, require, module){
var ListGet, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListGet = (function(_super) {
  __extends(ListGet, _super);

  function ListGet() {
    this.inPorts = {
      key: new noflo.Port('string')
    };
    this.outPorts = {
      items: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        var val, vals, value, _i, _len;
        value = localStorage.getItem(data);
        if (!value) {
          if (_this.outPorts.error.isAttached()) {
            _this.outPorts.error.send(new Error("" + data + " not found"));
            _this.outPorts.error.disconnect();
          }
          return;
        }
        vals = value.split(',');
        _this.outPorts.items.beginGroup(data);
        for (_i = 0, _len = vals.length; _i < _len; _i++) {
          val = vals[_i];
          _this.outPorts.items.send(val);
        }
        return _this.outPorts.items.endGroup();
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.items.disconnect();
      };
    })(this));
  }

  return ListGet;

})(noflo.Component);

exports.getComponent = function() {
  return new ListGet;
};

});
require.register("noflo-noflo-localstorage/components/ListRemove.js", function(exports, require, module){
var ListRemove, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListRemove = (function(_super) {
  __extends(ListRemove, _super);

  function ListRemove() {
    this.listKey = null;
    this.key = null;
    this.inPorts = {
      list: new noflo.Port('string'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      key: new noflo.Port('string')
    };
    this.inPorts.list.on('data', (function(_this) {
      return function(listKey) {
        _this.listKey = listKey;
        return _this.remove();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.remove();
      };
    })(this));
  }

  ListRemove.prototype.remove = function() {
    var items, list;
    if (!(this.listKey && this.key)) {
      return;
    }
    list = localStorage.getItem(this.listKey);
    if (list) {
      items = list.split(',');
      if (items.indexOf(this.key) !== -1) {
        items.splice(items.indexOf(this.key), 1);
        localStorage.setItem(this.listKey, items.join(','));
      }
    }
    if (this.outPorts.key.isAttached()) {
      this.outPorts.key.send(this.key);
      this.outPorts.key.disconnect();
    }
    return this.key = null;
  };

  return ListRemove;

})(noflo.Component);

exports.getComponent = function() {
  return new ListRemove;
};

});
require.register("noflo-noflo-localstorage/components/RemoveItem.js", function(exports, require, module){
var RemoveItem, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

RemoveItem = (function(_super) {
  __extends(RemoveItem, _super);

  function RemoveItem() {
    this.inPorts = {
      key: new noflo.Port('string')
    };
    this.outPorts = {
      item: new noflo.Port('string')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        localStorage.removeItem(data);
        _this.outPorts.item.beginGroup(data);
        _this.outPorts.item.send(null);
        _this.outPorts.item.endGroup();
        return _this.outPorts.item.disconnect();
      };
    })(this));
  }

  return RemoveItem;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveItem;
};

});
require.register("noflo-noflo-localstorage/components/SetItem.js", function(exports, require, module){
var SetItem, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetItem = (function(_super) {
  __extends(SetItem, _super);

  function SetItem() {
    this.key = null;
    this.value = null;
    this.inPorts = {
      key: new noflo.Port('string'),
      value: new noflo.Port('string')
    };
    this.outPorts = {
      item: new noflo.Port('string')
    };
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        if (!data) {
          return;
        }
        _this.key = data;
        if (_this.value) {
          return _this.setItem();
        }
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(data) {
        _this.value = data;
        if (_this.key) {
          return _this.setItem();
        }
      };
    })(this));
  }

  SetItem.prototype.setItem = function() {
    localStorage.setItem(this.key, this.value);
    if (this.outPorts.item.isAttached()) {
      this.outPorts.item.beginGroup(this.key);
      this.outPorts.item.send(this.value);
      this.outPorts.item.endGroup();
      this.outPorts.item.disconnect();
    }
    this.key = null;
    return this.value = null;
  };

  return SetItem;

})(noflo.Component);

exports.getComponent = function() {
  return new SetItem;
};

});
require.register("noflo-noflo-math/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-math.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-math/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-math","description":"Mathematical components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-math","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Add.coffee","components/Subtract.coffee","components/Multiply.coffee","components/Divide.coffee","components/Floor.coffee","components/CalculateAngle.coffee","components/CalculateDistance.coffee","components/Compare.coffee","components/CountSum.coffee","lib/MathComponent.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"plus-circle","components":{"Add":"components/Add.coffee","Subtract":"components/Subtract.coffee","Multiply":"components/Multiply.coffee","Divide":"components/Divide.coffee","Floor":"components/Floor.coffee","CalculateAngle":"components/CalculateAngle.coffee","CalculateDistance":"components/CalculateDistance.coffee","Compare":"components/Compare.coffee","CountSum":"components/CountSum.coffee"}}}');
});
require.register("noflo-noflo-math/components/Add.js", function(exports, require, module){
var Add, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Add = (function(_super) {
  __extends(Add, _super);

  Add.prototype.icon = 'plus';

  function Add() {
    Add.__super__.constructor.call(this, 'augend', 'addend', 'sum');
  }

  Add.prototype.calculate = function(augend, addend) {
    return Number(augend) + Number(addend);
  };

  return Add;

})(MathComponent);

exports.getComponent = function() {
  return new Add;
};

});
require.register("noflo-noflo-math/components/Subtract.js", function(exports, require, module){
var MathComponent, Subtract,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Subtract = (function(_super) {
  __extends(Subtract, _super);

  Subtract.prototype.icon = 'minus';

  function Subtract() {
    Subtract.__super__.constructor.call(this, 'minuend', 'subtrahend', 'difference');
  }

  Subtract.prototype.calculate = function(minuend, subtrahend) {
    return minuend - subtrahend;
  };

  return Subtract;

})(MathComponent);

exports.getComponent = function() {
  return new Subtract;
};

});
require.register("noflo-noflo-math/components/Multiply.js", function(exports, require, module){
var MathComponent, Multiply,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Multiply = (function(_super) {
  __extends(Multiply, _super);

  Multiply.prototype.icon = 'asterisk';

  function Multiply() {
    Multiply.__super__.constructor.call(this, 'multiplicand', 'multiplier', 'product');
  }

  Multiply.prototype.calculate = function(multiplicand, multiplier) {
    return multiplicand * multiplier;
  };

  return Multiply;

})(MathComponent);

exports.getComponent = function() {
  return new Multiply;
};

});
require.register("noflo-noflo-math/components/Divide.js", function(exports, require, module){
var Divide, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

Divide = (function(_super) {
  __extends(Divide, _super);

  function Divide() {
    Divide.__super__.constructor.call(this, 'dividend', 'divisor', 'quotient');
  }

  Divide.prototype.calculate = function(dividend, divisor) {
    return dividend / divisor;
  };

  return Divide;

})(MathComponent);

exports.getComponent = function() {
  return new Divide;
};

});
require.register("noflo-noflo-math/components/Floor.js", function(exports, require, module){
var Floor, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Floor = (function(_super) {
  __extends(Floor, _super);

  function Floor() {
    this.inPorts = {
      "in": new noflo.Port('number')
    };
    this.outPorts = {
      out: new noflo.Port('integer')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(Math.floor(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Floor;

})(noflo.Component);

exports.getComponent = function() {
  return new Floor;
};

});
require.register("noflo-noflo-math/components/CalculateAngle.js", function(exports, require, module){
var CalculateAngle, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

CalculateAngle = (function(_super) {
  __extends(CalculateAngle, _super);

  CalculateAngle.prototype.description = 'Calculate the angle between two points';

  CalculateAngle.prototype.icon = 'compass';

  function CalculateAngle() {
    CalculateAngle.__super__.constructor.call(this, 'origin', 'destination', 'angle', 'object');
  }

  CalculateAngle.prototype.calculate = function(origin, destination) {
    var angle, deltaX, deltaY;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    origin = null;
    destination = null;
    angle = (Math.atan2(deltaY, deltaX) * 180 / Math.PI) + 90;
    if (angle < 0) {
      angle = angle + 360;
    }
    return angle;
  };

  return CalculateAngle;

})(MathComponent);

exports.getComponent = function() {
  return new CalculateAngle;
};

});
require.register("noflo-noflo-math/components/CalculateDistance.js", function(exports, require, module){
var CalculateDistance, MathComponent,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathComponent = require('../lib/MathComponent').MathComponent;

CalculateDistance = (function(_super) {
  __extends(CalculateDistance, _super);

  CalculateDistance.prototype.icon = 'arrow-right';

  CalculateDistance.prototype.description = 'Calculate the distance between two points';

  function CalculateDistance() {
    CalculateDistance.__super__.constructor.call(this, 'origin', 'destination', 'distance', 'object');
  }

  CalculateDistance.prototype.calculate = function(origin, destination) {
    var deltaX, deltaY, distance;
    deltaX = destination.x - origin.x;
    deltaY = destination.y - origin.y;
    origin = null;
    destination = null;
    distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    return distance;
  };

  return CalculateDistance;

})(MathComponent);

exports.getComponent = function() {
  return new CalculateDistance;
};

});
require.register("noflo-noflo-math/components/Compare.js", function(exports, require, module){
var Compare, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Compare = (function(_super) {
  __extends(Compare, _super);

  Compare.prototype.description = 'Compare two numbers';

  Compare.prototype.icon = 'check';

  function Compare() {
    this.operator = '==';
    this.value = null;
    this.comparison = null;
    this.inPorts = {
      value: new noflo.Port('number'),
      comparison: new noflo.Port('number'),
      operator: new noflo.Port('string')
    };
    this.outPorts = {
      pass: new noflo.Port('number'),
      fail: new noflo.Port('number')
    };
    this.inPorts.operator.on('data', (function(_this) {
      return function(operator) {
        _this.operator = operator;
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.value = value;
        if (_this.comparison) {
          return _this.compare();
        }
      };
    })(this));
    this.inPorts.value.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.pass.disconnect();
      };
    })(this));
    this.inPorts.comparison.on('data', (function(_this) {
      return function(comparison) {
        _this.comparison = comparison;
        if (_this.value) {
          return _this.compare();
        }
      };
    })(this));
  }

  Compare.prototype.compare = function() {
    switch (this.operator) {
      case 'eq':
      case '==':
        if (this.value === this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'ne':
      case '!=':
        if (this.value !== this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'gt':
      case '>':
        if (this.value > this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'lt':
      case '<':
        if (this.value < this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'ge':
      case '>=':
        if (this.value >= this.comparison) {
          return this.send(this.value);
        }
        break;
      case 'le':
      case '<=':
        if (this.value <= this.comparison) {
          return this.send(this.value);
        }
    }
    if (!this.outPorts.fail.isAttached()) {
      return;
    }
    this.outPorts.fail.send(this.value);
    return this.outPorts.fail.disconnect();
  };

  Compare.prototype.send = function(val) {
    return this.outPorts.pass.send(this.value);
  };

  return Compare;

})(noflo.Component);

exports.getComponent = function() {
  return new Compare;
};

});
require.register("noflo-noflo-math/components/CountSum.js", function(exports, require, module){
var CountSum, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CountSum = (function(_super) {
  __extends(CountSum, _super);

  function CountSum() {
    this.portCounts = {};
    this.inPorts = {
      "in": new noflo.ArrayPort('number')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('number')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data, portId) {
        return _this.count(portId, data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(socket, portId) {
        var _i, _len, _ref;
        _ref = _this.inPorts["in"].sockets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          socket = _ref[_i];
          if (socket.isConnected()) {
            return;
          }
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  CountSum.prototype.count = function(port, data) {
    var id, socket, sum, _i, _len, _ref;
    sum = 0;
    this.portCounts[port] = data;
    _ref = this.inPorts["in"].sockets;
    for (id = _i = 0, _len = _ref.length; _i < _len; id = ++_i) {
      socket = _ref[id];
      if (typeof this.portCounts[id] === 'undefined') {
        this.portCounts[id] = 0;
      }
      sum += this.portCounts[id];
    }
    return this.outPorts.out.send(sum);
  };

  return CountSum;

})(noflo.Component);

exports.getComponent = function() {
  return new CountSum;
};

});
require.register("noflo-noflo-math/lib/MathComponent.js", function(exports, require, module){
var MathComponent, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MathComponent = (function(_super) {
  __extends(MathComponent, _super);

  function MathComponent(primary, secondary, res, inputType) {
    var calculate;
    if (inputType == null) {
      inputType = 'number';
    }
    this.inPorts = {};
    this.outPorts = {};
    this.inPorts[primary] = new noflo.Port(inputType);
    this.inPorts[secondary] = new noflo.Port(inputType);
    this.inPorts.clear = new noflo.Port('bang');
    this.outPorts[res] = new noflo.Port('number');
    this.primary = {
      value: null,
      group: [],
      disconnect: false
    };
    this.secondary = null;
    this.groups = [];
    calculate = (function(_this) {
      return function() {
        var group, _i, _j, _len, _len1, _ref, _ref1;
        _ref = _this.primary.group;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts[res].beginGroup(group);
        }
        _this.outPorts[res].send(_this.calculate(_this.primary.value, _this.secondary));
        _ref1 = _this.primary.group;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _this.outPorts[res].endGroup();
        }
        if (_this.primary.disconnect) {
          return _this.outPorts[res].disconnect();
        }
      };
    })(this);
    this.inPorts[primary].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts[primary].on('data', (function(_this) {
      return function(data) {
        _this.primary = {
          value: data,
          group: _this.groups.slice(0),
          disconnect: false
        };
        if (_this.secondary !== null) {
          return calculate();
        }
      };
    })(this));
    this.inPorts[primary].on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts[primary].on('disconnect', (function(_this) {
      return function() {
        _this.primary.disconnect = true;
        return _this.outPorts[res].disconnect();
      };
    })(this));
    this.inPorts[secondary].on('data', (function(_this) {
      return function(data) {
        _this.secondary = data;
        if (_this.primary.value !== null) {
          return calculate();
        }
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function(data) {
        var group, _i, _len, _ref;
        if (_this.outPorts[res].isConnected()) {
          _ref = _this.primary.group;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            group = _ref[_i];
            _this.outPorts[res].endGroup();
          }
          if (_this.primary.disconnect) {
            _this.outPorts[res].disconnect();
          }
        }
        _this.primary = {
          value: null,
          group: [],
          disconnect: false
        };
        _this.secondary = null;
        return _this.groups = [];
      };
    })(this));
  }

  return MathComponent;

})(noflo.Component);

exports.MathComponent = MathComponent;

});
require.register("noflo-noflo-objects/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of objects.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-objects/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-objects","description":"Object Utilities for NoFlo","version":"0.1.0","keywords":["noflo","objects","utilities"],"author":"Kenneth Kan <kenhkan@gmail.com>","repo":"noflo/objects","dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/Extend.coffee","components/MergeObjects.coffee","components/SplitObject.coffee","components/ReplaceKey.coffee","components/Keys.coffee","components/Size.coffee","components/Values.coffee","components/Join.coffee","components/ExtractProperty.coffee","components/InsertProperty.coffee","components/SliceArray.coffee","components/SplitArray.coffee","components/FilterPropertyValue.coffee","components/FlattenObject.coffee","components/MapProperty.coffee","components/RemoveProperty.coffee","components/MapPropertyValue.coffee","components/GetObjectKey.coffee","components/UniqueArray.coffee","components/SetProperty.coffee","components/SimplifyObject.coffee","components/DuplicateProperty.coffee","components/CreateObject.coffee","components/CreateDate.coffee","components/SetPropertyValue.coffee","components/CallMethod.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"list","components":{"Extend":"components/Extend.coffee","MergeObjects":"components/MergeObjects.coffee","SplitObject":"components/SplitObject.coffee","ReplaceKey":"components/ReplaceKey.coffee","Keys":"components/Keys.coffee","Size":"components/Size.coffee","Values":"components/Values.coffee","Join":"components/Join.coffee","ExtractProperty":"components/ExtractProperty.coffee","InsertProperty":"components/InsertProperty.coffee","SliceArray":"components/SliceArray.coffee","SplitArray":"components/SplitArray.coffee","FilterPropertyValue":"components/FilterPropertyValue.coffee","FlattenObject":"components/FlattenObject.coffee","MapProperty":"components/MapProperty.coffee","RemoveProperty":"components/RemoveProperty.coffee","MapPropertyValue":"components/MapPropertyValue.coffee","GetObjectKey":"components/GetObjectKey.coffee","UniqueArray":"components/UniqueArray.coffee","SetProperty":"components/SetProperty.coffee","SimplifyObject":"components/SimplifyObject.coffee","DuplicateProperty":"components/DuplicateProperty.coffee","CreateObject":"components/CreateObject.coffee","CreateDate":"components/CreateDate.coffee","SetPropertyValue":"components/SetPropertyValue.coffee","CallMethod":"components/CallMethod.coffee"}}}');
});
require.register("noflo-noflo-objects/components/Extend.js", function(exports, require, module){
var Extend, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

Extend = (function(_super) {
  __extends(Extend, _super);

  Extend.prototype.description = "Extend an incoming object to some predefined objects, optionally by a certain property";

  function Extend() {
    this.bases = [];
    this.mergedBase = {};
    this.key = null;
    this.reverse = false;
    this.inPorts = {
      "in": new noflo.Port,
      base: new noflo.Port,
      key: new noflo.Port,
      reverse: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.base.on("connect", (function(_this) {
      return function() {
        return _this.bases = [];
      };
    })(this));
    this.inPorts.base.on("data", (function(_this) {
      return function(base) {
        if (base != null) {
          return _this.bases.push(base);
        }
      };
    })(this));
    this.inPorts.key.on("data", (function(_this) {
      return function(key) {
        _this.key = key;
      };
    })(this));
    this.inPorts.reverse.on("data", (function(_this) {
      return function(reverse) {
        return _this.reverse = reverse === 'true';
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function(group) {};
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(incoming) {
        var base, out, _i, _len, _ref;
        out = {};
        _ref = _this.bases;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          base = _ref[_i];
          if ((_this.key == null) || (incoming[_this.key] != null) && incoming[_this.key] === base[_this.key]) {
            _.extend(out, base);
          }
        }
        if (_this.reverse) {
          return _this.outPorts.out.send(_.extend({}, incoming, out));
        } else {
          return _this.outPorts.out.send(_.extend(out, incoming));
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Extend;

})(noflo.Component);

exports.getComponent = function() {
  return new Extend;
};

});
require.register("noflo-noflo-objects/components/MergeObjects.js", function(exports, require, module){
var MergeObjects, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

MergeObjects = (function(_super) {
  __extends(MergeObjects, _super);

  MergeObjects.prototype.description = "merges all incoming objects into one";

  function MergeObjects() {
    this.merge = _.bind(this.merge, this);
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.groups = [];
        return _this.objects = [];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(object) {
        return _this.objects.push(object);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.send(_.reduce(_this.objects, _this.merge, {}));
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MergeObjects.prototype.merge = function(origin, object) {
    var key, oValue, value;
    for (key in object) {
      value = object[key];
      oValue = origin[key];
      if (oValue != null) {
        switch (toString.call(oValue)) {
          case "[object Array]":
            origin[key].push.apply(origin[key], value);
            break;
          case "[object Object]":
            origin[key] = this.merge(oValue, value);
            break;
          default:
            origin[key] = value;
        }
      } else {
        origin[key] = value;
      }
    }
    return origin;
  };

  return MergeObjects;

})(noflo.Component);

exports.getComponent = function() {
  return new MergeObjects;
};

});
require.register("noflo-noflo-objects/components/SplitObject.js", function(exports, require, module){
var SplitObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

SplitObject = (function(_super) {
  __extends(SplitObject, _super);

  SplitObject.prototype.description = "splits a single object into multiple IPs, wrapped with the key as the group";

  function SplitObject() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, value, _results;
        _results = [];
        for (key in data) {
          value = data[key];
          _this.outPorts.out.beginGroup(key);
          _this.outPorts.out.send(value);
          _results.push(_this.outPorts.out.endGroup());
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return SplitObject;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitObject;
};

});
require.register("noflo-noflo-objects/components/ReplaceKey.js", function(exports, require, module){
var ReplaceKey, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

ReplaceKey = (function(_super) {
  __extends(ReplaceKey, _super);

  ReplaceKey.prototype.description = "given a regexp matching any key of an incoming object as a data IP, replace the key with the provided string";

  function ReplaceKey() {
    this.patterns = {};
    this.inPorts = {
      "in": new noflo.Port,
      pattern: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.pattern.on("data", (function(_this) {
      return function(patterns) {
        _this.patterns = patterns;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, newKey, pattern, replace, value, _ref;
        newKey = null;
        for (key in data) {
          value = data[key];
          _ref = _this.patterns;
          for (pattern in _ref) {
            replace = _ref[pattern];
            pattern = new RegExp(pattern);
            if (key.match(pattern) != null) {
              newKey = key.replace(pattern, replace);
              data[newKey] = value;
              delete data[key];
            }
          }
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.pattern = null;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return ReplaceKey;

})(noflo.Component);

exports.getComponent = function() {
  return new ReplaceKey;
};

});
require.register("noflo-noflo-objects/components/Keys.js", function(exports, require, module){
var Keys, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Keys = (function(_super) {
  __extends(Keys, _super);

  Keys.prototype.description = "gets only the keys of an object and forward them as an array";

  function Keys() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('all')
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, _i, _len, _ref, _results;
        _ref = _.keys(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          _results.push(_this.outPorts.out.send(key));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Keys;

})(noflo.Component);

exports.getComponent = function() {
  return new Keys;
};

});
require.register("noflo-noflo-objects/components/Size.js", function(exports, require, module){
var Size, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Size = (function(_super) {
  __extends(Size, _super);

  Size.prototype.description = "gets the size of an object and sends that out as a number";

  function Size() {
    this.inPorts = {
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('integer')
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_.size(data));
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Size;

})(noflo.Component);

exports.getComponent = function() {
  return new Size;
};

});
require.register("noflo-noflo-objects/components/Values.js", function(exports, require, module){
var Values, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Values = (function(_super) {
  __extends(Values, _super);

  Values.prototype.description = "gets only the values of an object and forward them as an array";

  function Values() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var value, _i, _len, _ref, _results;
        _ref = _.values(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          value = _ref[_i];
          _results.push(_this.outPorts.out.send(value));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Values;

})(noflo.Component);

exports.getComponent = function() {
  return new Values;
};

});
require.register("noflo-noflo-objects/components/Join.js", function(exports, require, module){
var Join, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

Join = (function(_super) {
  __extends(Join, _super);

  Join.prototype.description = "Join all values of a passed packet together as a string with a predefined delimiter";

  function Join() {
    this.delimiter = ",";
    this.inPorts = {
      "in": new noflo.Port,
      delimiter: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.delimiter.on("data", (function(_this) {
      return function(delimiter) {
        _this.delimiter = delimiter;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(object) {
        if (_.isObject(object)) {
          return _this.outPorts.out.send(_.values(object).join(_this.delimiter));
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Join;

})(noflo.Component);

exports.getComponent = function() {
  return new Join;
};

});
require.register("noflo-noflo-objects/components/ExtractProperty.js", function(exports, require, module){
var ExtractProperty, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

ExtractProperty = (function(_super) {
  __extends(ExtractProperty, _super);

  ExtractProperty.prototype.description = "Given a key, return only the value matching that key in the incoming object";

  function ExtractProperty() {
    this.inPorts = {
      "in": new noflo.Port,
      key: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.key.on("connect", (function(_this) {
      return function() {
        return _this.keys = [];
      };
    })(this));
    this.inPorts.key.on("data", (function(_this) {
      return function(key) {
        return _this.keys.push(key);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, value, _i, _len, _ref;
        if ((_this.keys != null) && _.isObject(data)) {
          value = data;
          _ref = _this.keys;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            value = value[key];
          }
          return _this.outPorts.out.send(value);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return ExtractProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new ExtractProperty;
};

});
require.register("noflo-noflo-objects/components/InsertProperty.js", function(exports, require, module){
var InsertProperty, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

InsertProperty = (function(_super) {
  __extends(InsertProperty, _super);

  InsertProperty.prototype.description = "Insert a property into incoming objects.";

  function InsertProperty() {
    this.properties = {};
    this.inPorts = {
      "in": new noflo.Port,
      property: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.property.on("connect", (function(_this) {
      return function() {
        return _this.properties = {};
      };
    })(this));
    this.inPorts.property.on("begingroup", (function(_this) {
      return function(key) {
        _this.key = key;
      };
    })(this));
    this.inPorts.property.on("data", (function(_this) {
      return function(value) {
        if (_this.key != null) {
          return _this.properties[_this.key] = value;
        }
      };
    })(this));
    this.inPorts.property.on("endgroup", (function(_this) {
      return function() {
        return _this.key = null;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var key, value, _ref;
        if (!_.isObject(data)) {
          data = {};
        }
        _ref = _this.properties;
        for (key in _ref) {
          value = _ref[key];
          data[key] = value;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return InsertProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new InsertProperty;
};

});
require.register("noflo-noflo-objects/components/SliceArray.js", function(exports, require, module){
var SliceArray, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SliceArray = (function(_super) {
  __extends(SliceArray, _super);

  function SliceArray() {
    this.begin = 0;
    this.end = null;
    this.inPorts = {
      "in": new noflo.Port(),
      begin: new noflo.Port(),
      end: new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port(),
      error: new noflo.Port()
    };
    this.inPorts.begin.on('data', (function(_this) {
      return function(data) {
        return _this.begin = data;
      };
    })(this));
    this.inPorts.end.on('data', (function(_this) {
      return function(data) {
        return _this.end = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.sliceData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SliceArray.prototype.sliceData = function(data) {
    var sliced;
    if (!data.slice) {
      return this.outPorts.error.send("Data " + (typeof data) + " cannot be sliced");
    }
    if (this.end !== null) {
      sliced = data.slice(this.begin, this.end);
    }
    if (this.end === null) {
      sliced = data.slice(this.begin);
    }
    return this.outPorts.out.send(sliced);
  };

  return SliceArray;

})(noflo.Component);

exports.getComponent = function() {
  return new SliceArray;
};

});
require.register("noflo-noflo-objects/components/SplitArray.js", function(exports, require, module){
var SplitArray, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SplitArray = (function(_super) {
  __extends(SplitArray, _super);

  function SplitArray() {
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.ArrayPort()
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var item, key, _i, _len, _results;
        if (toString.call(data) !== '[object Array]') {
          for (key in data) {
            item = data[key];
            _this.outPorts.out.beginGroup(key);
            _this.outPorts.out.send(item);
            _this.outPorts.out.endGroup();
          }
          return;
        }
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          _results.push(_this.outPorts.out.send(item));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(data) {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return SplitArray;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitArray;
};

});
require.register("noflo-noflo-objects/components/FilterPropertyValue.js", function(exports, require, module){
var FilterPropertyValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FilterPropertyValue = (function(_super) {
  __extends(FilterPropertyValue, _super);

  FilterPropertyValue.prototype.icon = 'filter';

  function FilterPropertyValue() {
    this.accepts = {};
    this.regexps = {};
    this.inPorts = {
      accept: new noflo.ArrayPort('all'),
      regexp: new noflo.ArrayPort('string'),
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts.accept.on('data', (function(_this) {
      return function(data) {
        return _this.prepareAccept(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.filtering()) {
          return _this.filterData(data);
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  FilterPropertyValue.prototype.filtering = function() {
    return (Object.keys(this.accepts)).length > 0 || (Object.keys(this.regexps)).length > 0;
  };

  FilterPropertyValue.prototype.prepareAccept = function(map) {
    var e, mapParts;
    if (typeof map === 'object') {
      this.accepts = map;
      return;
    }
    mapParts = map.split('=');
    try {
      return this.accepts[mapParts[0]] = eval(mapParts[1]);
    } catch (_error) {
      e = _error;
      if (e instanceof ReferenceError) {
        return this.accepts[mapParts[0]] = mapParts[1];
      } else {
        throw e;
      }
    }
  };

  FilterPropertyValue.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    return this.regexps[mapParts[0]] = mapParts[1];
  };

  FilterPropertyValue.prototype.filterData = function(object) {
    var match, newData, property, regexp, value;
    newData = {};
    match = false;
    for (property in object) {
      value = object[property];
      if (this.accepts[property]) {
        if (this.accepts[property] !== value) {
          continue;
        }
        match = true;
      }
      if (this.regexps[property]) {
        regexp = new RegExp(this.regexps[property]);
        if (!regexp.exec(value)) {
          continue;
        }
        match = true;
      }
      newData[property] = value;
      continue;
    }
    if (!match) {
      if (!this.outPorts.missed.isAttached()) {
        return;
      }
      this.outPorts.missed.send(object);
      this.outPorts.missed.disconnect();
      return;
    }
    return this.outPorts.out.send(newData);
  };

  return FilterPropertyValue;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterPropertyValue;
};

});
require.register("noflo-noflo-objects/components/FlattenObject.js", function(exports, require, module){
var FlattenObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FlattenObject = (function(_super) {
  __extends(FlattenObject, _super);

  function FlattenObject() {
    this.map = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var object, _i, _len, _ref, _results;
        _ref = _this.flattenObject(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          _results.push(_this.outPorts.out.send(_this.mapKeys(object)));
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  FlattenObject.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.map = map;
      return;
    }
    mapParts = map.split('=');
    return this.map[mapParts[0]] = mapParts[1];
  };

  FlattenObject.prototype.mapKeys = function(object) {
    var key, map, _ref;
    _ref = this.map;
    for (key in _ref) {
      map = _ref[key];
      object[map] = object.flattenedKeys[key];
    }
    delete object.flattenedKeys;
    return object;
  };

  FlattenObject.prototype.flattenObject = function(object) {
    var flattened, flattenedValue, key, val, value, _i, _len;
    flattened = [];
    for (key in object) {
      value = object[key];
      if (typeof value === 'object') {
        flattenedValue = this.flattenObject(value);
        for (_i = 0, _len = flattenedValue.length; _i < _len; _i++) {
          val = flattenedValue[_i];
          val.flattenedKeys.push(key);
          flattened.push(val);
        }
        continue;
      }
      flattened.push({
        flattenedKeys: [key],
        value: value
      });
    }
    return flattened;
  };

  return FlattenObject;

})(noflo.Component);

exports.getComponent = function() {
  return new FlattenObject;
};

});
require.register("noflo-noflo-objects/components/MapProperty.js", function(exports, require, module){
var MapProperty, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MapProperty = (function(_super) {
  __extends(MapProperty, _super);

  function MapProperty() {
    this.map = {};
    this.regexps = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.mapData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MapProperty.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.map = map;
      return;
    }
    mapParts = map.split('=');
    return this.map[mapParts[0]] = mapParts[1];
  };

  MapProperty.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    return this.regexps[mapParts[0]] = mapParts[1];
  };

  MapProperty.prototype.mapData = function(data) {
    var expression, matched, newData, property, regexp, replacement, value, _ref;
    newData = {};
    for (property in data) {
      value = data[property];
      if (property in this.map) {
        property = this.map[property];
      }
      _ref = this.regexps;
      for (expression in _ref) {
        replacement = _ref[expression];
        regexp = new RegExp(expression);
        matched = regexp.exec(property);
        if (!matched) {
          continue;
        }
        property = property.replace(regexp, replacement);
      }
      if (property in newData) {
        if (Array.isArray(newData[property])) {
          newData[property].push(value);
        } else {
          newData[property] = [newData[property], value];
        }
      } else {
        newData[property] = value;
      }
    }
    return this.outPorts.out.send(newData);
  };

  return MapProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new MapProperty;
};

});
require.register("noflo-noflo-objects/components/RemoveProperty.js", function(exports, require, module){
var RemoveProperty, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

RemoveProperty = (function(_super) {
  __extends(RemoveProperty, _super);

  RemoveProperty.prototype.icon = 'ban';

  function RemoveProperty() {
    this.properties = [];
    this.inPorts = {
      "in": new noflo.Port(),
      property: new noflo.ArrayPort()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        return _this.properties.push(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.removeProperties(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  RemoveProperty.prototype.removeProperties = function(object) {
    var property, _i, _len, _ref;
    object = _.clone(object);
    _ref = this.properties;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      property = _ref[_i];
      delete object[property];
    }
    return object;
  };

  return RemoveProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new RemoveProperty;
};

});
require.register("noflo-noflo-objects/components/MapPropertyValue.js", function(exports, require, module){
var MapPropertyValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

MapPropertyValue = (function(_super) {
  __extends(MapPropertyValue, _super);

  function MapPropertyValue() {
    this.mapAny = {};
    this.map = {};
    this.regexpAny = {};
    this.regexp = {};
    this.inPorts = {
      map: new noflo.ArrayPort(),
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.map.on('data', (function(_this) {
      return function(data) {
        return _this.prepareMap(data);
      };
    })(this));
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.prepareRegExp(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.mapData(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  MapPropertyValue.prototype.prepareMap = function(map) {
    var mapParts;
    if (typeof map === 'object') {
      this.mapAny = map;
      return;
    }
    mapParts = map.split('=');
    if (mapParts.length === 3) {
      this.map[mapParts[0]] = {
        from: mapParts[1],
        to: mapParts[2]
      };
      return;
    }
    return this.mapAny[mapParts[0]] = mapParts[1];
  };

  MapPropertyValue.prototype.prepareRegExp = function(map) {
    var mapParts;
    mapParts = map.split('=');
    if (mapParts.length === 3) {
      this.regexp[mapParts[0]] = {
        from: mapParts[1],
        to: mapParts[2]
      };
      return;
    }
    return this.regexpAny[mapParts[0]] = mapParts[1];
  };

  MapPropertyValue.prototype.mapData = function(data) {
    var expression, matched, property, regexp, replacement, value, _ref;
    for (property in data) {
      value = data[property];
      if (this.map[property] && this.map[property].from === value) {
        data[property] = this.map[property].to;
      }
      if (this.mapAny[value]) {
        data[property] = this.mapAny[value];
      }
      if (this.regexp[property]) {
        regexp = new RegExp(this.regexp[property].from);
        matched = regexp.exec(value);
        if (matched) {
          data[property] = value.replace(regexp, this.regexp[property].to);
        }
      }
      _ref = this.regexpAny;
      for (expression in _ref) {
        replacement = _ref[expression];
        regexp = new RegExp(expression);
        matched = regexp.exec(value);
        if (!matched) {
          continue;
        }
        data[property] = value.replace(regexp, replacement);
      }
    }
    return this.outPorts.out.send(data);
  };

  return MapPropertyValue;

})(noflo.Component);

exports.getComponent = function() {
  return new MapPropertyValue;
};

});
require.register("noflo-noflo-objects/components/GetObjectKey.js", function(exports, require, module){
var GetObjectKey, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetObjectKey = (function(_super) {
  __extends(GetObjectKey, _super);

  GetObjectKey.prototype.icon = 'indent';

  function GetObjectKey() {
    this.sendGroup = true;
    this.data = [];
    this.key = [];
    this.inPorts = {
      "in": new noflo.Port('object'),
      key: new noflo.ArrayPort('string'),
      sendgroup: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      object: new noflo.Port('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.data = [];
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.key.length) {
          return _this.getKey(data);
        }
        return _this.data.push(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          _this.outPorts.out.disconnect();
          return;
        }
        if (!_this.key.length) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        _this.outPorts.out.disconnect();
        if (_this.outPorts.object.isAttached()) {
          return _this.outPorts.object.disconnect();
        }
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(data) {
        return _this.key.push(data);
      };
    })(this));
    this.inPorts.key.on('disconnect', (function(_this) {
      return function() {
        var data, _i, _len, _ref;
        if (!_this.data.length) {
          return;
        }
        _ref = _this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          _this.getKey(data);
        }
        _this.data = [];
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.sendgroup.on('data', (function(_this) {
      return function(data) {
        return _this.sendGroup = String(data) === 'true';
      };
    })(this));
  }

  GetObjectKey.prototype.error = function(data, error) {
    if (this.outPorts.missed.isAttached()) {
      this.outPorts.missed.send(data);
      this.outPorts.missed.disconnect();
      return;
    }
    throw error;
  };

  GetObjectKey.prototype.getKey = function(data) {
    var key, _i, _len, _ref;
    if (!this.key.length) {
      this.error(data, new Error('Key not defined'));
      return;
    }
    if (typeof data !== 'object') {
      this.error(data, new Error('Data is not an object'));
      return;
    }
    if (data === null) {
      this.error(data, new Error('Data is NULL'));
      return;
    }
    _ref = this.key;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      if (data[key] === void 0) {
        this.error(data, new Error("Object has no key " + key));
        continue;
      }
      if (this.sendGroup) {
        this.outPorts.out.beginGroup(key);
      }
      this.outPorts.out.send(data[key]);
      if (this.sendGroup) {
        this.outPorts.out.endGroup();
      }
    }
    if (!this.outPorts.object.isAttached()) {
      return;
    }
    return this.outPorts.object.send(data);
  };

  return GetObjectKey;

})(noflo.Component);

exports.getComponent = function() {
  return new GetObjectKey;
};

});
require.register("noflo-noflo-objects/components/UniqueArray.js", function(exports, require, module){
var UniqueArray, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

UniqueArray = (function(_super) {
  __extends(UniqueArray, _super);

  function UniqueArray() {
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.unique(data));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  UniqueArray.prototype.unique = function(array) {
    var member, newArray, seen, _i, _len;
    seen = {};
    newArray = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      member = array[_i];
      seen[member] = member;
    }
    for (member in seen) {
      newArray.push(member);
    }
    return newArray;
  };

  return UniqueArray;

})(noflo.Component);

exports.getComponent = function() {
  return new UniqueArray;
};

});
require.register("noflo-noflo-objects/components/SetProperty.js", function(exports, require, module){
var SetProperty, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetProperty = (function(_super) {
  __extends(SetProperty, _super);

  function SetProperty() {
    this.properties = {};
    this.inPorts = {
      property: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        return _this.setProperty(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.addProperties(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SetProperty.prototype.setProperty = function(prop) {
    var propParts;
    if (typeof prop === 'object') {
      this.prop = prop;
      return;
    }
    propParts = prop.split('=');
    return this.properties[propParts[0]] = propParts[1];
  };

  SetProperty.prototype.addProperties = function(object) {
    var property, value, _ref;
    _ref = this.properties;
    for (property in _ref) {
      value = _ref[property];
      object[property] = value;
    }
    return this.outPorts.out.send(object);
  };

  return SetProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new SetProperty;
};

});
require.register("noflo-noflo-objects/components/SimplifyObject.js", function(exports, require, module){
var SimplifyObject, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore')._;

SimplifyObject = (function(_super) {
  __extends(SimplifyObject, _super);

  function SimplifyObject() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on('beginGroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.simplify(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SimplifyObject.prototype.simplify = function(data) {
    if (_.isArray(data)) {
      if (data.length === 1) {
        return data[0];
      }
      return data;
    }
    if (!_.isObject(data)) {
      return data;
    }
    return this.simplifyObject(data);
  };

  SimplifyObject.prototype.simplifyObject = function(data) {
    var keys, simplified;
    keys = _.keys(data);
    if (keys.length === 1 && keys[0] === '$data') {
      return this.simplify(data['$data']);
    }
    simplified = {};
    _.each(data, (function(_this) {
      return function(value, key) {
        return simplified[key] = _this.simplify(value);
      };
    })(this));
    return simplified;
  };

  return SimplifyObject;

})(noflo.Component);

exports.getComponent = function() {
  return new SimplifyObject;
};

});
require.register("noflo-noflo-objects/components/DuplicateProperty.js", function(exports, require, module){
var DuplicateProperty, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DuplicateProperty = (function(_super) {
  __extends(DuplicateProperty, _super);

  function DuplicateProperty() {
    this.properties = {};
    this.separator = '/';
    this.inPorts = {
      property: new noflo.ArrayPort(),
      separator: new noflo.Port(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        return _this.setProperty(data);
      };
    })(this));
    this.inPorts.separator.on('data', (function(_this) {
      return function(data) {
        return _this.separator = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.addProperties(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  DuplicateProperty.prototype.setProperty = function(prop) {
    var propParts;
    if (typeof prop === 'object') {
      this.prop = prop;
      return;
    }
    propParts = prop.split('=');
    if (propParts.length > 2) {
      this.properties[propParts.pop()] = propParts;
      return;
    }
    return this.properties[propParts[1]] = propParts[0];
  };

  DuplicateProperty.prototype.addProperties = function(object) {
    var newValues, newprop, original, originalProp, _i, _len, _ref;
    _ref = this.properties;
    for (newprop in _ref) {
      original = _ref[newprop];
      if (typeof original === 'string') {
        object[newprop] = object[original];
        continue;
      }
      newValues = [];
      for (_i = 0, _len = original.length; _i < _len; _i++) {
        originalProp = original[_i];
        newValues.push(object[originalProp]);
      }
      object[newprop] = newValues.join(this.separator);
    }
    return this.outPorts.out.send(object);
  };

  return DuplicateProperty;

})(noflo.Component);

exports.getComponent = function() {
  return new DuplicateProperty;
};

});
require.register("noflo-noflo-objects/components/CreateObject.js", function(exports, require, module){
var CreateObject, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateObject = (function(_super) {
  __extends(CreateObject, _super);

  function CreateObject() {
    this.inPorts = {
      start: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.start.on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts.start.on("data", (function(_this) {
      return function() {
        return _this.outPorts.out.send({});
      };
    })(this));
    this.inPorts.start.on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts.start.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return CreateObject;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateObject;
};

});
require.register("noflo-noflo-objects/components/CreateDate.js", function(exports, require, module){
var CreateDate, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

CreateDate = (function(_super) {
  __extends(CreateDate, _super);

  CreateDate.prototype.description = 'Create a new Date object from string';

  CreateDate.prototype.icon = 'clock-o';

  function CreateDate() {
    this.inPorts = {
      "in": new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var date;
        if (data === "now" || data === null || data === true) {
          date = new Date;
        } else {
          date = new Date(data);
        }
        return _this.outPorts.out.send(date);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return CreateDate;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateDate;
};

});
require.register("noflo-noflo-objects/components/SetPropertyValue.js", function(exports, require, module){
var SetPropertyValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SetPropertyValue = (function(_super) {
  __extends(SetPropertyValue, _super);

  function SetPropertyValue() {
    this.property = null;
    this.value = null;
    this.data = [];
    this.groups = [];
    this.keep = false;
    this.inPorts = {
      property: new noflo.Port('string'),
      value: new noflo.Port('all'),
      "in": new noflo.Port('object'),
      keep: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.keep.on('data', (function(_this) {
      return function(keep) {
        return _this.keep = String(keep) === 'true';
      };
    })(this));
    this.inPorts.property.on('data', (function(_this) {
      return function(data) {
        _this.property = data;
        if (_this.value && _this.data.length) {
          return _this.addProperties();
        }
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(data) {
        _this.value = data;
        if (_this.property && _this.data.length) {
          return _this.addProperties();
        }
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.property && _this.value) {
          _this.addProperty({
            data: data,
            group: _this.groups.slice(0)
          });
          return;
        }
        return _this.data.push({
          data: data,
          group: _this.groups.slice(0)
        });
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.property && _this.value) {
          _this.outPorts.out.disconnect();
        }
        if (!_this.keep) {
          return _this.value = null;
        }
      };
    })(this));
  }

  SetPropertyValue.prototype.addProperty = function(object) {
    var group, _i, _j, _len, _len1, _ref, _ref1, _results;
    object.data[this.property] = this.value;
    _ref = object.group;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(object.data);
    _ref1 = object.group;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  SetPropertyValue.prototype.addProperties = function() {
    var object, _i, _len, _ref;
    _ref = this.data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      this.addProperty(object);
    }
    this.data = [];
    return this.outPorts.out.disconnect();
  };

  return SetPropertyValue;

})(noflo.Component);

exports.getComponent = function() {
  return new SetPropertyValue;
};

});
require.register("noflo-noflo-objects/components/CallMethod.js", function(exports, require, module){
var CallMethod, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

CallMethod = (function(_super) {
  __extends(CallMethod, _super);

  CallMethod.prototype.description = "call a method on an object";

  CallMethod.prototype.icon = 'gear';

  function CallMethod() {
    this.method = null;
    this.args = [];
    this.inPorts = {
      "in": new noflo.Port('object'),
      method: new noflo.Port('string'),
      "arguments": new noflo.Port('all')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      error: new noflo.Port('string')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var msg;
        if (!_this.method) {
          return;
        }
        if (!data[_this.method]) {
          msg = "Method '" + _this.method + "' not available";
          if (_this.outPorts.error.isAttached()) {
            _this.outPorts.error.send(msg);
            _this.outPorts.error.disconnect();
            return;
          }
          throw new Error(msg);
        }
        _this.outPorts.out.send(data[_this.method].apply(data, _this.args));
        return _this.args = [];
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.method.on("data", (function(_this) {
      return function(data) {
        return _this.method = data;
      };
    })(this));
    this.inPorts["arguments"].on('connect', (function(_this) {
      return function() {
        return _this.args = [];
      };
    })(this));
    this.inPorts["arguments"].on('data', (function(_this) {
      return function(data) {
        return _this.args.push(data);
      };
    })(this));
  }

  return CallMethod;

})(noflo.Component);

exports.getComponent = function() {
  return new CallMethod;
};

});
require.register("noflo-noflo-packets/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of packets.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-packets/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-packets","description":"The best project ever.","version":"0.0.8","author":"Kenneth Kan <kenhkan@gmail.com>","repo":"kenhkan/packets","keywords":[],"dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/CountPackets.coffee","components/Unzip.coffee","components/Defaults.coffee","components/DoNotDisconnect.coffee","components/OnlyDisconnect.coffee","components/SplitPacket.coffee","components/Range.coffee","components/Flatten.coffee","components/Compact.coffee","components/Zip.coffee","components/SendWith.coffee","components/FilterPackets.coffee","components/FilterByValue.coffee","components/FilterByPosition.coffee","components/FilterPacket.coffee","components/UniquePacket.coffee","components/GroupByPacket.coffee","components/LastPacket.coffee","components/Counter.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"dropbox","components":{"CountPackets":"components/CountPackets.coffee","Unzip":"components/Unzip.coffee","Defaults":"components/Defaults.coffee","DoNotDisconnect":"components/DoNotDisconnect.coffee","OnlyDisconnect":"components/OnlyDisconnect.coffee","SplitPacket":"components/SplitPacket.coffee","Range":"components/Range.coffee","Flatten":"components/Flatten.coffee","Compact":"components/Compact.coffee","Zip":"components/Zip.coffee","SendWith":"components/SendWith.coffee","FilterPackets":"components/FilterPackets.coffee","FilterByValue":"components/FilterByValue.coffee","FilterByPosition":"components/FilterByPosition.coffee","FilterPacket":"components/FilterPacket.coffee","UniquePacket":"components/UniquePacket.coffee","GroupByPacket":"components/GroupByPacket.coffee","LastPacket":"components/LastPacket.coffee","Counter":"components/Counter.coffee"}}}');
});
require.register("noflo-noflo-packets/components/CountPackets.js", function(exports, require, module){
var CountPackets, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

CountPackets = (function(_super) {
  __extends(CountPackets, _super);

  CountPackets.prototype.description = "count number of data IPs";

  CountPackets.prototype.icon = 'sort-numeric-asc';

  function CountPackets() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      count: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        var count;
        _this.counts = [0];
        return count = _.last(_this.counts);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        _this.counts.push(0);
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var count;
        _this.counts[_this.counts.length - 1]++;
        count = _.last(_this.counts);
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        var count;
        count = _.last(_this.counts);
        _this.outPorts.count.send(count);
        _this.counts.pop();
        return _this.outPorts.out.endGroup(group);
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var count;
        count = _.last(_this.counts);
        _this.outPorts.count.send(count);
        _this.outPorts.count.disconnect();
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return CountPackets;

})(noflo.Component);

exports.getComponent = function() {
  return new CountPackets;
};

});
require.register("noflo-noflo-packets/components/Unzip.js", function(exports, require, module){
var Unzip, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require("underscore");

noflo = require("noflo");

Unzip = (function(_super) {
  __extends(Unzip, _super);

  Unzip.prototype.description = "Send packets whose position upon receipt is even to the EVEN port, otherwise the ODD port.";

  function Unzip() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      odd: new noflo.Port,
      even: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function(group) {
        return _this.count = 0;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var port;
        _this.count++;
        port = _this.count % 2 === 0 ? "even" : "odd";
        return _this.outPorts[port].send(data);
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.odd.disconnect();
        return _this.outPorts.even.disconnect();
      };
    })(this));
  }

  return Unzip;

})(noflo.Component);

exports.getComponent = function() {
  return new Unzip;
};

});
require.register("noflo-noflo-packets/components/Defaults.js", function(exports, require, module){
var Defaults, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Defaults = (function(_super) {
  __extends(Defaults, _super);

  Defaults.prototype.description = "if incoming is short of the length of the default packets, send the default packets.";

  function Defaults() {
    this.defaults = [];
    this.inPorts = {
      "in": new noflo.Port,
      "default": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["default"].on("connect", (function(_this) {
      return function() {
        return _this.defaults = [];
      };
    })(this));
    this.inPorts["default"].on("data", (function(_this) {
      return function(data) {
        return _this.defaults.push(data);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.counts = [0];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        _this.counts.push(0);
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var count;
        count = _.last(_this.counts);
        if (data == null) {
          data = _this.defaults[count];
        }
        _this.outPorts.out.send(data);
        return _this.counts[_this.counts.length - 1]++;
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        _this.padPackets(_.last(_this.counts));
        _this.counts.pop();
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.padPackets(_this.counts[0]);
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  Defaults.prototype.padPackets = function(count) {
    var _results;
    _results = [];
    while (count < this.defaults.length) {
      this.outPorts.out.send(this.defaults[count]);
      _results.push(count++);
    }
    return _results;
  };

  return Defaults;

})(noflo.Component);

exports.getComponent = function() {
  return new Defaults;
};

});
require.register("noflo-noflo-packets/components/DoNotDisconnect.js", function(exports, require, module){
var DoNotDisconnect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

DoNotDisconnect = (function(_super) {
  __extends(DoNotDisconnect, _super);

  DoNotDisconnect.prototype.description = "forwards everything but never disconnect";

  function DoNotDisconnect() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
  }

  return DoNotDisconnect;

})(noflo.Component);

exports.getComponent = function() {
  return new DoNotDisconnect;
};

});
require.register("noflo-noflo-packets/components/OnlyDisconnect.js", function(exports, require, module){
var OnlyDisconnect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

OnlyDisconnect = (function(_super) {
  __extends(OnlyDisconnect, _super);

  OnlyDisconnect.prototype.description = "the inverse of DoNotDisconnect";

  function OnlyDisconnect() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.connect();
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return OnlyDisconnect;

})(noflo.Component);

exports.getComponent = function() {
  return new OnlyDisconnect;
};

});
require.register("noflo-noflo-packets/components/SplitPacket.js", function(exports, require, module){
var SplitPacket, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

SplitPacket = (function(_super) {
  __extends(SplitPacket, _super);

  SplitPacket.prototype.description = "splits each incoming packet into its own connection";

  function SplitPacket() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var group, _i, _j, _len, _len1, _ref, _ref1;
        _this.outPorts.out.connect();
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.beginGroup(group);
        }
        _this.outPorts.out.send(data);
        _ref1 = _this.groups;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _this.outPorts.out.endGroup();
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
  }

  return SplitPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitPacket;
};

});
require.register("noflo-noflo-packets/components/Range.js", function(exports, require, module){
var Range, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Range = (function(_super) {
  __extends(Range, _super);

  Range.prototype.description = "only forward a specified number of packets in a connection";

  function Range() {
    this.start = -Infinity;
    this.end = +Infinity;
    this.length = +Infinity;
    this.inPorts = {
      "in": new noflo.Port,
      start: new noflo.Port,
      end: new noflo.Port,
      length: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.start.on("data", (function(_this) {
      return function(start) {
        return _this.start = parseInt(start);
      };
    })(this));
    this.inPorts.end.on("data", (function(_this) {
      return function(end) {
        return _this.end = parseInt(end);
      };
    })(this));
    this.inPorts.length.on("data", (function(_this) {
      return function(length) {
        return _this.length = parseInt(length);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.totalCount = 0;
        return _this.sentCount = 0;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        _this.totalCount++;
        if (_this.totalCount > _this.start && _this.totalCount < _this.end && _this.sentCount < _this.length) {
          _this.sentCount++;
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Range;

})(noflo.Component);

exports.getComponent = function() {
  return new Range;
};

});
require.register("noflo-noflo-packets/components/Flatten.js", function(exports, require, module){
var Flatten, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Flatten = (function(_super) {
  __extends(Flatten, _super);

  Flatten.prototype.description = "Flatten the IP structure but preserve all groups (i.e. all groups are at the top level)";

  function Flatten() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.groups = [];
        return _this.cache = [];
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        var loc;
        loc = _this.locate();
        loc[group] = [];
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var loc;
        loc = _this.locate();
        return loc.push(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var nodes, packets, _ref;
        _ref = _this.flatten(_this.cache), packets = _ref.packets, nodes = _ref.nodes;
        _this.flush(_.extend(packets, nodes));
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  Flatten.prototype.locate = function() {
    return _.reduce(this.groups, (function(loc, group) {
      return loc[group];
    }), this.cache);
  };

  Flatten.prototype.flatten = function(node) {
    var group, groups, nodes, packets, subnodes, _i, _len, _ref;
    groups = this.getNonArrayKeys(node);
    if (groups.length === 0) {
      return {
        packets: node,
        nodes: {}
      };
    } else {
      subnodes = {};
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        group = groups[_i];
        _ref = this.flatten(node[group]), packets = _ref.packets, nodes = _ref.nodes;
        delete node[group];
        subnodes[group] = packets;
        _.extend(subnodes, nodes);
      }
      return {
        packets: node,
        nodes: subnodes
      };
    }
  };

  Flatten.prototype.getNonArrayKeys = function(node) {
    return _.compact(_.filter(_.keys(node), function(key) {
      return isNaN(parseInt(key));
    }));
  };

  Flatten.prototype.flush = function(node) {
    var group, packet, _i, _j, _len, _len1, _ref, _results;
    for (_i = 0, _len = node.length; _i < _len; _i++) {
      packet = node[_i];
      this.outPorts.out.send(packet);
    }
    _ref = this.getNonArrayKeys(node);
    _results = [];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      group = _ref[_j];
      this.outPorts.out.beginGroup(group);
      this.flush(node[group]);
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  return Flatten;

})(noflo.Component);

exports.getComponent = function() {
  return new Flatten;
};

});
require.register("noflo-noflo-packets/components/Compact.js", function(exports, require, module){
var Compact, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Compact = (function(_super) {
  __extends(Compact, _super);

  Compact.prototype.description = "Remove null";

  function Compact() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (data == null) {
          return;
        }
        if (data.length === 0) {
          return;
        }
        if (_.isObject(data) && _.isEmpty(data)) {
          return;
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Compact;

})(noflo.Component);

exports.getComponent = function() {
  return new Compact;
};

});
require.register("noflo-noflo-packets/components/Zip.js", function(exports, require, module){
var Zip, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

Zip = (function(_super) {
  __extends(Zip, _super);

  Zip.prototype.description = "zip through multiple IPs and output a series of zipped IPs just like how _.zip() works in Underscore.js";

  function Zip() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function(group) {
        return _this.packets = [];
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_.isArray(data)) {
          return _this.packets.push(data);
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        if (_.isEmpty(_this.packets)) {
          _this.outPorts.out.send([]);
        } else {
          _this.outPorts.out.send(_.zip.apply(_, _this.packets));
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Zip;

})(noflo.Component);

exports.getComponent = function() {
  return new Zip;
};

});
require.register("noflo-noflo-packets/components/SendWith.js", function(exports, require, module){
var SendWith, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

SendWith = (function(_super) {
  __extends(SendWith, _super);

  SendWith.prototype.description = "Always send the specified packets with incoming packets.";

  function SendWith() {
    this["with"] = [];
    this.inPorts = {
      "in": new noflo.Port,
      "with": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["with"].on("connect", (function(_this) {
      return function() {
        return _this["with"] = [];
      };
    })(this));
    this.inPorts["with"].on("data", (function(_this) {
      return function(data) {
        return _this["with"].push(data);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var packet, _i, _len, _ref;
        _ref = _this["with"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          packet = _ref[_i];
          _this.outPorts.out.send(packet);
        }
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return SendWith;

})(noflo.Component);

exports.getComponent = function() {
  return new SendWith;
};

});
require.register("noflo-noflo-packets/components/FilterPackets.js", function(exports, require, module){
var FilterPackets, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

FilterPackets = (function(_super) {
  __extends(FilterPackets, _super);

  FilterPackets.prototype.description = "Filter packets matching some RegExp strings";

  function FilterPackets() {
    this.regexps = [];
    this.inPorts = {
      "in": new noflo.Port,
      regexp: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      missed: new noflo.Port,
      passthru: new noflo.Port
    };
    this.inPorts.regexp.on("connect", (function(_this) {
      return function() {
        return _this.regexps = [];
      };
    })(this));
    this.inPorts.regexp.on("data", (function(_this) {
      return function(regexp) {
        return _this.regexps.push(new RegExp(regexp));
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_.any(_this.regexps, (function(regexp) {
          return data.match(regexp);
        }))) {
          _this.outPorts.out.send(data);
        } else {
          _this.outPorts.missed.send(data);
        }
        if (_this.outPorts.passthru.isAttached()) {
          return _this.outPorts.passthru.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        _this.outPorts.missed.disconnect();
        if (_this.outPorts.passthru.isAttached()) {
          return _this.outPorts.passthru.disconnect();
        }
      };
    })(this));
  }

  return FilterPackets;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterPackets;
};

});
require.register("noflo-noflo-packets/components/FilterByValue.js", function(exports, require, module){
var FilterByValue, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

FilterByValue = (function(_super) {
  __extends(FilterByValue, _super);

  FilterByValue.prototype.description = "Filter packets based on their value";

  function FilterByValue() {
    this.filterValue = null;
    this.inPorts = {
      "in": new noflo.Port,
      filtervalue: new noflo.Port
    };
    this.outPorts = {
      lower: new noflo.Port,
      higher: new noflo.Port,
      equal: new noflo.Port
    };
    this.inPorts.filtervalue.on('data', (function(_this) {
      return function(data) {
        return _this.filterValue = data;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (data < _this.filterValue) {
          return _this.outPorts.lower.send(data);
        } else if (data > _this.filterValue) {
          return _this.outPorts.higher.send(data);
        } else if (data === _this.filterValue) {
          return _this.outPorts.equal.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.outPorts.lower.isConnected()) {
          _this.outPorts.lower.disconnect();
        }
        if (_this.outPorts.higher.isConnected()) {
          _this.outPorts.higher.disconnect();
        }
        if (_this.outPorts.equal.isConnected()) {
          return _this.outPorts.equal.disconnect();
        }
      };
    })(this));
  }

  return FilterByValue;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterByValue;
};

});
require.register("noflo-noflo-packets/components/FilterByPosition.js", function(exports, require, module){
var FilterByPosition, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

FilterByPosition = (function(_super) {
  __extends(FilterByPosition, _super);

  FilterByPosition.prototype.description = "Filter packets based on their positions";

  function FilterByPosition() {
    this.filters = [];
    this.inPorts = {
      "in": new noflo.Port,
      filter: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.filter.on("connect", (function(_this) {
      return function() {
        return _this.filters = [];
      };
    })(this));
    this.inPorts.filter.on("data", (function(_this) {
      return function(filter) {
        return _this.filters.push(filter);
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        return _this.count = 0;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_this.filters[_this.count]) {
          _this.outPorts.out.send(data);
        }
        return _this.count++;
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return FilterByPosition;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterByPosition;
};

});
require.register("noflo-noflo-packets/components/FilterPacket.js", function(exports, require, module){
var FilterPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FilterPacket = (function(_super) {
  __extends(FilterPacket, _super);

  function FilterPacket() {
    this.regexps = [];
    this.inPorts = {
      regexp: new noflo.ArrayPort(),
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port(),
      missed: new noflo.Port()
    };
    this.inPorts.regexp.on('data', (function(_this) {
      return function(data) {
        return _this.regexps.push(data);
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.regexps.length) {
          return _this.filterData(data);
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        return _this.outPorts.missed.disconnect();
      };
    })(this));
  }

  FilterPacket.prototype.filterData = function(data) {
    var expression, match, regexp, _i, _len, _ref;
    match = false;
    _ref = this.regexps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      expression = _ref[_i];
      regexp = new RegExp(expression);
      if (!regexp.exec(data)) {
        continue;
      }
      match = true;
    }
    if (!match) {
      if (this.outPorts.missed.isAttached()) {
        this.outPorts.missed.send(data);
      }
      return;
    }
    return this.outPorts.out.send(data);
  };

  return FilterPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new FilterPacket;
};

});
require.register("noflo-noflo-packets/components/UniquePacket.js", function(exports, require, module){
var UniquePacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

UniquePacket = (function(_super) {
  __extends(UniquePacket, _super);

  function UniquePacket() {
    this.seen = [];
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port('all'),
      clear: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('all'),
      duplicate: new noflo.Port('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var group, _i, _j, _len, _len1, _ref, _ref1, _results;
        if (!_this.unique(data)) {
          if (!_this.outPorts.duplicate.isAttached()) {
            return;
          }
          _this.outPorts.duplicate.send(data);
          return;
        }
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.beginGroup(group);
        }
        _this.outPorts.out.send(data);
        _ref1 = _this.groups;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _results.push(_this.outPorts.out.endGroup());
        }
        return _results;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        if (!_this.outPorts.duplicate.isAttached()) {
          return;
        }
        return _this.outPorts.duplicate.disconnect();
      };
    })(this));
    this.inPorts.clear.on('data', (function(_this) {
      return function() {
        _this.seen = [];
        return _this.groups = [];
      };
    })(this));
  }

  UniquePacket.prototype.unique = function(packet) {
    if (this.seen.indexOf(packet) !== -1) {
      return false;
    }
    this.seen.push(packet);
    return true;
  };

  return UniquePacket;

})(noflo.Component);

exports.getComponent = function() {
  return new UniquePacket;
};

});
require.register("noflo-noflo-packets/components/GroupByPacket.js", function(exports, require, module){
var GroupByPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GroupByPacket = (function(_super) {
  __extends(GroupByPacket, _super);

  function GroupByPacket() {
    this.packets = 0;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        _this.outPorts.out.beginGroup(group);
        return _this.packets = 0;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.outPorts.out.beginGroup(_this.packets);
        _this.outPorts.out.send(data);
        _this.outPorts.out.endGroup();
        return _this.packets++;
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.packets = 0;
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return GroupByPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new GroupByPacket;
};

});
require.register("noflo-noflo-packets/components/LastPacket.js", function(exports, require, module){
var LastPacket, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

LastPacket = (function(_super) {
  __extends(LastPacket, _super);

  function LastPacket() {
    this.packets = null;
    this.inPorts = {
      "in": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["in"].on('connect', (function(_this) {
      return function() {
        return _this.packets = [];
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.packets.push(data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.packets.length === 0) {
          return;
        }
        _this.outPorts.out.send(_this.packets.pop());
        _this.outPorts.out.disconnect();
        return _this.packets = null;
      };
    })(this));
  }

  return LastPacket;

})(noflo.Component);

exports.getComponent = function() {
  return new LastPacket;
};

});
require.register("noflo-noflo-packets/components/Counter.js", function(exports, require, module){
var Counter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Counter = (function(_super) {
  __extends(Counter, _super);

  Counter.prototype.description = 'The count component receives input on a single input port, and sends the number of data packets received to the output port when the input disconnects';

  Counter.prototype.icon = 'sort-numeric-asc';

  function Counter() {
    this.count = null;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      count: new noflo.Port,
      out: new noflo.Port
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.count === null) {
          _this.count = 0;
        }
        _this.count++;
        if (_this.outPorts.out.isAttached()) {
          return _this.outPorts.out.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        _this.outPorts.count.send(_this.count);
        _this.outPorts.count.disconnect();
        if (_this.outPorts.out.isAttached()) {
          _this.outPorts.out.disconnect();
        }
        return _this.count = null;
      };
    })(this));
  }

  return Counter;

})(noflo.Component);

exports.getComponent = function() {
  return new Counter;
};

});
require.register("noflo-noflo-physics/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-physics.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-physics/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-physics","description":"Physics components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-physics","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Spring.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"Spring":"components/Spring.coffee"}}}');
});
require.register("noflo-noflo-physics/components/Spring.js", function(exports, require, module){
var Spring, noflo, requestAnimFrame,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof process === 'object' && process.title === 'node') {
  noflo = require("noflo");
  requestAnimFrame = process.nextTick;
} else {
  noflo = require('noflo');
  requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
    return setTimeout(callback, 1);
  };
}

Spring = (function(_super) {
  __extends(Spring, _super);

  Spring.prototype.description = 'Animates a directional spring';

  function Spring() {
    this.step = __bind(this.step, this);
    this.massPosition = 0;
    this.anchorPosition = 0;
    this.stiffness = 120;
    this.mass = 10;
    this.friction = 3;
    this.speed = 0;
    this.inPorts = {
      anchor: new noflo.Port('number'),
      "in": new noflo.Port('number'),
      stiffness: new noflo.Port('int'),
      mass: new noflo.Port('int'),
      friction: new noflo.Port('int')
    };
    this.outPorts = {
      out: new noflo.Port('number')
    };
    this.inPorts.anchor.on('data', (function(_this) {
      return function(anchorPosition) {
        _this.anchorPosition = anchorPosition;
      };
    })(this));
    this.inPorts.stiffness.on('data', (function(_this) {
      return function(stiffness) {
        _this.stiffness = stiffness;
      };
    })(this));
    this.inPorts.mass.on('data', (function(_this) {
      return function(mass) {
        _this.mass = mass;
      };
    })(this));
    this.inPorts.friction.on('data', (function(_this) {
      return function(friction) {
        _this.friction = friction;
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(massPosition) {
        _this.massPosition = massPosition;
        return _this.step();
      };
    })(this));
  }

  Spring.prototype.step = function() {
    var acceleration, dampingForce, distance, previousPosition, springForce, totalForce;
    distance = this.massPosition - this.anchorPosition;
    dampingForce = -this.friction * this.speed;
    springForce = -this.stiffness * distance;
    totalForce = springForce + dampingForce;
    acceleration = totalForce / this.mass;
    this.speed += acceleration;
    previousPosition = this.massPosition;
    this.massPosition += this.speed / 100;
    if (Math.round(this.massPosition) !== Math.round(previousPosition)) {
      this.outPorts.out.send(Math.round(this.massPosition));
    }
    if (Math.round(this.massPosition) === this.anchorPosition && Math.abs(this.speed) < 0.2) {
      return this.outPorts.out.disconnect();
    } else {
      if (this.massPosition === 0) {
        return;
      }
      return requestAnimFrame(this.step);
    }
  };

  return Spring;

})(noflo.Component);

exports.getComponent = function() {
  return new Spring;
};

});
require.register("noflo-noflo-routers/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of routers.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-routers/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-routers","description":"Routing Packets in NoFlo","keywords":["noflo","routing"],"author":"Kenneth Kan <kenhkan@gmail.com>","version":"0.1.0","dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/ControlledSequence.coffee","components/KickRouter.coffee","components/PacketRouter.coffee","components/RegexpRouter.coffee","components/SplitInSequence.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"code-fork","components":{"ControlledSequence":"components/ControlledSequence.coffee","KickRouter":"components/KickRouter.coffee","PacketRouter":"components/PacketRouter.coffee","RegexpRouter":"components/RegexpRouter.coffee","SplitInSequence":"components/SplitInSequence.coffee"}},"repo":"https://raw.github.com/noflo/noflo-routers"}');
});
require.register("noflo-noflo-routers/components/ControlledSequence.js", function(exports, require, module){
var ControlledSequence, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ControlledSequence = (function(_super) {
  __extends(ControlledSequence, _super);

  function ControlledSequence() {
    this.current = 0;
    this.inPorts = {
      "in": new noflo.Port('all'),
      next: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group, _this.current);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(data, _this.current);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup(_this.current);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect(_this.current);
      };
    })(this));
    this.inPorts.next.on('data', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect(_this.current);
        if (_this.current < _this.outPorts.out.sockets.length - 1) {
          _this.current++;
          return;
        }
        return _this.current = 0;
      };
    })(this));
  }

  return ControlledSequence;

})(noflo.Component);

exports.getComponent = function() {
  return new ControlledSequence;
};

});
require.register("noflo-noflo-routers/components/KickRouter.js", function(exports, require, module){
var KickRouter, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

KickRouter = (function(_super) {
  __extends(KickRouter, _super);

  KickRouter.prototype.description = "Holds an IP and send it to a specified port or previous/next";

  function KickRouter() {
    this.sendToIndex = __bind(this.sendToIndex, this);
    this.data = null;
    this.current = 0;
    this.inPorts = {
      "in": new noflo.Port('all'),
      index: new noflo.Port('int'),
      prev: new noflo.Port('bang'),
      next: new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('all')
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.data = data;
      };
    })(this));
    this.inPorts.index.on('data', (function(_this) {
      return function(index) {
        return _this.sendToIndex(_this.data, index);
      };
    })(this));
    this.inPorts.prev.on('data', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect(_this.current);
        if (_this.current > 0) {
          _this.current--;
        } else {
          _this.current = _this.outPorts.out.sockets.length - 1;
        }
        return _this.sendToIndex(_this.data, _this.current);
      };
    })(this));
    this.inPorts.next.on('data', (function(_this) {
      return function() {
        _this.outPorts.out.disconnect(_this.current);
        if (_this.current < _this.outPorts.out.sockets.length - 1) {
          _this.current++;
        } else {
          _this.current = 0;
        }
        return _this.sendToIndex(_this.data, _this.current);
      };
    })(this));
  }

  KickRouter.prototype.sendToIndex = function(data, index) {
    if (this.outPorts.out.isAttached(index)) {
      this.current = index;
      return this.outPorts.out.send(data, index);
    }
  };

  return KickRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new KickRouter;
};

});
require.register("noflo-noflo-routers/components/PacketRouter.js", function(exports, require, module){
var PacketRouter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

PacketRouter = (function(_super) {
  __extends(PacketRouter, _super);

  PacketRouter.prototype.description = "Routes IPs based on position in an incoming IP stream";

  function PacketRouter() {
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.ArrayPort,
      missed: new noflo.Port
    };
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.count = 0;
        return _this.outPortCount = _this.outPorts.out.sockets.length;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (_this.count < _this.outPortCount) {
          _this.outPorts.out.send(data, _this.count++);
          return _this.outPorts.out.disconnect();
        } else if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        var i, _i, _ref, _ref1;
        if (_this.count < _this.outPortCount) {
          for (i = _i = _ref = _this.count, _ref1 = _this.outPortCount; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
            _this.outPorts.out.send(null, i);
            _this.outPorts.out.disconnect();
          }
        }
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.disconnect();
        }
      };
    })(this));
  }

  return PacketRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new PacketRouter;
};

});
require.register("noflo-noflo-routers/components/RegexpRouter.js", function(exports, require, module){
var RegexpRouter, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

_ = require("underscore");

RegexpRouter = (function(_super) {
  __extends(RegexpRouter, _super);

  RegexpRouter.prototype.description = "Route IPs based on RegExp (top-level only). The position of the RegExp determines which port to forward to.";

  function RegexpRouter() {
    this.routes = [];
    this.inPorts = {
      "in": new noflo.Port,
      route: new noflo.ArrayPort,
      reset: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.ArrayPort,
      missed: new noflo.Port,
      route: new noflo.Port
    };
    this.inPorts.reset.on("disconnect", (function(_this) {
      return function() {
        return _this.routes = [];
      };
    })(this));
    this.inPorts.route.on("data", (function(_this) {
      return function(regexp) {
        if (_.isString(regexp)) {
          return _this.routes.push(new RegExp(regexp));
        } else {
          throw new Error({
            message: "Route must be a string",
            source: regexp
          });
        }
      };
    })(this));
    this.inPorts["in"].on("connect", (function(_this) {
      return function() {
        _this.matchedRouteIndex = null;
        return _this.level = 0;
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        var i, index, route, _i, _len, _ref;
        index = _this.matchedRouteIndex;
        if (_this.level === 0) {
          _ref = _this.routes;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            route = _ref[i];
            if (group.match(route) != null) {
              _this.matchedRouteIndex = i;
              if (_this.outPorts.route.isAttached()) {
                _this.outPorts.route.send(group);
                _this.outPorts.route.disconnect();
              }
              break;
            }
          }
        } else if ((index != null) && _this.outPorts.out.isAttached(index)) {
          _this.outPorts.out.beginGroup(group, index);
        } else if (_this.outPorts.missed.isAttached()) {
          _this.outPorts.missed.beginGroup(group);
        }
        return _this.level++;
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if ((_this.matchedRouteIndex != null) && _this.outPorts.out.isAttached(_this.matchedRouteIndex)) {
          return _this.outPorts.out.send(data, _this.matchedRouteIndex);
        } else if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        _this.level--;
        if (_this.level === 0 && (_this.matchedRouteIndex != null)) {
          _this.matchedRouteIndex = null;
        }
        if ((_this.matchedRouteIndex != null) && _this.outPorts.out.isAttached(_this.matchedRouteIndex)) {
          return _this.outPorts.out.endGroup(_this.matchedRouteIndex);
        } else if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.endGroup();
        }
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.disconnect();
        }
      };
    })(this));
  }

  return RegexpRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new RegexpRouter;
};

});
require.register("noflo-noflo-routers/components/SplitInSequence.js", function(exports, require, module){
var SplitInSequence, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SplitInSequence = (function(_super) {
  __extends(SplitInSequence, _super);

  function SplitInSequence() {
    this.lastSent = null;
    this.inPorts = {
      "in": new noflo.Port
    };
    this.outPorts = {
      out: new noflo.ArrayPort
    };
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.sendToPort(_this.portId(), data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SplitInSequence.prototype.portId = function() {
    var next;
    if (this.lastSent === null) {
      return 0;
    }
    next = this.lastSent + 1;
    if (next > this.outPorts.out.sockets.length - 1) {
      return 0;
    }
    return next;
  };

  SplitInSequence.prototype.sendToPort = function(portId, data) {
    this.outPorts.out.send(data, portId);
    return this.lastSent = portId;
  };

  return SplitInSequence;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitInSequence;
};

});
require.register("noflo-noflo-strings/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("noflo-noflo-strings/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-strings","description":"String Utilities for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-strings","version":"0.0.1","keywords":[],"dependencies":{"noflo/noflo":"*","component/underscore":"*"},"scripts":["components/CompileString.coffee","components/Filter.coffee","components/SendString.coffee","components/SplitStr.coffee","components/StringTemplate.coffee","components/Replace.coffee","components/Jsonify.coffee","components/ParseJson.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"font","components":{"CompileString":"components/CompileString.coffee","Filter":"components/Filter.coffee","SendString":"components/SendString.coffee","SplitStr":"components/SplitStr.coffee","StringTemplate":"components/StringTemplate.coffee","Replace":"components/Replace.coffee","Jsonify":"components/Jsonify.coffee","ParseJson":"components/ParseJson.coffee"}}}');
});
require.register("noflo-noflo-strings/components/CompileString.js", function(exports, require, module){
var CompileString, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CompileString = (function(_super) {
  __extends(CompileString, _super);

  function CompileString() {
    this.delimiter = "\n";
    this.data = [];
    this.onGroupEnd = true;
    this.inPorts = {
      delimiter: new noflo.Port,
      "in": new noflo.ArrayPort,
      ongroup: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port
    };
    this.inPorts.delimiter.on('data', (function(_this) {
      return function(data) {
        return _this.delimiter = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.data.push(data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        if (_this.data.length && _this.onGroupEnd) {
          _this.outPorts.out.send(_this.data.join(_this.delimiter));
        }
        _this.outPorts.out.endGroup();
        return _this.data = [];
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        if (_this.data.length) {
          _this.outPorts.out.send(_this.data.join(_this.delimiter));
        }
        _this.data = [];
        return _this.outPorts.out.disconnect();
      };
    })(this));
    this.inPorts.ongroup.on("data", (function(_this) {
      return function(data) {
        if (typeof data === 'string') {
          if (data.toLowerCase() === 'false') {
            _this.onGroupEnd = false;
            return;
          }
          _this.onGroupEnd = true;
          return;
        }
        return _this.onGroupEnd = data;
      };
    })(this));
  }

  return CompileString;

})(noflo.Component);

exports.getComponent = function() {
  return new CompileString;
};

});
require.register("noflo-noflo-strings/components/Filter.js", function(exports, require, module){
var Filter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

Filter = (function(_super) {
  __extends(Filter, _super);

  Filter.prototype.description = "filters an IP which is a string using a regex";

  function Filter() {
    this.regex = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      pattern: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string'),
      missed: new noflo.Port('string')
    };
    this.inPorts.pattern.on("data", (function(_this) {
      return function(data) {
        return _this.regex = new RegExp(data);
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        if (typeof data !== 'string') {
          data = data.toString();
        }
        if ((_this.regex != null) && ((data != null ? typeof data.match === "function" ? data.match(_this.regex) : void 0 : void 0) != null)) {
          _this.outPorts.out.send(data);
          return;
        }
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.send(data);
        }
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        _this.outPorts.out.disconnect();
        if (_this.outPorts.missed.isAttached()) {
          return _this.outPorts.missed.disconnect();
        }
      };
    })(this));
  }

  return Filter;

})(noflo.Component);

exports.getComponent = function() {
  return new Filter;
};

});
require.register("noflo-noflo-strings/components/SendString.js", function(exports, require, module){
var SendString, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SendString = (function(_super) {
  __extends(SendString, _super);

  function SendString() {
    this.data = {
      string: null,
      group: []
    };
    this.groups = [];
    this.inPorts = {
      string: new noflo.Port('string'),
      "in": new noflo.Port('bang')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.string.on('data', (function(_this) {
      return function(data) {
        return _this.data.string = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        _this.data.group = _this.groups.slice(0);
        return _this.sendString(_this.data);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  SendString.prototype.sendString = function(data) {
    var group, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = data.group;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      group = _ref[_i];
      this.outPorts.out.beginGroup(group);
    }
    this.outPorts.out.send(data.string);
    _ref1 = data.group;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      group = _ref1[_j];
      _results.push(this.outPorts.out.endGroup());
    }
    return _results;
  };

  return SendString;

})(noflo.Component);

exports.getComponent = function() {
  return new SendString;
};

});
require.register("noflo-noflo-strings/components/SplitStr.js", function(exports, require, module){
var SplitStr, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SplitStr = (function(_super) {
  __extends(SplitStr, _super);

  SplitStr.prototype.description = ' The SplitStr component receives a string in the in port, splits it by string specified in the delimiter port, and send each part as a separate packet to the out port';

  function SplitStr() {
    this.delimiterString = "\n";
    this.strings = [];
    this.groups = [];
    this.inPorts = {
      "in": new noflo.Port(),
      delimiter: new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts.delimiter.on('data', (function(_this) {
      return function(data) {
        var first, last;
        first = data.substr(0, 1);
        last = data.substr(data.length - 1, 1);
        if (first === '/' && last === '/' && data.length > 1) {
          data = new RegExp(data.substr(1, data.length - 2));
        }
        return _this.delimiterString = data;
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.strings.push(data);
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function(data) {
        var group, _i, _j, _len, _len1, _ref, _ref1;
        if (_this.strings.length === 0) {
          return _this.outPorts.out.disconnect();
        }
        _ref = _this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          _this.outPorts.out.beginGroup(group);
        }
        _this.strings.join(_this.delimiterString).split(_this.delimiterString).forEach(function(line) {
          return _this.outPorts.out.send(line);
        });
        _ref1 = _this.groups;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          group = _ref1[_j];
          _this.outPorts.out.endGroup();
        }
        _this.outPorts.out.disconnect();
        _this.strings = [];
        return _this.groups = [];
      };
    })(this));
  }

  return SplitStr;

})(noflo.Component);

exports.getComponent = function() {
  return new SplitStr();
};

});
require.register("noflo-noflo-strings/components/StringTemplate.js", function(exports, require, module){
var StringTemplate, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

StringTemplate = (function(_super) {
  __extends(StringTemplate, _super);

  function StringTemplate() {
    this.template = null;
    this.inPorts = {
      template: new noflo.Port('string'),
      "in": new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.template.on('data', (function(_this) {
      return function(data) {
        return _this.template = _.template(data);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        return _this.outPorts.out.send(_this.template(data));
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return StringTemplate;

})(noflo.Component);

exports.getComponent = function() {
  return new StringTemplate;
};

});
require.register("noflo-noflo-strings/components/Replace.js", function(exports, require, module){
var Replace, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Replace = (function(_super) {
  __extends(Replace, _super);

  Replace.prototype.description = 'Given a fixed pattern and its replacement, replace all occurrences in the incoming template.';

  function Replace() {
    this.pattern = null;
    this.replacement = '';
    this.inPorts = {
      "in": new noflo.Port('string'),
      pattern: new noflo.Port('string'),
      replacement: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.pattern.on('data', (function(_this) {
      return function(data) {
        return _this.pattern = new RegExp(data, 'g');
      };
    })(this));
    this.inPorts.replacement.on('data', (function(_this) {
      return function(data) {
        return _this.replacement = data.replace('\\\\n', "\n");
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        var string;
        string = data;
        if (_this.pattern != null) {
          string = ("" + data).replace(_this.pattern, _this.replacement);
        }
        return _this.outPorts.out.send(string);
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Replace;

})(noflo.Component);

exports.getComponent = function() {
  return new Replace;
};

});
require.register("noflo-noflo-strings/components/Jsonify.js", function(exports, require, module){
var Jsonify, noflo, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

_ = require('underscore');

Jsonify = (function(_super) {
  __extends(Jsonify, _super);

  Jsonify.prototype.description = "JSONify all incoming, unless a raw flag is set to exclude data packets that are pure strings";

  function Jsonify() {
    this.raw = false;
    this.inPorts = {
      "in": new noflo.Port('object'),
      raw: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.raw.on('data', (function(_this) {
      return function(raw) {
        return _this.raw = String(raw) === 'true';
      };
    })(this));
    this.inPorts["in"].on('begingroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on('data', (function(_this) {
      return function(data) {
        if (_this.raw && _.isString(data)) {
          _this.outPorts.out.send(data);
          return;
        }
        return _this.outPorts.out.send(JSON.stringify(data));
      };
    })(this));
    this.inPorts["in"].on('endgroup', (function(_this) {
      return function(group) {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return Jsonify;

})(noflo.Component);

exports.getComponent = function() {
  return new Jsonify;
};

});
require.register("noflo-noflo-strings/components/ParseJson.js", function(exports, require, module){
var ParseJson, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require("noflo");

ParseJson = (function(_super) {
  __extends(ParseJson, _super);

  function ParseJson() {
    this["try"] = false;
    this.inPorts = {
      "in": new noflo.Port(),
      "try": new noflo.Port()
    };
    this.outPorts = {
      out: new noflo.Port()
    };
    this.inPorts["try"].on("data", (function(_this) {
      return function(data) {
        if (data === "true") {
          return _this["try"] = true;
        }
      };
    })(this));
    this.inPorts["in"].on("begingroup", (function(_this) {
      return function(group) {
        return _this.outPorts.out.beginGroup(group);
      };
    })(this));
    this.inPorts["in"].on("data", (function(_this) {
      return function(data) {
        var e;
        try {
          data = JSON.parse(data);
        } catch (_error) {
          e = _error;
          if (!_this["try"]) {
            data = JSON.parse(data);
          }
        }
        return _this.outPorts.out.send(data);
      };
    })(this));
    this.inPorts["in"].on("endgroup", (function(_this) {
      return function() {
        return _this.outPorts.out.endGroup();
      };
    })(this));
    this.inPorts["in"].on("disconnect", (function(_this) {
      return function() {
        return _this.outPorts.out.disconnect();
      };
    })(this));
  }

  return ParseJson;

})(noflo.Component);

exports.getComponent = function() {
  return new ParseJson;
};

});
require.register("noflo-noflo-websocket/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-websocket.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-websocket/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-websocket","description":"WebSocket components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-websocket","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Connect.coffee","components/SendMessage.coffee","components/ListenMessages.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"comments","components":{"Connect":"components/Connect.coffee","SendMessage":"components/SendMessage.coffee","ListenMessages":"components/ListenMessages.coffee"}}}');
});
require.register("noflo-noflo-websocket/components/Connect.js", function(exports, require, module){
var Connect, WsClient, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

if (noflo.isBrowser()) {
  WsClient = WebSocket;
} else {
  WsClient = require('websocket').client;
}

Connect = (function(_super) {
  __extends(Connect, _super);

  function Connect() {
    this.handleError = __bind(this.handleError, this);
    this.protocol = 'noflo';
    this.inPorts = {
      url: new noflo.Port('string'),
      protocol: new noflo.Port('string')
    };
    this.outPorts = {
      connection: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.url.on('data', (function(_this) {
      return function(data) {
        return _this.connect(data);
      };
    })(this));
    this.inPorts.protocol.on('data', (function(_this) {
      return function(protocol) {
        _this.protocol = protocol;
      };
    })(this));
  }

  Connect.prototype.connect = function(url) {
    var client;
    if (noflo.isBrowser()) {
      client = new WsClient(url, this.protocol);
      client.onerror = this.handleError;
      client.onopen = (function(_this) {
        return function() {
          return _this.outPorts.connection.send(client);
        };
      })(this);
      return;
    }
    client = new WsClient;
    client.on('connect', (function(_this) {
      return function(connection) {
        _this.outPorts.connection.send(connection);
        return connection.on('error', _this.handleError);
      };
    })(this));
    client.on('connectFailed', this.handleError);
    return client.connect(url, this.protocol);
  };

  Connect.prototype.handleError = function(err) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(err);
      this.outPorts.error.disconnect();
      return;
    }
    throw err;
  };

  return Connect;

})(noflo.Component);

exports.getComponent = function() {
  return new Connect;
};

});
require.register("noflo-noflo-websocket/components/SendMessage.js", function(exports, require, module){
var SendMessage, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

SendMessage = (function(_super) {
  __extends(SendMessage, _super);

  function SendMessage() {
    this.connection = null;
    this.buffer = [];
    this.inPorts = {
      connection: new noflo.Port('object'),
      string: new noflo.Port('string')
    };
    this.outPorts = {};
    this.inPorts.connection.on('data', (function(_this) {
      return function(connection) {
        _this.connection = connection;
        if (_this.buffer.length) {
          return _this.clearBuffer();
        }
      };
    })(this));
    this.inPorts.string.on('data', (function(_this) {
      return function(data) {
        if (_this.connection) {
          return _this.send(data);
        }
        return _this.buffer.push(data);
      };
    })(this));
  }

  SendMessage.prototype.send = function(message) {
    if (noflo.isBrowser()) {
      this.connection.send(message);
      return;
    }
    return this.connection.sendUTF(message);
  };

  SendMessage.prototype.clearBuffer = function() {
    var message, _i, _len, _ref;
    _ref = this.buffer;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      message = _ref[_i];
      this.send(message);
    }
    return this.buffer = [];
  };

  return SendMessage;

})(noflo.Component);

exports.getComponent = function() {
  return new SendMessage;
};

});
require.register("noflo-noflo-websocket/components/ListenMessages.js", function(exports, require, module){
var ListenMessages, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

ListenMessages = (function(_super) {
  __extends(ListenMessages, _super);

  function ListenMessages() {
    this.inPorts = {
      connection: new noflo.Port('object')
    };
    this.outPorts = {
      string: new noflo.Port('string'),
      binary: new noflo.Port('binary')
    };
    this.inPorts.connection.on('data', (function(_this) {
      return function(data) {
        return _this.subscribe(data);
      };
    })(this));
  }

  ListenMessages.prototype.subscribe = function(connection) {
    if (noflo.isBrowser()) {
      if (!this.outPorts.string.isAttached()) {
        return;
      }
      connection.addEventListener('message', (function(_this) {
        return function(message) {
          return _this.outPorts.string.send(message.data);
        };
      })(this), false);
      connection.addEventListener('close', (function(_this) {
        return function(message) {
          return _this.outPorts.string.disconnect();
        };
      })(this), false);
      return;
    }
    connection.on('message', (function(_this) {
      return function(message) {
        if (message.type === 'utf8' && _this.outPorts.string.isAttached()) {
          _this.outPorts.string.send(message.utf8Data);
          return;
        }
        if (message.type === 'binary' && _this.outPorts.binary.isAttached()) {
          _this.outPorts.binary.send(message.binaryData);
        }
      };
    })(this));
    return connection.on('close', (function(_this) {
      return function() {
        if (_this.outPorts.string.isAttached()) {
          _this.outPorts.string.disconnect();
        }
        if (_this.outPorts.binary.isAttached()) {
          return _this.outPorts.binary.disconnect();
        }
      };
    })(this));
  };

  return ListenMessages;

})(noflo.Component);

exports.getComponent = function() {
  return new ListenMessages;
};

});
require.register("noflo-noflo-indexeddb/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-indexeddb.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-indexeddb/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-indexeddb","description":"IndexedDB components for NoFlo","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-indexeddb","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Open.coffee","components/Close.coffee","components/DeleteDatabase.coffee","components/CreateStore.coffee","components/CreateIndex.coffee","components/DeleteStore.coffee","components/UpgradeRouter.coffee","components/BeginTransaction.coffee","components/AbortTransaction.coffee","components/GetStore.coffee","components/GetIndex.coffee","components/Query.coffee","components/QueryOnly.coffee","components/QueryFrom.coffee","components/QueryTo.coffee","components/Put.coffee","components/Get.coffee","components/Delete.coffee","index.js"],"json":["component.json"],"files":["vendor/IndexedDBShim.min.js"],"noflo":{"icon":"bitbucket","components":{"Open":"components/Open.coffee","Close":"components/Close.coffee","DeleteDatabase":"components/DeleteDatabase.coffee","CreateStore":"components/CreateStore.coffee","CreateIndex":"components/CreateIndex.coffee","DeleteStore":"components/DeleteStore.coffee","UpgradeRouter":"components/UpgradeRouter.coffee","BeginTransaction":"components/BeginTransaction.coffee","AbortTransaction":"components/AbortTransaction.coffee","GetStore":"components/GetStore.coffee","GetIndex":"components/GetIndex.coffee","Query":"components/Query.coffee","QueryOnly":"components/QueryOnly.coffee","QueryFrom":"components/QueryFrom.coffee","QueryTo":"components/QueryTo.coffee","Put":"components/Put.coffee","Get":"components/Get.coffee","Delete":"components/Delete.coffee"}}}');
});
require.register("noflo-noflo-indexeddb/components/Open.js", function(exports, require, module){
var Open, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Open = (function(_super) {
  __extends(Open, _super);

  function Open() {
    this.name = null;
    this.version = null;
    this.inPorts = {
      name: new noflo.Port('name'),
      version: new noflo.Port('number')
    };
    this.outPorts = {
      upgrade: new noflo.Port('object'),
      db: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.open();
      };
    })(this));
    this.inPorts.version.on('data', (function(_this) {
      return function(version) {
        _this.version = version;
        return _this.open();
      };
    })(this));
  }

  Open.prototype.open = function() {
    var req, version;
    if (!(this.name && this.version)) {
      return;
    }
    req = indexedDB.open(this.name, parseInt(this.version));
    this.name = null;
    version = this.version;
    this.version = null;
    req.onupgradeneeded = (function(_this) {
      return function(e) {
        _this.outPorts.upgrade.beginGroup(_this.name);
        _this.outPorts.upgrade.send({
          oldVersion: e.oldVersion,
          newVersion: version,
          db: e.target.result
        });
        _this.outPorts.upgrade.endGroup();
        return _this.outPorts.upgrade.disconnect();
      };
    })(this);
    req.onsuccess = (function(_this) {
      return function(e) {
        _this.outPorts.db.beginGroup(_this.name);
        _this.outPorts.db.send(e.target.result);
        _this.outPorts.db.endGroup();
        return _this.outPorts.db.disconnect();
      };
    })(this);
    return req.onerror = this.error.bind(this);
  };

  return Open;

})(noflo.Component);

exports.getComponent = function() {
  return new Open;
};

});
require.register("noflo-noflo-indexeddb/components/Close.js", function(exports, require, module){
var Close, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Close = (function(_super) {
  __extends(Close, _super);

  function Close() {
    this.inPorts = {
      db: new noflo.Port('object')
    };
    this.inPorts.db.on('data', function(db) {
      return db.close();
    });
  }

  return Close;

})(noflo.Component);

exports.getComponent = function() {
  return new Close;
};

});
require.register("noflo-noflo-indexeddb/components/DeleteDatabase.js", function(exports, require, module){
var DeleteDatabase, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DeleteDatabase = (function(_super) {
  __extends(DeleteDatabase, _super);

  function DeleteDatabase() {
    this.inPorts = {
      name: new noflo.Port('string')
    };
    this.outPorts = {
      deleted: new noflo.Port('bang'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        return _this.deleteDb(name);
      };
    })(this));
  }

  DeleteDatabase.prototype.deleteDb = function(name) {
    var req;
    req = indexedDB.deleteDatabase(name);
    req.onsuccess = (function(_this) {
      return function() {
        _this.outPorts.deleted.send(true);
        return _this.outPorts.deleted.disconnect();
      };
    })(this);
    return req.onerror = this.error;
  };

  return DeleteDatabase;

})(noflo.Component);

exports.getComponent = function() {
  return new DeleteDatabase;
};

});
require.register("noflo-noflo-indexeddb/components/CreateStore.js", function(exports, require, module){
var CreateStore, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateStore = (function(_super) {
  __extends(CreateStore, _super);

  function CreateStore() {
    this.name = null;
    this.db = null;
    this.keyPath = '';
    this.autoIncrement = false;
    this.inPorts = {
      name: new noflo.Port('name'),
      db: new noflo.Port('object'),
      keypath: new noflo.Port('name'),
      autoincrement: new noflo.Port('boolean')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      db: new noflo.Port('object'),
      error: new noflo.Port('error')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.create();
      };
    })(this));
    this.inPorts.db.on('data', (function(_this) {
      return function(db) {
        _this.db = db;
        return _this.create();
      };
    })(this));
    this.inPorts.keypath.on('data', (function(_this) {
      return function(keyPath) {
        _this.keyPath = keyPath;
      };
    })(this));
    this.inPorts.autoincrement.on('data', (function(_this) {
      return function(autoIncrement) {
        _this.autoIncrement = autoIncrement;
      };
    })(this));
  }

  CreateStore.prototype.create = function() {
    var store;
    if (!(this.name && this.db)) {
      return;
    }
    this.db.transaction.onerror = this.error;
    store = this.db.createObjectStore(this.name, {
      keyPath: this.keyPath,
      autoIncrement: this.autoIncrement
    });
    if (store && this.outPorts.store.isAttached()) {
      this.outPorts.store.beginGroup(this.name);
      this.outPorts.store.send(store);
      this.outPorts.store.endGroup();
      this.outPorts.store.disconnect();
    }
    this.db.transaction.onerror = null;
    if (this.outPorts.db.isAttached()) {
      this.outPorts.db.send(this.db);
      this.outPorts.db.disconnect();
    }
    this.db = null;
    return this.name = null;
  };

  return CreateStore;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateStore;
};

});
require.register("noflo-noflo-indexeddb/components/CreateIndex.js", function(exports, require, module){
var CreateIndex, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

CreateIndex = (function(_super) {
  __extends(CreateIndex, _super);

  function CreateIndex() {
    this.store = null;
    this.name = null;
    this.keyPath = null;
    this.unique = false;
    this.multiEntry = false;
    this.inPorts = {
      store: new noflo.Port('object'),
      name: new noflo.Port('string'),
      keypath: new noflo.Port('string'),
      unique: new noflo.Port('boolean'),
      multientry: new noflo.Port('boolean')
    };
    this.outPorts = {
      index: new noflo.Port('object'),
      store: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.create();
      };
    })(this));
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.create();
      };
    })(this));
    this.inPorts.keypath.on('data', (function(_this) {
      return function(keyPath) {
        _this.keyPath = keyPath;
        return _this.create();
      };
    })(this));
    this.inPorts.unique.on('data', (function(_this) {
      return function(unique) {
        _this.unique = unique;
      };
    })(this));
    this.inPorts.multientry.on('data', (function(_this) {
      return function(multiEntry) {
        _this.multiEntry = multiEntry;
      };
    })(this));
  }

  CreateIndex.prototype.create = function() {
    var index;
    if (!(this.store && this.name && this.keyPath)) {
      return;
    }
    this.store.onerror = this.error.bind(this);
    index = this.store.createIndex(this.name, this.keyPath, {
      unique: this.unique,
      multiEntry: this.multiEntry
    });
    this.store.onerror = null;
    this.name = null;
    this.keyPath = null;
    if (this.outPorts.index.isAttached()) {
      this.outPorts.index.beginGroup(index.name);
      this.outPorts.index.send(index);
      this.outPorts.index.endGroup();
      this.outPorts.index.disconnect();
    }
    if (this.outPorts.store.isAttached()) {
      this.outPorts.store.send(this.store);
      this.outPorts.store.disconnect();
    }
    return this.store = null;
  };

  return CreateIndex;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateIndex;
};

});
require.register("noflo-noflo-indexeddb/components/DeleteStore.js", function(exports, require, module){
var DeleteStore, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DeleteStore = (function(_super) {
  __extends(DeleteStore, _super);

  function DeleteStore() {
    this.name = null;
    this.db = null;
    this.inPorts = {
      name: new noflo.Port('name'),
      db: new noflo.Port('object')
    };
    this.outPorts = {
      db: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.deleteStore();
      };
    })(this));
    this.inPorts.db.on('data', (function(_this) {
      return function(db) {
        _this.db = db;
        return _this.deleteStore();
      };
    })(this));
  }

  DeleteStore.prototype.deleteStore = function() {
    if (!(this.name && this.db)) {
      return;
    }
    this.db.transaction.onerror = this.error;
    this.db.deleteObjectStore(this.name);
    this.db.transaction.onerror = null;
    if (this.outPorts.db.isAttached()) {
      this.outPorts.db.send(this.db);
      this.outPorts.db.disconnect();
    }
    this.db = null;
    return this.name = null;
  };

  return DeleteStore;

})(noflo.Component);

exports.getComponent = function() {
  return new DeleteStore;
};

});
require.register("noflo-noflo-indexeddb/components/UpgradeRouter.js", function(exports, require, module){
var UpgradeRouter, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

UpgradeRouter = (function(_super) {
  __extends(UpgradeRouter, _super);

  function UpgradeRouter() {
    this.groups = [];
    this.inPorts = {
      upgrade: new noflo.Port('object')
    };
    this.outPorts = {
      versions: new noflo.ArrayPort('object'),
      missed: new noflo.Port('object')
    };
    this.inPorts.upgrade.on('begingroup', (function(_this) {
      return function(group) {
        return _this.groups.push(group);
      };
    })(this));
    this.inPorts.upgrade.on('data', (function(_this) {
      return function(upgrade) {
        return _this.route(upgrade);
      };
    })(this));
    this.inPorts.upgrade.on('endgroup', (function(_this) {
      return function() {
        return _this.groups.pop();
      };
    })(this));
    this.inPorts.upgrade.on('disconnect', (function(_this) {
      return function() {
        return _this.groups = [];
      };
    })(this));
  }

  UpgradeRouter.prototype.route = function(upgrade) {
    var group, migration, upgraded, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    upgraded = false;
    migration = 0;
    while (migration < upgrade.newVersion) {
      if (migration < upgrade.oldVersion) {
        migration++;
        continue;
      }
      if (!this.outPorts.versions.isAttached(migration)) {
        migration++;
        continue;
      }
      _ref = this.groups;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        group = _ref[_i];
        this.outPorts.versions.beginGroup(group, migration);
      }
      this.outPorts.versions.send(upgrade.db, migration);
      _ref1 = this.groups;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        group = _ref1[_j];
        this.outPorts.versions.endGroup(migration);
      }
      this.outPorts.versions.disconnect(migration);
      upgraded = true;
      migration++;
    }
    if (upgraded) {
      return;
    }
    if (!this.outPorts.missed.isAttached()) {
      return;
    }
    _ref2 = this.groups;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      group = _ref2[_k];
      this.outPorts.missed.beginGroup(group);
    }
    this.outPorts.missed.send(upgrade.db);
    _ref3 = this.groups;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      group = _ref3[_l];
      this.outPorts.missed.endGroup();
    }
    return this.outPorts.missed.disconnect();
  };

  return UpgradeRouter;

})(noflo.Component);

exports.getComponent = function() {
  return new UpgradeRouter;
};

});
require.register("noflo-noflo-indexeddb/components/BeginTransaction.js", function(exports, require, module){
var BeginTransaction, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

BeginTransaction = (function(_super) {
  __extends(BeginTransaction, _super);

  function BeginTransaction() {
    this.stores = null;
    this.db = null;
    this.mode = 'readwrite';
    this.inPorts = {
      stores: new noflo.Port('string'),
      db: new noflo.Port('object'),
      mode: new noflo.Port('string')
    };
    this.outPorts = {
      transaction: new noflo.Port('object'),
      db: new noflo.Port('object'),
      error: new noflo.Port('error'),
      complete: new noflo.Port('bang')
    };
    this.inPorts.stores.on('data', (function(_this) {
      return function(data) {
        _this.stores = data.split(',');
        return _this.begin();
      };
    })(this));
    this.inPorts.db.on('data', (function(_this) {
      return function(db) {
        _this.db = db;
        return _this.begin();
      };
    })(this));
    this.inPorts.mode.on('data', (function(_this) {
      return function(mode) {
        _this.mode = mode;
      };
    })(this));
  }

  BeginTransaction.prototype.begin = function() {
    var transaction;
    if (!(this.db && this.stores)) {
      return;
    }
    transaction = this.db.transaction(this.stores, this.mode);
    transaction.oncomplete = (function(_this) {
      return function() {
        if (_this.outPorts.complete.isAttached()) {
          _this.outPorts.complete.send(true);
          _this.outPorts.complete.disconnect();
        }
        transaction.onerror = null;
        return transaction.oncomplete = null;
      };
    })(this);
    transaction.onerror = this.error.bind(this);
    this.outPorts.transaction.send(transaction);
    this.outPorts.transaction.disconnect();
    if (this.outPorts.db.isAttached()) {
      this.outPorts.db.send(this.db);
      this.outPorts.db.disconnect();
    }
    return this.stores = null;
  };

  return BeginTransaction;

})(noflo.Component);

exports.getComponent = function() {
  return new BeginTransaction;
};

});
require.register("noflo-noflo-indexeddb/components/AbortTransaction.js", function(exports, require, module){
var AbortTransaction, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

AbortTransaction = (function(_super) {
  __extends(AbortTransaction, _super);

  function AbortTransaction() {
    this.inPorts = {
      transaction: new noflo.Port('object')
    };
    this.outPorts = {
      error: new noflo.Port('object')
    };
    this.inPorts.transaction.on('data', (function(_this) {
      return function(transaction) {
        transaction.onerror = _this.error.bind(_this);
        return transaction.abort();
      };
    })(this));
  }

  return AbortTransaction;

})(noflo.Component);

exports.getComponent = function() {
  return new AbortTransaction;
};

});
require.register("noflo-noflo-indexeddb/components/GetStore.js", function(exports, require, module){
var GetStore, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetStore = (function(_super) {
  __extends(GetStore, _super);

  function GetStore() {
    this.transaction = null;
    this.name = null;
    this.inPorts = {
      name: new noflo.Port('string'),
      transaction: new noflo.Port('object')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      transaction: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.get();
      };
    })(this));
    this.inPorts.transaction.on('data', (function(_this) {
      return function(transaction) {
        _this.transaction = transaction;
        return _this.get();
      };
    })(this));
  }

  GetStore.prototype.get = function() {
    var store;
    if (!(this.name && this.transaction)) {
      return;
    }
    this.transaction.onerror = this.error;
    store = this.transaction.objectStore(this.name);
    this.transaction.onerror = null;
    this.outPorts.store.beginGroup(this.name);
    this.outPorts.store.send(store);
    this.outPorts.store.endGroup();
    this.outPorts.store.disconnect();
    if (this.outPorts.transaction.isAttached()) {
      this.outPorts.transaction.send(this.transaction);
      this.outPorts.transaction.disconnect();
    }
    this.transaction = null;
    return this.name = null;
  };

  return GetStore;

})(noflo.Component);

exports.getComponent = function() {
  return new GetStore;
};

});
require.register("noflo-noflo-indexeddb/components/GetIndex.js", function(exports, require, module){
var GetIndex, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetIndex = (function(_super) {
  __extends(GetIndex, _super);

  function GetIndex() {
    this.store = null;
    this.name = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      name: new noflo.Port('string')
    };
    this.outPorts = {
      index: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.get();
      };
    })(this));
    this.inPorts.name.on('data', (function(_this) {
      return function(name) {
        _this.name = name;
        return _this.get();
      };
    })(this));
  }

  GetIndex.prototype.get = function() {
    var index;
    if (!(this.store && this.name)) {
      return;
    }
    this.store.onerror = this.error;
    index = this.store.index(this.name);
    this.store.onerror = null;
    this.outPorts.index.beginGroup(this.name);
    this.outPorts.index.send(index);
    this.outPorts.index.endGroup();
    this.outPorts.index.disconnect();
    this.store = null;
    return this.name = null;
  };

  return GetIndex;

})(noflo.Component);

exports.getComponent = function() {
  return new GetIndex;
};

});
require.register("noflo-noflo-indexeddb/components/Query.js", function(exports, require, module){
var Query, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Query = (function(_super) {
  __extends(Query, _super);

  function Query() {
    this.step = __bind(this.step, this);
    this.store = null;
    this.range = null;
    this.all = false;
    this.inPorts = {
      store: new noflo.Port('object'),
      range: new noflo.Port('object'),
      all: new noflo.Port('bang')
    };
    this.outPorts = {
      item: new noflo.Port('all'),
      range: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.query();
      };
    })(this));
    this.inPorts.range.on('data', (function(_this) {
      return function(range) {
        _this.range = range;
        return _this.query();
      };
    })(this));
    this.inPorts.all.on('data', (function(_this) {
      return function() {
        _this.all = true;
        return _this.query();
      };
    })(this));
  }

  Query.prototype.query = function() {
    var req;
    if (!this.store) {
      return;
    }
    if (this.all) {
      req = this.store.openCursor();
      this.store = null;
      this.all = false;
      req.onsuccess = this.step;
      req.onerror = this.error;
      return;
    }
    if (this.range) {
      req = this.store.openCursor(this.range);
      this.store = null;
      if (this.outPorts.range.isAttached()) {
        this.outPorts.range.send(this.range);
        this.outPorts.range.disconnect();
      }
      this.range = null;
      req.onsuccess = this.step;
      return req.onerror = this.error;
    }
  };

  Query.prototype.step = function(e) {
    var cursor;
    cursor = e.target.result;
    if (!cursor) {
      this.outPorts.item.disconnect();
      return;
    }
    this.outPorts.item.beginGroup(cursor.key);
    this.outPorts.item.send(cursor.value);
    this.outPorts.item.endGroup();
    return cursor["continue"]();
  };

  return Query;

})(noflo.Component);

exports.getComponent = function() {
  return new Query;
};

});
require.register("noflo-noflo-indexeddb/components/QueryOnly.js", function(exports, require, module){
var QueryOnly, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

QueryOnly = (function(_super) {
  __extends(QueryOnly, _super);

  function QueryOnly() {
    this.inPorts = {
      value: new noflo.Port('all')
    };
    this.outPorts = {
      range: new noflo.Port('object')
    };
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.outPorts.range.send(IDBKeyRange.only(value));
        return _this.outPorts.range.disconnect();
      };
    })(this));
  }

  return QueryOnly;

})(noflo.Component);

exports.getComponent = function() {
  return new QueryOnly;
};

});
require.register("noflo-noflo-indexeddb/components/QueryFrom.js", function(exports, require, module){
var QueryFrom, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

QueryFrom = (function(_super) {
  __extends(QueryFrom, _super);

  function QueryFrom() {
    this.including = false;
    this.inPorts = {
      value: new noflo.Port('all'),
      including: new noflo.Port('boolean')
    };
    this.outPorts = {
      range: new noflo.Port('object')
    };
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.outPorts.range.send(IDBKeyRange.lowerBound(value, _this.including));
        return _this.outPorts.range.disconnect();
      };
    })(this));
    this.inPorts.including.on('data', (function(_this) {
      return function(including) {
        _this.including = including;
      };
    })(this));
  }

  return QueryFrom;

})(noflo.Component);

exports.getComponent = function() {
  return new QueryFrom;
};

});
require.register("noflo-noflo-indexeddb/components/QueryTo.js", function(exports, require, module){
var QueryTo, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

QueryTo = (function(_super) {
  __extends(QueryTo, _super);

  function QueryTo() {
    this.including = false;
    this.inPorts = {
      value: new noflo.Port('all'),
      including: new noflo.Port('boolean')
    };
    this.outPorts = {
      range: new noflo.Port('object')
    };
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.outPorts.range.send(IDBKeyRange.upperBound(value, _this.including));
        return _this.outPorts.range.disconnect();
      };
    })(this));
    this.inPorts.including.on('data', (function(_this) {
      return function(including) {
        _this.including = including;
      };
    })(this));
  }

  return QueryTo;

})(noflo.Component);

exports.getComponent = function() {
  return new QueryTo;
};

});
require.register("noflo-noflo-indexeddb/components/Put.js", function(exports, require, module){
var Put, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Put = (function(_super) {
  __extends(Put, _super);

  function Put() {
    this.store = null;
    this.value = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      value: new noflo.Port('all')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      key: new noflo.Port('all'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.put();
      };
    })(this));
    this.inPorts.value.on('data', (function(_this) {
      return function(value) {
        _this.value = value;
        return _this.put();
      };
    })(this));
  }

  Put.prototype.put = function() {
    var req;
    if (!(this.store && this.value)) {
      return;
    }
    req = this.store.put(this.value);
    this.value = null;
    if (this.outPorts.store.isAttached()) {
      this.outPorts.store.send(this.store);
      this.outPorts.store.disconnect();
    }
    this.store = null;
    req.onsuccess = (function(_this) {
      return function(e) {
        if (_this.outPorts.key.isAttached()) {
          _this.outPorts.key.send(e.target.result);
          return _this.outPorts.key.disconnect();
        }
      };
    })(this);
    return req.onerror = this.error.bind(this);
  };

  return Put;

})(noflo.Component);

exports.getComponent = function() {
  return new Put;
};

});
require.register("noflo-noflo-indexeddb/components/Get.js", function(exports, require, module){
var Get, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Get = (function(_super) {
  __extends(Get, _super);

  function Get() {
    this.store = null;
    this.key = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      item: new noflo.Port('all'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.get();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.get();
      };
    })(this));
  }

  Get.prototype.get = function() {
    var req;
    if (!(this.store && this.key)) {
      return;
    }
    req = this.store.get(this.key);
    if (this.outPorts.store.isAttached()) {
      this.outPorts.store.send(this.store);
      this.outPorts.store.disconnect();
    }
    this.store = null;
    req.onsuccess = (function(_this) {
      return function(e) {
        _this.outPorts.item.beginGroup(_this.key);
        _this.outPorts.item.send(e.target.result);
        _this.outPorts.item.endGroup();
        _this.outPorts.item.disconnect();
        return _this.key = null;
      };
    })(this);
    return req.onerror = this.error.bind(this);
  };

  return Get;

})(noflo.Component);

exports.getComponent = function() {
  return new Get;
};

});
require.register("noflo-noflo-indexeddb/components/Delete.js", function(exports, require, module){
var Delete, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Delete = (function(_super) {
  __extends(Delete, _super);

  function Delete() {
    this.store = null;
    this.key = null;
    this.inPorts = {
      store: new noflo.Port('object'),
      key: new noflo.Port('string')
    };
    this.outPorts = {
      store: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.store.on('data', (function(_this) {
      return function(store) {
        _this.store = store;
        return _this.get();
      };
    })(this));
    this.inPorts.key.on('data', (function(_this) {
      return function(key) {
        _this.key = key;
        return _this.get();
      };
    })(this));
  }

  Delete.prototype.get = function() {
    var req;
    if (!(this.store && this.key)) {
      return;
    }
    req = this.store["delete"](this.key);
    req.onsuccess = (function(_this) {
      return function(e) {
        if (_this.outPorts.store.isAttached()) {
          _this.outPorts.store.send(_this.store);
          _this.outPorts.store.disconnect();
        }
        _this.key = null;
        return _this.store = null;
      };
    })(this);
    return req.onerror = this.error;
  };

  return Delete;

})(noflo.Component);

exports.getComponent = function() {
  return new Delete;
};

});
require.register("component-reduce/index.js", function(exports, require, module){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
});
require.register("visionmedia-superagent/lib/client.js", function(exports, require, module){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? this
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

function getXHR() {
  if (root.XMLHttpRequest
    && ('file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
}

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  this.text = this.xhr.responseText;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status || 1223 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var path = req.path;

  var msg = 'cannot ' + method + ' ' + path + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.path = path;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var res = new Response(self);
    if ('HEAD' == method) res.text = null;
    self.callback(null, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  if (2 == fn.length) return fn(err, res);
  if (err) return this.emit('error', err);
  fn(res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;
    if (0 == xhr.status) {
      if (self.aborted) return self.timeoutError();
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  if (xhr.upload) {
    xhr.upload.onprogress = function(e){
      e.percent = e.loaded / e.total * 100;
      self.emit('progress', e);
    };
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

});
require.register("bergie-octo/octo.js", function(exports, require, module){
/*!
 * octo.js
 * Copyright (c) 2012 Justin Palmer <justin@labratrevenge.com>
 * MIT Licensed
 */

(function() {

  if(typeof superagent === 'undefined' && require) {
    superagent = require('superagent');
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      btoa = require('btoa');
    }
  }

  var octo = {}

  // The main entry point for interacting with the GitHub API v3.
  //
  //      var gh = octo.api()
  //      gh.get('/events').on('success', function(events) {
  //        console.log(events);
  //      })
  //
  octo.api = function() {
    var host  = 'https://api.github.com',
        agent = superagent,
        limit,
        remaining,
        username,
        password,
        token

    function api() {}

    function pager(method, path, params) {
      var page    = 1,
          perpage = 30,
          hasnext = false,
          hasprev = false,
          headers = {},
          callbacks = {}

      var request = function() {
        var req = superagent[method](api.host() + path)

        var complete = function(res) {
          limit = ~~res.header['x-ratelimit-limit']
          remaining = ~~res.header['x-ratelimit-remaining']

          var link = res.header['link']
          hasnext = (/rel=\"next\"/i).test(link)
          hasprev = (/rel=\"next\"/).test(link)

          pager.trigger('end', res)
          if(res.ok)    pager.trigger('success', res)
          if(res.error) pager.trigger('error', res)
        }

        if(token) req.set('Authorization', 'token ' + token)

        if(!token && username && password)
          req.set('Authorization', 'Basic ' + btoa(username + ':' + password))

        req
          .set(headers)
          .query({page: page, per_page: perpage})
          .send(params)
          .end(complete)
      }

      // ### Paging
      // Each subsequent request for additional pages can easily share the same callbacks and properties.
      //
      //      var events = api.get('/events').on('end', function(response) {
      //        console.log(response.body);
      //        events.next()
      //        console.log(events.page());
      //      })
      //
      //      events()
      //
      function pager() { request() }

      // Sets or gets the current page
      //
      // Returns the pager
      pager.page = function(v) {
        if(!arguments.length) return page
        page = v

        return pager
      }

      // Sets or gets the items returned per page
      //
      // Returns the pager
      pager.perpage = function(v) {
        if(!arguments.length) return perpage
        perpage = v

        return pager
      }

      // Increments the page number by one and fires a requests for the next page
      //
      // Returns the pager
      pager.next = function() {
        page += 1
        request()

        return pager
      }

      // Decrements the page number by one and fires a request for the previous page
      //
      // Returns the pager
      pager.prev = function() {
        page -= 1
        request()

        return pager
      }

      // Determines if the server is reporting a next page of results
      pager.hasnext = function() {
        return hasnext;
      }

      // Determines if the server is reporting a previous page of results
      pager.hasprev = function() {
        return hasprev;
      }

      // Registers a callback for an event
      //
      //  Supported events:
      //
      // * `success` - Request was successful
      // * `error` - Request returned an error
      // * `end` - Request is complete
      //
      // Returns a pager
      pager.on = function(event, callback) {
        if (typeof callbacks[event] == 'undefined')
          callbacks[event] = []

        callbacks[event].push(callback)

        return pager
      }

      // Unregisters a previously registered callback
      pager.off = function(event, callback) {
        if (callbacks[event] instanceof Array) {
          var cbacks = callbacks[event], i = 0
          for (i; i < cbacks.length; i++) {
            if (cbacks[i] === callback) {
              cbacks.splice(i, 1)
              break
            }
          }
        }

        return pager
      }

      // Triggers a custom event
      pager.trigger = function(event, data) {
        if (callbacks[event] instanceof Array) {
          callbacks[event].forEach(function(callback) {
            callback.call(pager, data)
          })
        }

        return pager
      }

      // Sets a request header
      pager.set = function(key, val) {
        headers[key] = val
        return pager
      }

      return pager
    }

    // Sets or gets the GitHub API host
    // Uses https://api.github.com by default
    //
    //      var gh = octo.api().host('https://api.github.com')
    //
    // Returns the api
    api.host = function(val) {
      if(!arguments.length) return host
      host = val
      return api
    }

    // Initializes a GET request to GitHub API v3
    // Returns a pager
    api.get = function(path, params) {
      return new pager('get', path)
    }

    // Initializes a POST request to GitHub API v3
    // Returns a pager
    api.post = function(path, params) {
      return new pager('post', path, params)
    }

    // Initializes a PATCH request to GitHub API v3
    // Returns a pager
    api.patch = function(path, params) {
      return new pager('patch', path, params)
    }

    // Initializes a PUT request to GitHub API v3
    // Returns a pager
    api.put = function(path, params) {
      return new pager('put', path, params)
    }

    // Initializes a DELETE request to GitHub API v3
    // Returns a pager
    api.delete = function(path, params) {
      return new pager('delete', path, params)
    }

    // Returns the API rate limit as reported by GitHub
    api.limit = function() {
      return limit
    }

    // Returns the number of requests that can be made before the `limit` is reached
    api.remaining = function() {
      return remaining;
    }

    // Sets or gets the Basic Auth username
    // Returns the api
    api.username = function(v) {
      if(!arguments.length) return username;
      username = v

      return api
    }

    // Sets or gets the Basic Auth password
    // Returns the api
    api.password = function(v) {
      if(!arguments.length) return password;
      password = v

      return api
    }

    // Sets or gets an OAuth two token.  You can temporarily use Basic Auth to create a
    // GitHub Authorization which will grant you an OAuth token.  You can use this token in
    // your scripts
    // Returns the api
    api.token = function(v) {
      if(!arguments.length) return token;
      token = v

      return api
    }

    return api
  }

  if("undefined" != typeof exports)
    module.exports = octo
  else
    window.octo = octo

})()

});
require.register("noflo-noflo-github/index.js", function(exports, require, module){

});
require.register("noflo-noflo-github/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-github","description":"GitHub service components for the NoFlo flow-based programming environment","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-github","dependencies":{"noflo/noflo":"*","bergie/octo":"*"},"scripts":["index.js","components/CreateRepository.coffee","components/CreateOrgRepository.coffee","components/GetRepository.coffee","components/GetContents.coffee","components/GetCurrentUser.coffee","components/GetUser.coffee","components/GetStargazers.coffee","components/SetContents.coffee"],"json":["component.json"],"noflo":{"icon":"github","components":{"CreateRepository":"components/CreateRepository.coffee","CreateOrgRepository":"components/CreateOrgRepository.coffee","GetRepository":"components/GetRepository.coffee","GetContents":"components/GetContents.coffee","GetCurrentUser":"components/GetCurrentUser.coffee","GetUser":"components/GetUser.coffee","GetStargazers":"components/GetStargazers.coffee","SetContents":"components/SetContents.coffee"}}}');
});
require.register("noflo-noflo-github/components/CreateRepository.js", function(exports, require, module){
var CreateRepository, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

CreateRepository = (function(_super) {
  __extends(CreateRepository, _super);

  function CreateRepository() {
    this.token = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      token: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('string')
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    CreateRepository.__super__.constructor.call(this);
  }

  CreateRepository.prototype.doAsync = function(repo, callback) {
    var api, request;
    api = octo.api();
    if (!this.token) {
      callback(new Error('token required'));
      return;
    }
    api.token(this.token);
    request = api.post('/user/repos', {
      name: repo
    });
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(repo);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return CreateRepository;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new CreateRepository;
};

});
require.register("noflo-noflo-github/components/CreateOrgRepository.js", function(exports, require, module){
var CreateOrgRepository, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

CreateOrgRepository = (function(_super) {
  __extends(CreateOrgRepository, _super);

  function CreateOrgRepository() {
    this.token = null;
    this.organization = null;
    this.inPorts = {
      "in": new noflo.Port,
      org: new noflo.Port,
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    this.inPorts.org.on('data', (function(_this) {
      return function(data) {
        return _this.organization = data;
      };
    })(this));
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    CreateOrgRepository.__super__.constructor.call(this);
  }

  CreateOrgRepository.prototype.doAsync = function(repo, callback) {
    var api, request;
    api = octo.api();
    if (!this.organization) {
      callback(new Error('organization name required'));
      return;
    }
    if (!this.token) {
      callback(new Error('token required'));
      return;
    }
    api.token(this.token);
    request = api.post("/orgs/" + this.organization + "/repos", {
      name: repo
    });
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(repo);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return CreateOrgRepository;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new CreateOrgRepository;
};

});
require.register("noflo-noflo-github/components/GetRepository.js", function(exports, require, module){
var GetRepository, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetRepository = (function(_super) {
  __extends(GetRepository, _super);

  GetRepository.prototype.description = 'Get information about a repository';

  function GetRepository() {
    this.token = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      token: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetRepository.__super__.constructor.call(this);
  }

  GetRepository.prototype.doAsync = function(repo, callback) {
    var api, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    request = api.get("/repos/" + repo);
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(repo);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetRepository;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetRepository;
};

});
require.register("noflo-noflo-github/components/GetContents.js", function(exports, require, module){
var GetContents, atob, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

if (!noflo.isBrowser()) {
  atob = require('atob');
} else {
  atob = window.atob;
}

GetContents = (function(_super) {
  __extends(GetContents, _super);

  GetContents.prototype.description = 'Get contents of a file or a directory';

  function GetContents() {
    this.token = null;
    this.repo = null;
    this.sendRepo = true;
    this.inPorts = {
      repository: new noflo.Port('string'),
      path: new noflo.Port('string'),
      token: new noflo.Port('string'),
      sendrepo: new noflo.Port('boolean')
    };
    this.outPorts = {
      out: new noflo.Port('string'),
      files: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.repository.on('data', (function(_this) {
      return function(data) {
        return _this.repo = data;
      };
    })(this));
    this.inPorts.sendrepo.on('data', (function(_this) {
      return function(sendRepo) {
        _this.sendRepo = sendRepo;
      };
    })(this));
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetContents.__super__.constructor.call(this, 'path');
  }

  GetContents.prototype.doAsync = function(path, callback) {
    var api, repo, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    if (!this.repo) {
      callback(new Error('repository name required'));
    }
    repo = this.repo;
    request = api.get("/repos/" + repo + "/contents/" + path);
    request.on('success', (function(_this) {
      return function(res) {
        var file, _i, _len, _ref;
        if (!res.body.content) {
          if (toString.call(res.body) !== '[object Array]') {
            callback(new Error('content not found'));
            return;
          }
          if (!_this.outPorts.files.isAttached()) {
            callback(new Error('content not found'));
            return;
          }
          if (_this.sendRepo) {
            _this.outPorts.files.beginGroup(repo);
          }
          _ref = res.body;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            _this.outPorts.files.send(file);
          }
          if (_this.sendRepo) {
            _this.outPorts.files.endGroup();
          }
          _this.outPorts.files.disconnect();
          callback();
          return;
        }
        if (_this.sendRepo) {
          _this.outPorts.out.beginGroup(repo);
        }
        _this.outPorts.out.beginGroup(path);
        _this.outPorts.out.send(atob(res.body.content.replace(/\s/g, '')));
        _this.outPorts.out.endGroup();
        if (_this.sendRepo) {
          _this.outPorts.out.endGroup();
        }
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetContents;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetContents;
};

});
require.register("noflo-noflo-github/components/GetCurrentUser.js", function(exports, require, module){
var GetCurrentUser, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetCurrentUser = (function(_super) {
  __extends(GetCurrentUser, _super);

  function GetCurrentUser() {
    this.token = null;
    this.inPorts = {
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    GetCurrentUser.__super__.constructor.call(this, 'token');
  }

  GetCurrentUser.prototype.doAsync = function(token, callback) {
    var api, request;
    api = octo.api();
    api.token(token);
    request = api.get("/user");
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetCurrentUser;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetCurrentUser;
};

});
require.register("noflo-noflo-github/components/GetUser.js", function(exports, require, module){
var GetUser, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetUser = (function(_super) {
  __extends(GetUser, _super);

  function GetUser() {
    this.token = null;
    this.inPorts = {
      user: new noflo.Port,
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetUser.__super__.constructor.call(this, 'user');
  }

  GetUser.prototype.doAsync = function(user, callback) {
    var api, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    request = api.get("/users/" + user);
    request.on('success', (function(_this) {
      return function(res) {
        _this.outPorts.out.beginGroup(user);
        _this.outPorts.out.send(res.body);
        _this.outPorts.out.endGroup();
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        _this.outPorts.out.disconnect();
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetUser;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetUser;
};

});
require.register("noflo-noflo-github/components/GetStargazers.js", function(exports, require, module){
var GetStargazers, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

GetStargazers = (function(_super) {
  __extends(GetStargazers, _super);

  function GetStargazers() {
    this.token = null;
    this.inPorts = {
      repository: new noflo.Port,
      token: new noflo.Port
    };
    this.outPorts = {
      out: new noflo.Port,
      error: new noflo.Port
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(data) {
        return _this.token = data;
      };
    })(this));
    GetStargazers.__super__.constructor.call(this, 'repository');
  }

  GetStargazers.prototype.doAsync = function(repository, callback) {
    var api, request;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    request = api.get("/repos/" + repository + "/stargazers");
    request.on('success', (function(_this) {
      return function(res) {
        var user, _i, _len, _ref;
        _this.outPorts.out.beginGroup(repository);
        _ref = res.body;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          user = _ref[_i];
          _this.outPorts.out.send(user);
        }
        _this.outPorts.out.endGroup();
        if (request.hasnext()) {
          return request.next();
        }
        _this.outPorts.out.disconnect();
        return callback();
      };
    })(this));
    request.on('error', (function(_this) {
      return function(err) {
        return callback(err.body);
      };
    })(this));
    this.outPorts.out.connect();
    return request();
  };

  return GetStargazers;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new GetStargazers;
};

});
require.register("noflo-noflo-github/components/SetContents.js", function(exports, require, module){
var SetContents, btoa, noflo, octo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

octo = require('octo');

if (!noflo.isBrowser()) {
  btoa = require('btoa');
} else {
  btoa = window.btoa;
}

SetContents = (function(_super) {
  __extends(SetContents, _super);

  SetContents.prototype.description = 'Create or update a file in the repository';

  function SetContents() {
    this.token = null;
    this.message = null;
    this.repo = null;
    this.path = null;
    this.inPorts = {
      "in": new noflo.Port('string'),
      token: new noflo.Port('string'),
      message: new noflo.Port('string'),
      repository: new noflo.Port('string'),
      path: new noflo.Port('string')
    };
    this.outPorts = {
      out: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.token.on('data', (function(_this) {
      return function(token) {
        _this.token = token;
      };
    })(this));
    this.inPorts.message.on('data', (function(_this) {
      return function(message) {
        _this.message = message;
      };
    })(this));
    this.inPorts.repository.on('data', (function(_this) {
      return function(repo) {
        _this.repo = repo;
      };
    })(this));
    this.inPorts.path.on('data', (function(_this) {
      return function(path) {
        _this.path = path;
      };
    })(this));
    SetContents.__super__.constructor.call(this, 'in');
  }

  SetContents.prototype.doAsync = function(contents, callback) {
    var api, message, path, repo, shaReq;
    if (!this.repo) {
      callback(new Error('repository name required'));
    }
    if (!this.path) {
      callback(new Error('file path required'));
    }
    if (!this.message) {
      this.message = '';
    }
    repo = this.repo;
    path = this.path;
    message = this.message;
    api = octo.api();
    if (this.token) {
      api.token(this.token);
    }
    shaReq = api.get("/repos/" + repo + "/contents/" + path);
    shaReq.on('success', (function(_this) {
      return function(shaRes) {
        var updateReq;
        updateReq = api.put("/repos/" + repo + "/contents/" + path, {
          path: path,
          message: message,
          content: btoa(contents),
          sha: shaRes.body.sha
        });
        updateReq.on('success', function(updateRes) {
          _this.outPorts.out.beginGroup(path);
          _this.outPorts.out.send(updateRes.sha);
          _this.outPorts.out.endGroup();
          _this.outPorts.out.disconnect();
          return callback();
        });
        updateReq.on('error', function(error) {
          _this.outPorts.out.disconnect();
          return callback(err.body);
        });
        return updateReq();
      };
    })(this));
    shaReq.on('error', (function(_this) {
      return function() {
        var createReq;
        createReq = api.put("/repos/" + repo + "/contents/" + path, {
          path: path,
          message: message,
          content: btoa(contents)
        });
        createReq.on('success', function(createRes) {
          _this.outPorts.out.beginGroup(path);
          _this.outPorts.out.send(createRes.sha);
          _this.outPorts.out.endGroup();
          _this.outPorts.out.disconnect();
          return callback();
        });
        createReq.on('error', function(error) {
          _this.outPorts.out.disconnect();
          return callback(err.body);
        });
        return createReq();
      };
    })(this));
    this.outPorts.out.connect();
    return shaReq();
  };

  return SetContents;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new SetContents;
};

});
require.register("bergie-FD.js/fd.js", function(exports, require, module){
// Copyright (c) 2011, Srikumar K. S. (srikumarks@gmail.com)
// License: New BSD (http://www.opensource.org/licenses/bsd-license.php)
//
// Module: FD
// Status: Work (very much) in progress
//
// Basic finite domain constraint programming using the
// "computation spaces" idea in Oz to factorize a search
// problem into propagators, distributors, search strategies
// and problem scripts.
//
// Exports:
// 
// Class FD.space is a computation space.
// FD.space has methods that add propagators to spaces.
// Each space has a "brancher" object that can branch
// a space if it isn't solved yet and some options can be
// explored. You can enqueue different branchers into a
// space's brancher object which will then control how the
// search tree is created.
//
// Namespace FD.distribute has the following strategies -
//    FD.distribute.naive
//    FD.distribute.fail_first
// 
// Namespace FD.search has the following search algo -
//    FD.search.depth_first
//
var FD = (function (exports, Math) {

    var FD_SUP = 100000000;

    // Fails if the given dom is empty by throwing 'fail'.
    // If it isn't empty, dom itself is returned. 
    // Useful within propagators.
    function domain_non_empty(dom) {
        if (dom.length === 0) { throw 'fail'; }
        return dom;
    }

    // CSIS form = Canonical Sorted Interval Sequeunce form.
    //
    // Intersection of two domains given in CSIS form.
    // r is optional and if given it should be an array and
    // the domain pieces will be inserted into it, in which case
    // the result domain will be returned unsimplified.
    function domain_intersection(dom1, dom2, r) {
        var i, j, len1, len2, b1, b2, d1, d2, d3, d4, d, mx, mn;

        if (dom1.length === 0 || dom2.length === 0) {
            return r || [];
        }

        if (dom1.length === 1) {
            if (dom2.length === 1) {
                b1 = dom1[0];
                b2 = dom2[0];
                mn = b1[0] > b2[0] ? b1[0] : b2[0];
                mx = b1[1] < b2[1] ? b1[1] : b2[1];
                r = r || [];
                if (mx >= mn) {
                    r.push([mn, mx]);
                }
                return r;
            } else {
                return domain_intersection(dom2, dom1, r);
            }
        } else {
            if (dom2.length === 1) {
                mn = dom2[0][0];
                mx = dom2[0][1];
                r = r || [];
                for (i = 0, len1 = dom1.length; i < len1; ++i) {
                    d = dom1[i];
                    if (d[0] <= mx && d[1] >= mn) {
                        r.push([(mn > d[0] ? mn : d[0]), (mx < d[1] ? mx : d[1])]);
                    }
                }
                return r;
            } else {
                // Worst case. Both lengths are > 1. Divide and conquer. 
                i = dom1.length >> 1;
                j = dom2.length >> 1;
                d1 = dom1.slice(0, i);
                d2 = dom1.slice(i);
                d3 = dom2.slice(0, j);
                d4 = dom2.slice(j);
                d = domain_intersection(d1, d3, r);
                d = domain_intersection(d1, d4, d);
                d = domain_intersection(d2, d3, d);
                d = domain_intersection(d2, d4, d);
                return r ? d : simplify_domain(d);
            }
        }
    }

    // Turns d into CSIS form.
    function simplify_domain(d) {
        if (d.length === 0) {
            return d;
        }

        if (d.length === 1) {
            if (d[0][1] < d[0][0]) {
                return [];
            } else {
                return d;
            }
        }

        var result = [];
        var i, len, prev, prevL, prevR, next, nextL, nextR;

        // Find the first index from which we need to do the
        // simplification. If at the end of this loop i >= len,
        // then we need to do nothing and we avoid loading the GC.
        // This loop checks for overlaps and ordering issues.
        prevL = d[0][0]; prevR = d[0][1];
        i = 0; len = d.length;
        if (prevR >= prevL) {
            for (i = 1; i < len; ++i) {
                next = d[i];
                if (next[1] < next[0] || next[0] <= prevR || next[1] <= prevR) {
                    break;
                } else {
                    prevR = next[1];
                }
            }
        }

        if (i >= len) {
            // Nothing to do.
            return d;
        }

        d.sort(function (d1, d2) { return d1[0] - d2[0]; });
        result.push(prev = d[0]);

        for (i = 1, len = d.length; i < len; ++i) {
            next = d[i];
            if (prev[1] >= next[0]) {
                // Two consecutive domains that are at least touching.
                // Merge them.
                prev[1] = Math.max(prev[1], next[1]);
            } else {
                result.push(prev = next);
            }
        }

        d.splice(0, d.length);
        d.push.apply(d, result);
        return result;
    }

    function domain_bounds(d) {
        if (d.length > 0) {
            return [d[0][0], d[d.length-1][1]];
        } else {
            throw 'fail';
        }
    }

    function domain_equal(d1, d2) {
        if (d1.length != d2.length) {
            return false;
        }

        var i, len;
        for (i = 0, len = d1.length; i < len; ++i) {
            if (d1[i][0] != d2[i][0] || d1[i][1] != d2[i][1]) {
                return false;
            }
        }

        return true;
    }

    // The complement of a domain is such that domain U domain' = [[0, FD_SUP]].
    function domain_complement(d) {
        if (d.length === 0) {
            return [[0, FD_SUP]];
        } else {
            var end = 0;
            var result = [];
            var i, len;
            for (i = 0, len = d.length; i < len; ++i) {
                if (end < d[i][0]) {
                    result.push([end, d[i][0] - 1]);
                }
                end = d[0][1] + 1;
            }
            if (end < FD_SUP) {
                result.push([end, FD_SUP]);
            }
            return result;
        }
    }

    // The union of two domains contains all the intervals in either domain.
    function domain_union(d1, d2) {
        var result = [];
        result.push.apply(result, d1);
        result.push.apply(result, d2);
        return simplify_domain(result);
    }

    // If a parent 'brancher' is given, then the queue is shared
    // with the parent, but the next_brancher is incremented.
    function Brancher(S, brancher) {
        this.space = S;
        this.queue = brancher ? brancher.queue : [];
        this.next_brancher = brancher ? brancher.next_brancher : 0;
    }

    Brancher.prototype = {
        branch: function () {
            // Note that the "next brancher" field will be
            // taken from the deepest space's brancher object
            // due to access via 'this'. However, the queue
            // is an array whose contents are common to all 
            // branchers part of the same tree.
            var b, ch = null;

            do {
                b = this.queue[this.next_brancher];
                ch = b ? b.branch.call(this, this.space) : null;
            } while (ch === null && this.descend());

            return ch;
        },

        enqueue: function (b) {
            // Note that the queue is common to all spaces
            // starting from the parent space, but the
            // 'next_brancher' index is local to the brancher
            // belonging to each space.
            this.queue.push(b);
            return this;
        },

        descend: function () {
            if (this.next_brancher + 1 < this.queue.length) {
                this.next_brancher++;
                return true;
            } else {
                return false;
            }
        },

        descend_and_branch: function () {
            return this.descend() ? this.branch() : null;
        }
    };

    // Empty propagation step
    function empty_propagation_step() {
        return 0;
    }

    // A propagator is solved if all the depvars it affects and
    // depends on have domains of size = 1.
    function propagator_is_solved(S, p, dont_mark_solved) {
        var i, len, b;
        
        if (p.solved) {
            return true; 
        }

        for (i = 0, len = p.allvars.length; i < len; ++i) {
            if (S.vars[p.allvars[i]].is_undetermined()) {
                return false;
            }
        }

//        return dont_mark_solved ? true : (p.solved = true);
        return true;        
    }

    // Some common features for all propagators
    var Propagator = {
        save_vars: function (P) {
            var var_state_stack = P.var_state_stack || (P.var_state_stack = []);
            var i, N, doms = [], steps = [];
            for (i = 1, N = P.space.length; i < N; ++i) {
                doms.push(P.space[i].dom);
                steps.push(P.space[i].step);
            }
            var_state_stack.push([doms, steps, P.last_step]);     
            P.old_step = P.step;
        },

        restore_vars: function (P) {
            var vss = P.var_state_stack.pop();
            var doms = vss[0], steps = vss[1];
            var i, N;
            for (i = 1, N = P.space.length; i < N; ++i) {
                P.space[i].dom = doms[i - 1];
                P.space[i].step = steps[i - 1];
            }
            P.step = P.old_step;
            P.last_step = vss[2];
        },

        discard_saved_vars: function (P) {
            P.var_state_stack.pop();
            delete P.old_step;
        },

        snapshot_vars: function (P) {
            this.save_vars(P);
            return P.var_state_stack.pop()[0];
        },

        complementary_operator: {
            eq: 'neq',
            neq: 'eq',
            lt: 'gte',
            gt: 'lte',
            lte: 'gt',
            gte: 'lt'
        }
    };

    // Concept of a space that holds fdvars, propagators and branchers.
    function Space(S) {
        if (S) {
            // The given space is being cloned.
            var i, j, v, p;

            // Bring the fdvars in using copy-on-write.
            this.vars = {};
            for (i in S.vars) {
                p = S.vars[i];
                this.vars[i] = new FDVar(p.dom, p.step);
            }

            // The propagators can simply be borrowed by reference
            // into this space since they all have a "set space" step
            // before they get to run.
            this._propagators = [];
            for (i = 0; i < S._propagators.length; ++i) {
                p = S._propagators[i];
                if (!propagator_is_solved(S, p)) {
                    v = {allvars: p.allvars, depvars: p.depvars, step: p.step};
                    this.newprop(v);
                }
            }

            // The brancher queue object is shared with the parent,
            // except for the "next brancher" state which is made
            // local to this space.
            this.brancher = new Brancher(this, S.brancher);

            // Keep note of the space that this one was cloned from.
            //
            // TODO: Remove this reference. It might result in less
            // memory being used during searches. If we keep around the
            // parent space like this, then we have to maintain all
            // spaces that we search in memory. For now, since I'm
            // still debugging, this is all right.
            this.clone_of = S;
        } else {
            // The FDVARS are all named and accessed by name.
            // When a space is cloned, the clone's fdvars objects
            // all have their __proto__ fields set to the parent's
            // fdvars object. This gets us copy on modify semantics.
            this.vars = {};
            this._propagators = [];
            this.brancher = new Brancher(this);
        }

        this.succeeded_children = 0;
        this.failed_children = 0;
        this.stable_children = 0;

        return this;
    }

    // Duplicates the functionality of new Space(S) for readability.
    Space.prototype.clone = function () {
        return new Space(this);
    };

    // When done with the space, call this to send success results
    // to the parent space from which it was cloned.
    Space.prototype.done = function () {
        if (this.clone_of) {
            this.clone_of.succeeded_children += this.succeeded_children;
            this.clone_of.failed_children += this.failed_children;
            if (this.failed) {
                this.clone_of.failed_children++;
            }
            if (this.succeeded_children === 0 && this.failed_children > 0) {
                this.failed = true;
            }
            this.clone_of.stable_children += this.stable_children;
        }
    };

    // A monotonically increasing class-global counter for unique temporary variable names.
    Space._temp_count = 1;

    // Run all the propagators until stability point. Returns the number
    // of changes made or throws a 'fail' if any propagator failed.
    Space.prototype.propagate = function () {
        var i, ps, len, count, totalCount = 0;
        do {
            for (i = 0, ps = this._propagators, len = ps.length, count = 0; i < len; ++i) {
                count += ps[i].step();
            }
            totalCount += count;
        } while (count > 0);
        // console.log(JSON.stringify(this.solution()));
        return totalCount;
    };

    // Returns true if this space is solved - i.e. when
    // all the fdvars in the space have a singleton domain.
    //
    // This is a *very* strong condition that might not need
    // to be satisfied for a space to be considered to be
    // solved. For example, the propagators may determine
    // ranges for all variables under which all conditions
    // are met and there would be no further need to enumerate
    // those solutions.
    //
    // For weaker tests, use the solve_for_variables function
    // to create an appropriate "is_solved" tester and 
    // set the "state.is_solved" field at search time to
    // that function.
    Space.prototype.is_solved = function () {
        var i, v;
        for (i in this.vars) {
            v = this.vars[i];
            if (v.dom.length === 1) {
                if (v.dom[0][0] !== v.dom[0][1]) {
                    return false;
                } else {
                    // Singleton domain
                }
            } else {
                return false;
            }
        }

        return true;
    };

    // Returns an object whose field names are the fdvar names
    // and whose values are the solved values. The space *must*
    // be already in a solved state for this to work.
    Space.prototype.solution = function () {
        var result = {};
        var i, v, d;
        for (i in this.vars) {
            // Don't include the temporary variables in the "solution".
            // Temporary variables take the form of a numeric property
            // of the object, so we test for the key to be a number and
            // don't include those variables in the result.
            if (/^[0-9]+$/.test(i) === false) {
                v = this.vars[i];
                d = v.dom;
                result[i] = (d.length === 0 ? false : ((d.length > 1 || d[0][1] > d[0][0]) ? d : d[0][0]));
            }
        }
        return result;
    };

    // Utility to easily print out the state of variables in the space.
    Space.prototype.toString = function () {
        return JSON.stringify(this.solution());
    };

    // Injects the given proc into this space by calling
    // the proc with a single argument which is the current space.
    Space.prototype.inject = function (proc) {
        proc(this); // duh!
        return this;
    };

    Space.prototype.initprop = function (p) {
        p.last_step = -1;
        p.space = [this];
        var i, len;
        for (i = 0, len = p.allvars.length; i < len; ++i) {
            p.space.push(this.vars[p.allvars[i]]);
        }
        return p;
     };

    // Adds the new given propagator to this space and returns the space.
    Space.prototype.newprop = function (p) {
        this._propagators.push(this.initprop(p));
        return this;
    };

    // Returns a new unique name usable for a temporary fdvar
    // for more complex calculations. Every call will yield
    // a different name that is unique across all spaces.
    //
    // You can optionally specify a domain for the temporary
    // if you already know something about it.
    Space.prototype.temp = function (dom) {
        var t = ++(Space._temp_count);
        this.decl(t, dom);
        return t;
    };

    // Create N temporary FD variables and return their names
    // in an array.
    Space.prototype.temps = function (N, dom) {
        var i;
        var result = [];
        for (i = 0; i < N; ++i) {
            result.push(this.temp(dom));
        }
        return result;
    };

    // Create a "constant". We have no optimizing support for
    // constants at the moment and just treat it as a temp FDVar
    // whose domain is of size = 1.
    //
    // Fixing issue #1 - 'const' in the property position is not
    // accepted by the IE8 parser. It is likely to be rejected by
    // the closure compiler too. So I'm changing the name to 'konst' 
    // instead. I'll keep the old name 'const' for compatibility.
    Space.prototype.konst = function (val) {
        if (val < 0 || val > FD_SUP) {
            throw "FD.space.konst: Value out of valid range";
        }

        return this.temp([[val, val]]);
    };
    Space.prototype['const'] = Space.prototype.konst; // Keep old name for compatibility.

    function FDVar(dom, step) {
        this.dom = dom || [[0, FD_SUP]];
        this.step = step || 0;
    }

    FDVar.prototype = {
        is_undetermined: function () {
            return (this.dom.length > 1) || (this.dom[0][0] < this.dom[0][1]);
        },

        set_dom: function (d) {
            if (!domain_equal(this.dom, d)) { 
                this.dom = d; 
                this.step++; 
            } 
            return d; 
        },

        constrain: function (d) {
            return this.set_dom(domain_non_empty(domain_intersection(this.dom, d)));
        },

        size: function () {
            // TODO: Can be cached using the 'step' member which
            // keeps track of the number of times the domain was
            // changed.
            var i, N, s = 0;
            for (i = 0, N = this.dom.length; i < N; ++i) {
                s += this.dom[i][1] - this.dom[i][0] + 1;
            }
            return s;
        },

        min: function () {
            return this.dom[0][0];
        },

        max: function () {
            return this.dom[this.dom.length - 1][1];
        },

        // This "mid" function is quick to calculate and is a useful
        // compromise if you aren't really interested in the exact 
        // middle value, but something along the lines of "avoid the
        // extremes" as best as you can, as fast as you can.
        rough_mid: function () {
            var midDomIx = Math.floor(this.dom.length / 2);
            var midDom = this.dom[midDomIx];
            return Math.round((midDom[0] + midDom[1]) / 2);
        },

        // This is true "mid" function that returns the exact middle
        // value of the domain, but needs to run through the whole domain
        // to do it. Can be made more efficient, see TODO note below.
        mid: function () {
            var size = this.size();
            var midIx = Math.floor(size / 2);
            var domIx = 0;
            var dom = this.dom[domIx];

            // TODO: By right, we should do a binary search here
            // instead of a linear search. Yes, I'm lazy :P (Kumar)
            while (midIx > dom[1] - dom[0]) {
                midIx -= dom[1] - dom[0] + 1;
                domIx++;
                dom = this.dom[domIx];
            }

            return dom[0] + midIx; 
        }
    };

    // Once you create an fdvar in a space with the given
    // name, it is available for accessing as a direct member
    // of the space. Since this can cause a name clash, it is
    // recommended that you start the names of fdvars with an
    // upper case letter. Since all the declared member names
    // start with a lower case letter, a clash can certainly
    // be avoided if you stick to that rule.
    //
    // If the domain is not specified, it is taken to be [[0, FD_SUP]].
    //
    // Returns the space. All methods, unless otherwise noted,
    // will return the current space so that other methods
    // can be invoked in sequence.
    Space.prototype.decl = function (name_or_names, dom) {
        var i;

        if (name_or_names instanceof Object || name_or_names instanceof Array) {
            // Recursively declare all variables in the structure given.
            for (i in name_or_names) {
                this.decl(name_or_names[i], dom);
            }

            return this;
        }
        
        // A single variable is being declared.
        var name = name_or_names, fs = this.vars;
        var f = fs[name];
        if (f) { 
            // If it already exists, change the domain if necessary.
            if (dom) { f.set_dom(dom); }
            return this; 
        }

        fs[name] = new FDVar(dom);

        return this;
    };

    // Same function as var, but the domain is
    // that of a single number.
    Space.prototype.num = function(name, n) {
        return this.decl(name, [[n, n]]);
    };

    // Adds propagators which reify the given operator application
    // to the given boolean variable.
    //
    // `opname` is a string giving the name of the comparison
    // operator to reify. Currently, 'eq', 'neq', 'lt', 'lte', 'gt' and 'gte'
    // are supported.
    //
    // `argv` is an array of arguments accepted by the given 
    // comparison operator. Currently this *must* be an array of two
    // FD variable names.
    //
    // `boolname` is the name of the boolean variable to which to
    // reify the comparison operator. Note that this boolean
    // variable must already have been declared. If this argument
    // is omitted from the call, then the `reified` function can
    // be used in "functional style" and will return the name of
    // the reified boolean variable which you can pass to other
    // propagator creator functions.
    Space.prototype.reified = function (opname, argv, boolname) {
        var result, positive_propagator, negative_propagator;

        if (opname in Propagator.complementary_operator) {
            if (boolname) {
                this.vars[boolname].constrain([[0,1]]);
                result = this;
            } else {
                boolname = this.temp([[0,1]]);
                result = boolname;
            }

            console.log('GRAPH: ' + argv[0] + ' ' + opname + ' ' + argv[1] + ' :: ' + boolname);

            this[opname].apply(this, argv);
            positive_propagator = this._propagators.pop();

            this[Propagator.complementary_operator[opname]].apply(this, argv);
            negative_propagator = this._propagators.pop();

            var deps = argv.slice(0);
            deps.push(boolname);

            this.newprop({
                allvars: deps,
                depvars: deps,
                step: function () {
                    var S = this.space[0], v1 = this.space[1], v2 = this.space[2], b = this.space[3], bdom, snap, i, N, d, k, p, np;
                    var nextStep = v1.step + v2.step + b.step, f;
                    if (nextStep > this.last_step) {
                        // We need to make sure the `last_step` related changes
                        // are unique to this space, since p and np won't be
                        // borrowed into cloned spaces, since they aren't in 
                        // the `S._propagators` array.

                        if (false && this.solved) {
                            return 0;
                        }

                        if (!this.p) {                   
                            this.p = p = S.initprop({
                                allvars: positive_propagator.allvars, 
                                depvars: positive_propagator.depvars,
                                step: positive_propagator.step
                            });
                        } else {
                            p = this.p;
                        }

                        if (!this.np) {
                            this.np = np = S.initprop({
                                allvars: negative_propagator.allvars, 
                                depvars: negative_propagator.depvars,
                                step: negative_propagator.step
                             });
                        } else {
                            np = this.np;
                        }

                        do {
                            this.last_step = v1.step + v2.step + b.step;

                            bdom = b.dom[0];

                            if (bdom[0] === 1) {
                                p.step(); // may throw
                                this.solved = propagator_is_solved(S, p);
                            }

                            if (bdom[1] === 0) {
                                // The reified fdvar generates the negative condition.
                                np.step(); // may throw
                                this.solved = propagator_is_solved(S, np);
                            }

                            if (bdom[0] < bdom[1]) {
                                // The reified fdvar doesn't decide the condition, so
                                // we now need to check whether the conditions constrain
                                // the reified fdvar.
                                Propagator.save_vars(p);

                                try {
                                    p.step();
                                    Propagator.restore_vars(p);
                                } catch (e) {
                                    Propagator.restore_vars(p);
                                    b.constrain([[0, 0]]);
                                }

                                bdom = b.dom[0];
                            }

                            if (bdom[0] < bdom[1]) {
                                Propagator.save_vars(np);

                                try {
                                    np.step();
                                    Propagator.restore_vars(np);
                                } catch (e) {
                                    Propagator.restore_vars(np);
                                    b.constrain([[1, 1]]);
                                }
                            }
                        } while (v1.step + v2.step + b.step > this.last_step);

                        this.last_step = v1.step + v2.step + b.step;
                        return this.last_step - nextStep;
                    } else {
                        return 0;
                    }
                }
            });

            return result;
        } else {
            throw "FD.space.reified: Unsupported operator '" + opname + "'";
        }
    };

    // Domain equality propagator. Creates the propagator
    // in this space. The specified variables need not
    // exist at the time the propagator is created and
    // added, since the fdvars are all referenced by name.
    //
    // A convention for propagators is that the return
    // value of a propagator is number unless
    // the propagator has failed, in which case it throws
    // an exception 'fail'. The returned number indicates
    // the number of domains that were changed by this propagation
    // step. 
    //
    // The second optional argument indicates what you want the
    // propagator to do.
    Space.prototype.eq = function(v1name, v2name) {

        // If v2name is not specified, then we're operating in functional syntax
        // and the return value is expected to be v2name itself. This can happen
        // when, for example, scale uses a weight factor of 1.
        if (!v2name) {
            return v1name;
        }

        var p = {
            // Make available the list of fd variables that this
            // propagator affects. The space can check whether
            // a propagator is at its limit using this list.
            allvars: [v1name, v2name],
            depvars: [v1name, v2name],
            step: function () {
                var v1 = this.space[1], v2 = this.space[2];
                var nextStep = v1.step + v2.step;
                if (nextStep > this.last_step) {
                    var d = domain_non_empty(domain_intersection(v1.dom, v2.dom));
                    v1.set_dom(d);
                    v2.set_dom(d);
                    this.last_step = v1.step + v2.step;
                    return this.last_step - nextStep;
                } else {
                    return 0;
                }
            }
        };

        return this.newprop(p);
    };

    // Less than propagator. See general propagator nores
    // for fdeq which also apply to this one.
    Space.prototype.lt = function (v1name, v2name) {

        var p = {
            allvars: [v1name, v2name],
            depvars: [v1name, v2name],
            step: function () {
                var v1 = this.space[1], v2 = this.space[2];
                var nextStep = v1.step + v2.step;
                if (nextStep > this.last_step) {
                    var b1 = domain_bounds(v1.dom);
                    var b2 = domain_bounds(v2.dom);
                    this.last_step = nextStep;

                    if (b2[0] > b1[1]) {
                        // Condition already satisfied. No changes necessary.
                        // Change the step function to one that does almost no work.
//                        this.step = empty_propagation_step;
                        this.solved = true;                        
                        return 0;
                    }

                    var count = 0;

                    do {
                        this.last_step = v1.step + v2.step;
                        b1 = domain_bounds(v1.dom);
                        b2 = domain_bounds(v2.dom);

                        if (b2[1] - 1 < b1[1]) {
                            // Need to change domain of v1.
                            v1.set_dom(domain_non_empty(domain_intersection(v1.dom, [[b1[0], b2[1] - 1]])));
                        }

                        if (b1[0] + 1 > b2[0]) {
                            // Need to change domain of v2.
                            v2.set_dom(domain_non_empty(domain_intersection(v2.dom, [[b1[0] + 1, b2[1]]])));
                        }
                    } while (v1.step + v2.step > this.last_step);

                    return (this.last_step = v1.step + v2.step) - nextStep;
                } else {
                    return 0;
                }
            }
        };

        return this.newprop(p);
    };

    // Greater than propagator.
    Space.prototype.gt = function (v1name, v2name) {
        return this.lt(v2name, v1name);
    };

    // Less than or equal to propagator.
    Space.prototype.lte = function (v1name, v2name) {

        var p = {
            allvars: [v1name, v2name],
            depvars: [v1name, v2name],
            step: function () {
                var v1 = this.space[1], v2 = this.space[2];
                var nextStep = v1.step + v2.step;
                if (nextStep > this.last_step) {
                    var b1 = domain_bounds(v1.dom);
                    var b2 = domain_bounds(v2.dom);
                    this.last_step = nextStep;

                    if (b2[0] >= b1[1]) {
                        // Condition already satisfied. No changes necessary.
                        // Change the step function to one that does almost no work.
//                        this.step = empty_propagation_step;
                        this.solved = true;                        
                        return 0;
                    }

                    var count = 0;

                    do {
                        this.last_step = v1.step + v2.step;
                        b1 = domain_bounds(v1.dom);
                        b2 = domain_bounds(v2.dom);

                        if (b2[1] < b1[1]) {
                            // Need to change domain of v1.
                            v1.set_dom(domain_non_empty(domain_intersection(v1.dom, [[b1[0], b2[1]]])));
                        }

                        if (b1[0] > b2[0]) {
                            // Need to change domain of v2.
                            v2.set_dom(domain_non_empty(domain_intersection(v2.dom, [[b1[0], b2[1]]])));
                        }
                    } while (v1.step + v2.step > this.last_step)

                    return (this.last_step = v1.step + v2.step) - nextStep;
                } else {
                    return 0;
                }
            }
        };

        return this.newprop(p);
    };

    // Greater than or equal to.
    Space.prototype.gte = function (v1name, v2name) {
        return this.lte(v2name, v1name);
    };

    // Ensures that the two variables take on different values.
    Space.prototype.neq = function (v1name, v2name) {

        var p = {
            allvars: [v1name, v2name],
            depvars: [v1name, v2name],
            step: function () {
                var v1 = this.space[1], v2 = this.space[2];
                var nextStep = v1.step + v2.step;
                if (nextStep > this.last_step) {
                    var b1 = domain_bounds(v1.dom);
                    var b2 = domain_bounds(v2.dom);
                    this.last_step = nextStep;

                    if (b2[0] > b1[1] || b1[1] < b2[0]) {
                        // Condition already satisfied. No changes necessary.
                        // Change the step function to one that does almost no work.
//                        this.step = empty_propagation_step;
                        this.solved = true;                        
                        return 0;
                    }

                    var v12 = domain_intersection(v1.dom, v2.dom);
                    if (v12.length === 0) {
                        // Condition already satisfied.
                        // Change the step function to one that does almost no work.
//                        this.step = empty_propagation_step;
                        this.solved = true;                        
                        return 0;
                    }

                    do {
                        this.last_step = v1.step + v2.step;
                        b1 = domain_bounds(v1.dom);
                        b2 = domain_bounds(v2.dom);

                        if (b1[0] === b1[1]) {
                            v2.set_dom(domain_non_empty(domain_intersection(v2.dom, domain_complement([b1]))));
                        }

                        if (b2[0] === b2[1]) {
                            v1.set_dom(domain_non_empty(domain_intersection(v1.dom, domain_complement([b2]))));
                        }
                    } while (v1.step + v2.step > this.last_step);

                    this.last_step = v1.step + v2.step;
                    return this.last_step - nextStep;
                } else {
                    return 0;
                }
            }
        };

        return this.newprop(p);        
    };

    // Takes an arbitrary number of FD variables and adds propagators that
    // ensure that they are pairwise distinct.
    Space.prototype.distinct = function (vars) {
        var i, j, len;
        for (i = 0, len = vars.length; i < len; ++i) {
            for (j = 0; j < i; ++j) {
                this.neq(vars[i], vars[j]);
            }
        }
        return this;
    };


    function ring(plusop, minusop, v1name, v2name, sumname) {
        var retval = this;

        // If sumname is not specified, we need to create a temp
        // for the result and return the name of that temp variable.
        if (!sumname) {
            sumname = this.temp();
            retval = sumname;
        }

        console.log('GRAPH: ' + v1name + ' + ' + v2name  + ' = ' + sumname);

        this.newprop({
            allvars: [v1name, v2name, sumname],
            depvars: [v1name, v2name],
            step: function () {
                var v1 = this.space[1], v2 = this.space[2], sum = this.space[3];
                var nextStep = v1.step + v2.step + sum.step;

                if (nextStep > this.last_step) {
                    sum.set_dom(domain_non_empty(domain_intersection(plusop(v1.dom, v2.dom), sum.dom)));
                    this.last_step = sum.step + v1.step + v2.step;
                }

                return this.last_step - nextStep;
            }
        });

        this.newprop({
            allvars: [v1name, v2name, sumname],
            depvars: [v2name, sumname],
            step: function () {
                var v1 = this.space[1], v2 = this.space[2], sum = this.space[3];
                var nextStep = v1.step + v2.step + sum.step;

                if (nextStep > this.last_step) {
                    v1.set_dom(domain_non_empty(domain_intersection(minusop(sum.dom, v2.dom), v1.dom)));
                    this.last_step = sum.step + v1.step + v2.step;
                }

                return this.last_step - nextStep;
            }
        });

        this.newprop({
            allvars: [v1name, v2name, sumname],
            depvars: [v1name, sumname],
            step: function () {
                var v1 = this.space[1], v2 = this.space[2], sum = this.space[3];
                var nextStep = v1.step + v2.step + sum.step;

                if (nextStep > this.last_step) {
                    v2.set_dom(domain_non_empty(domain_intersection(minusop(sum.dom, v1.dom), v2.dom)));
                    this.last_step = sum.step + v1.step + v2.step;
                }

                return this.last_step - nextStep;
            }
        });

        return retval;
    };

    // Bidirectional addition propagator.
    Space.prototype.plus = function (v1name, v2name, sumname) {
        return ring.call(this, dom_plus, dom_minus, v1name, v2name, sumname);
    };

    // Bidirectional multiplication propagator.
    Space.prototype.times = function (v1name, v2name, prodname) {
        return ring.call(this, dom_times, dom_divby, v1name, v2name, prodname);
    };

    // factor = constant number (not an fdvar)
    // vname is an fdvar name
    // prodname is an fdvar name.
    //
    // factor * v = prod
    Space.prototype.scale = function (factor, vname, prodname) {
        if (factor === 1) {
            return this.eq(vname, prodname);
        } else if (factor === 0) {
            return this.eq(this.temp([[0, 0]]), prodname);
        } else if (factor < 0) {
            throw "scale: negative factors not supported.";
        }

        var retval = this;
        if (!prodname) {
            prodname = this.temp();
            retval = prodname;
        }

        this.newprop({
            allvars: [vname, prodname],
            depvars: [vname],
            step: function () {
                var v = this.space[1], prod = this.space[2];
                var nextStep = v.step + prod.step;
                if (nextStep > this.last_step) {
                    var bd = domain_bounds(v.dom);
                    var kd, l, r;

                    // We multiply only the interval bounds.
                    kd = v.dom.map(function (i) { return [Math.min(FD_SUP, i[0] * factor), Math.min(FD_SUP, i[1] * factor)]; });

                    prod.set_dom(domain_non_empty(domain_intersection(kd, prod.dom)));

                    return (this.last_step = v.step + prod.step) - nextStep;
                } else {
                    return 0;
                }
             }
        });

        this.newprop({
            allvars: [vname, prodname],
            depvars: [prodname],
            step: function () {
                var v = this.space[1], prod = this.space[2];
                var nextStep = v.step + prod.step;
                if (nextStep > this.last_step) {
                    var dbyk, l, r;

                    dbyk = simplify_domain(prod.dom.map(function (i) {
                        l = i[0] / factor;
                        r = i[1] / factor;
                        return [l - l % 1, r - r % 1];
                    }));

                    v.set_dom(domain_non_empty(domain_intersection(dbyk, v.dom)));

                    return (this.last_step = v.step + prod.step) - nextStep;
                } else {
                    return 0;
                }
            }
        });
        
        return retval;
    };

    // TODO: Can be made more efficient.
    Space.prototype.times_plus = function (k1, v1name, k2, v2name, resultname) {
        return this.plus(this.scale(k1, v1name), this.scale(k2, v2name), resultname);
    };

    // Sum of N fdvars = resultFDVar
    // Creates as many temporaries as necessary.
    Space.prototype.sum = function (vars, resultName) {
        var n, N, t1, t2;
        var retval = this;
        if (!resultName) {
            resultName = this.temp();
            retval = resultName;
        }

        switch (vars.length) {
            case 0: throw "Space.sum: Nothing to sum!";
            case 1: this.eq(vars[0], resultName); return retval;
            case 2: this.plus(vars[0], vars[1], resultName); return retval;
            default:
                n = vars.length >> 1;
                t2 = this.temp();
                this.sum(vars.slice(n), t2);
                if (n > 1) {
                    t1 = this.temp();
                    this.sum(vars.slice(0, n), t1);
                } else {
                    t1 = vars[0];
                }
                this.plus(t1, t2, resultName);
                return retval;
        }
    };

    // Product of N fdvars = resultFDvar.
    // Create as many temporaries as necessary.
    Space.prototype.product = function (vars, resultName) {
        var n, t1, t2;
        var retval = this;
        if (!resultName) {
            resultName = this.temp();
            retval = resultName;
        }

        switch (vars.length) {
            case 0: return retval;
            case 1: this.eq(vars[0], resultName); return retval;
            case 2: this.times(vars[0], vars[1], resultName); return retval;
            default:
                n = vars.length >> 1;
                t2 = this.temp();
                this.product(vars.slice(n), t2);
                if (n > 1) {
                    t1 = this.temp();
                    this.product(vars.slice(0, n), t1);
                } else {
                    t1 = vars[0];
                }
                this.times(t1, t2, resultName);
                return retval;
        }
    };

    // Weighted sum of fdvars where the weights are constants.
    Space.prototype.wsum = function (kweights, vars, resultName) {
        var temps = [];
        var i, len, t;
        for (i = 0, len = vars.length; i < len; ++i) {
            t = this.temp();
            this.scale(kweights[i], vars[i], t);
            temps.push(t);
        }
        return this.sum(temps, resultName);
    }

    // Closes all the gaps between the intervals according to
    // the given gap value. All gaps less than this gap are closed.
    function dom_close_gaps(d, gap) {
        if (d.length === 0) { return d; }

        var result = [];
        var i, len, prev, next;
        result.push(prev = [d[0][0], d[0][1]]);
        for (i = 1, len = d.length; i < len; ++i) {
            next = [d[i][0], d[i][1]];
            if (next[0] - prev[1] < gap) {
                prev[1] = next[1];
            } else {
                result.push(prev = next);
            }
        }

        return result;
    }

    function dom_smallest_interval_width(d) {
        return Math.min.apply(null, d.map(function (i) { return i[1] - i[0] + 1; }));
    }

    function dom_largest_interval_width(d) {
        return Math.max.apply(null, d.map(function (i) { return i[1] - i[0] + 1; }));
    }

    // The idea behind this function - which is primarily
    // intended for dom_plus and dom_minus and porbably applies
    // to nothing else - is that when adding two intervals,
    // both intervals expand by the other's amount. This means
    // that when given two segmented domains, each continuous
    // subdomain expands by at least the interval of the smallest
    // subdomain of the other segmented domain. When such an expansion
    // occurs, any gaps between subdomains that are <= the smallest
    // subdomain's interval width get filled up, which we can exploit 
    // to reduce the number of segments in a domain. Reducing the
    // number of domain segments helps reduce the N^2 complexity of
    // the subsequent domain consistent interval addition method.
    function dom_close_gaps2(d1, d2) {
        var d, change;
        do {
            change = 0;
            d = dom_close_gaps(d1, dom_smallest_interval_width(d2));
            change += d1.length - d.length;
            d1 = d;
            d = dom_close_gaps(d2, dom_smallest_interval_width(d1));
            change += d2.length - d.length;
            d2 = d;
        } while (change > 0);

        return [d1, d2];
    }

    function dom_plus(d1, d2) {
        var d, i, j, len1, len2, i1, i2, p = [];
        var change;

        // Simplify the domains by closing gaps since when we add
        // the domains, the gaps will close according to the
        // smallest interval width in the other domain.
        d = dom_close_gaps2(d1, d2);
        d1 = d[0];
        d2 = d[1];

        for (i = 0, len1 = d1.length, len2 = d2.length; i < len1; ++i) {
            i1 = d1[i];
            for (j = 0; j < len2; ++j) {
                i2 = d2[j];
                p.push([Math.min(FD_SUP, i1[0] + i2[0]), Math.min(FD_SUP, i1[1] + i2[1])]);
            }
        }

        return simplify_domain(p);
    }

    // Note that this one isn't domain consistent.
    function dom_times(d1, d2) {
        var i, j, len1, len2, i1, i2, p = [];
        for (i = 0, len1 = d1.length, len2 = d2.length; i < len1; ++i) {
            i1 = d1[i];
            for (j = 0; j < len2; ++j) {
                i2 = d2[j];
                p.push([Math.min(FD_SUP, i1[0] * i2[0]), Math.min(FD_SUP, i1[1] * i2[1])]);
            }
        }

        return simplify_domain(p);
    }

    function dom_minus(d1, d2) {
        var d, i, j, len1, len2, i1, i2, p = [], lo, hi;

        // Simplify the domains by closing gaps since when we add
        // the domains, the gaps will close according to the
        // smallest interval width in the other domain.
        d = dom_close_gaps2(d1, d2);
        d1 = d[0];
        d2 = d[1];

        for (i = 0, len1 = d1.length, len2 = d2.length; i < len1; ++i) {
            i1 = d1[i];
            for (j = 0; j < len2; ++j) {
                i2 = d2[j];
                lo = i1[0] - i2[1];
                hi = i1[1] - i2[0];
                if (hi >= 0) {
                    p.push([(lo < 0 ? 0 : lo), hi]);
                }
            }
        }

        return simplify_domain(p);
    }

    // Note that this isn't domain consistent.
    function dom_divby(d1, d2) {
        var i, j, len1, len2, i1, i2, p = [], lo, hi;
        for (i = 0, len1 = d1.length, len2 = d2.length; i < len1; ++i) {
            i1 = d1[i];
            for (j = 0; j < len2; ++j) {
                i2 = d2[j];
                if (i2[1] > 0) {
                    lo = i1[0] / i2[1];
                    hi = (i2[0] > 0 ? (i1[1] / i2[0]) : FD_SUP);
                    if (hi >= 0) {
                        p.push([(lo < 0 ? 0 : lo), hi]);
                    }
                }
            }
        }

        return simplify_domain(p);
    }

    /////////////////////////////////////////////////////////////////
    // Modular distribution strategies.
    var Distribute = {};

    // The generic distributor.
    Distribute.generic = function (S, varnames, spec) {
       
        function select_by_order(S, vars, orderingfn) {
            if (vars.length > 0) {
                if (vars.length === 1) {
                    return vars[0];
                }

                var i, N, first = 0;
                for (i = 1, N = vars.length; i < N; ++i) {
                    if (!orderingfn(S, vars[first], vars[i])) {
                        first = i;
                    }
                }

                return vars[first];
            } else {
                return null;
            }
        }

        var branch_sequence = {};
        var filterfn = (typeof(spec.filter) === 'string') ? Distribute.generic.filters[spec.filter] : spec.filter;
        var orderingfn = (typeof(spec.ordering) === 'string') ? Distribute.generic.orderings[spec.ordering] : spec.ordering;
        var valuefn = (typeof(spec.value) === 'string') ? Distribute.generic.values[spec.value] : spec.value;

        if (!filterfn || !orderingfn || !valuefn) {
            throw 'FD.distribute.generic: Invalid spec';
        }

        // The role of the branch() function is to produce a function (S, n)
        // that will return S with the choice point n committed. The function's
        // 'numChoices' property will tell you how many choices are available.
        branch_sequence.branch = function (S) {
            var vars, v, doms, Sc;

            vars = filterfn(S, varnames);
            if (vars.length > 0) {
                v = select_by_order(S, vars, orderingfn);

                return v ? valuefn(v) : null;
            } else {
                return null;
            }
        };

        S.brancher.enqueue(branch_sequence);
        return S;
    };

    Distribute.generic.filters = {
        undet: function (S, varnames) {
            var i, N, vs = [];
            for (i = 0, N = varnames.length; i < N; ++i) {
                if (S.vars[varnames[i]].is_undetermined()) {
                    vs.push(varnames[i]);
                }
            }

            return vs;
        }
    };

    Distribute.generic.orderings = {
        naive: function (S, v1, v2) {
            return true;
        },

        size: function (S, v1, v2) {
            return S.vars[v1].size() < S.vars[v2].size();
        },

        min: function (S, v1, v2) {
            return S.vars[v1].min() < S.vars[v2].min();
        },

        max: function (S, v1, v2) {
            return S.vars[v1].max() > S.vars[v2].max();
        }
    };

    // The interface contract for "values" functions is that
    // they take a variable name and return a function that will
    // impose a sequence of choices on the variable into a given
    // space. The returned function (S, n) will commit the given
    // space S to a choice for the originally specified variable.
    // The returned function's "numChoices" property tells you
    // how many choices are available, and the choices are numbered
    // from 0 to numChoices-1.
    //
    // Note that this change of interface has resulted in a noticeable
    // performance degradation. My guess is that the degradation is due
    // to the computations outside the switch blocks having to execute
    // for every choice, whereas in the earlier implementation there
    // were only executed once per space.
    Distribute.generic.values = {

        // Picks the smallest value in the domain first.
        min: function (v) {
            function options(S, n) {
                var vS = S.vars[v];
                var d = vS.min();
                switch (n) {
                    case 0: 
                        vS.constrain([[d, d]]);
                        return S;
                    case 1: 
                        vS.constrain([[d+1, vS.max()]]);
                        return S;
                    default: 
                        throw new Error("Invalid choice");
                }
            }

            options.numChoices = 2;
            return options;
        },

        // Picks the largest value in the domain first.
        max: function (v) {
            function options(S, n) {
                var vS = S.vars[v];
                var d = vS.max();
                switch (n) {
                    case 0:
                        vS.constrain([[d, d]]);
                        return S;
                    case 1:
                        vS.constrain([[vS.min(), d-1]]);
                        return S;
                    default:
                        throw new Error("Invalid choice");
                }
            }

            options.numChoices = 2;
            return options;
        },

        // Picks the middle value in the domain first.
        mid: function (v) {
            function options(S, n) {
                var fv = S.vars[v];
                var d = fv.mid();
                if (n === 0) {
                    fv.constrain([[d, d]]);
                    return S;
                } else if (n === 1) {
                    if (d > fv.min()) {
                        fv.constrain([[fv.min(), d-1], [d+1, fv.max()]]);
                        return S;
                    } else {
                        fv.constrain([[d+1, fv.max()]]);
                        return S;
                    }
                } else {
                    throw new Error("Invalid choice");
                }
            }

            options.numChoices = 2;
            return options;
        },

        // splits the domain roughly down the middle, trying the
        // lower values first.
        splitMin: function (v) {
            function options(S, n) {
                var vS = S.vars[v];
                var d = vS.dom;
                var m = (d[0][0] + d[d.length - 1][1]) >> 1;
                switch (n) {
                    case 0:
                        vS.constrain([[d[0][0], m]]);
                        return S;
                    case 1: 
                        vS.constrain([[m+1, d[d.length - 1][1]]]);
                        return S;
                    default:
                        throw new Error("Invalid choice");
                }
            }

            options.numChoices = 2;
            return options;
        },

        // splits the domain roughly down the middle, trying the
        // higher values first.
        splitMax: function (v) {
            function options(S, n) {
                var vS = S.vars[v];
                var d = vS.dom;
                var m = (d[0][0] + d[d.length - 1][1]) >> 1;
                switch (n) {
                    case 0:
                        vS.constrain([[m+1, d[d.length - 1][1]]]);
                        return S;
                    case 1:
                        vS.constrain([[d[0][0], m]]);
                        return S;
                    default:
                        throw new Error("Invalid choice");
                }
            }

            options.numChoices = 2;
            return options;
        }
    };

    // The native distribution strategy simply steps through all
    // undetermined variables.
    Distribute.naive = (function () {
        var spec = {
            filter: 'undet',
            ordering: 'naive',
            value: 'min'
        };

        return function (S, varnames) {
            return Distribute.generic(S, varnames, spec);
        };
    }());

    // The "fail first" strategy branches on the variable with the
    // smallest domain size.
    Distribute.fail_first = (function () {
        var spec = {
            filter: 'undet',
            ordering: 'size',
            value: 'min'
        };

        return function (S, varnames) {
            return Distribute.generic(S, varnames, spec);
        };
    }());

    // The "domain splitting" strategy where each domain is roughly
    // halved in each step. The 'varname' argument can be either a
    // single fdvar name or an array of names or an object whose
    // values are fdvar names.
    Distribute.split = (function () {
        var spec = {
            filter: 'undet',
            ordering: 'size',
            value: 'splitMin'
        };

        return function (S, varnames) {
            return Distribute.generic(S, varnames, spec);
        };
    }());
            
    // Search using the branchers.
    var Search = {};

    // A "class function" for making "is_solved" testers
    // for use during search.
    Search.solve_for_variables = function (varnames) {
        if (varnames) {
            return function (S) {
                var i, N, v;
                for (i = 0, N = varnames.length; i < N; ++i) {
                    v = S.vars[varnames[i]];
                    if (v.dom.length === 1) {
                        if (v.dom[0][0] !== v.dom[0][1]) {
                            return false;
                        } else {
                            // Singleton domain
                        }
                    } else {
                        return false;
                    }
                }
                return true;
            };
        } else {
            return function (S) { 
                return S.is_solved(); 
            };
        }
    };

    Search.solve_for_propagators = function (S) {
        var i, N, p;
        for (i = 0, N = S._propagators.length; i < N; ++i) {
            if (!propagator_is_solved(S, S._propagators[i])) {
                return false;
            }
        }
        return true;
    };

    // A simple mechanism for branching down a search tree where the
    // choice points function and info about the number of choices
    // are both stored in the space itself. This doesn't have to be
    // the case, however, and you can roll your own strategy and
    // pass it in the "state.next_choice" field.
    //
    // This implementation stores information that is local to
    // a space in the space itself. That doesn't have to be the
    // case and the whole search state is passed in which you
    // can make use of for tracking purposes. For example, you can 
    // have a stack of choice functions that you can use to recompute
    // a space at any depth by starting from the root and applying
    // the options in sequence to a clone of the root space. 
    //
    // The implementation below suffices for the depth_first and
    // branch_and_bound search strategies.
    function next_choice(space, state) {
        if (!space.commit) {
            // Note that the branch call is made only once, irrespective
            // of how many children this space might generate. The branch
            // call now returns a choice function that constrains a chosen
            // variable to a domain indexed by a choice number.
            space.commit = space.brancher.branch();
            if (space.commit) {
                space.commit.nextChoice = 0;
            }
        }

        if (space.commit && space.commit.nextChoice < space.commit.numChoices) {
            // Clone the given space and commit it to the next available choice.
            // Returned the commited cloned space.
            return space.commit(space.clone(), space.commit.nextChoice++);
        } else {
            return null;
        }
    }

    // Depth first search.
    // state.space must be the starting space. The object is used to store and 
    // track continuation information from that point onwards.
    //
    // On return, state.status contains either 'solved' or 'end' to indicate
    // the status of the returned solution. Also state.more will be true if
    // the search can continue and there may be more solutions.
    Search.depth_first = function (state) {
        var space = state.space;
        var stack = state.stack;
        var brancher, next_space, choose_next_space;

        // If no stack argument, then search begins with this space.
        if (!stack || stack.length === 0) {
            stack = state.stack = [space];
        }

        if (!state.is_solved) {
            // Set the default "solved" condition to be "all variables".
            state.is_solved = Search.solve_for_variables();
        }

        if (!state.next_choice) {
            // Set the default branch generator to the next_choice
            // function, which is a simple implementation of generating
            // branches from index 0 to N-1.
            state.next_choice = next_choice;
        }

        choose_next_space = state.next_choice;

        while (stack.length > 0) {
            space = stack[stack.length - 1];

            try {
                // Wait for stability. Could throw a 'fail', in which case
                // this becomes a failed space.
                space.propagate();

                if (state.is_solved(space)) {
                    space.succeeded_children++;
                    space.done();
                    stack.pop();
                    state.status = 'solved';
                    state.space = space;
                    state.more = stack.length > 0;
                    return state;
                }

                // Now this space is neither solved nor failed,
                // therefore it is stable. (WARNING: Is this correct?)

                // Call up the next brancher and fork the space
                // according to what it says.
                next_space = choose_next_space(space, state);
                if (next_space) {
                    // Push on to the stack and explore further.
                    stack.push(next_space);
                } else {
                    // Finished exploring branches of this space. Continue with the previous spaces.
                    // This is a stable space, but isn't a solution. Neither is it a failed space.
                    space.stable_children++;
                    space.done();
                    stack.pop();
                    state.more = stack.length > 0;
                }
            } catch (e) {
                // Some propagators failed so this is now a failed space and we need
                // to pop the stack and continue from above. This is a failed space.
                space.failed = true;
                space.done();
                stack.pop();
            }
        }

        // Failed space and no more options to explore.
        state.status = 'end';
        state.more = false;
        return state;
    };

    // Branch and bound search
    // WARNING: Untested!
    // TODO: Test this function and once the tests pass, remove the above warning.
    //
    // Finds the "best" solution according to the given ordering function.
    // The `state` parameter is similar to the `depth_first` search function.
    // It is expected to be an object such that `state.space` gives the space
    // from which to search for the best solution.
    //
    // The `state` is also what is returned by `branch_and_bound` and `state.space`
    // will be the space with the best solution found during the search. When a
    // solution exists, `state.status` will be the string "solved".
    //
    // The `ordering` argument is expected to be a function of the form
    //       function (space, a_solution) { ... }
    // where the `space` argument is the space into which the ordering function
    // should inject the new constraints for the ordering, and `a_solution` is
    // an object whose keys are root finite domain variable names and whose
    // values are the solved values of those variables. The return value of
    // the ordering function is irrelevant.
    //
    // There are two ways to use the branch_and_bound function -
    //    1. In one shot mode where a single call will give you the best
    //       solution that it can find, if a solution exists at all.
    //
    //    2. In "single step" mode, indicated by setting `state.single_step` to `true`.
    //       In this mode, the function will return whenever it finds a solved space
    //       and `state.more` will indicate whether there may be any more solutions
    //       to look at. In this mode, every call will result in a solution that is
    //       "better" than the one found before it, due to the `ordering` function.
    //
    //       Note that if `state.more` is `false`, then definitely there are no
    //       more solutions to look at, but if it is `true`, there *may* be more
    //       solutions to look at. If a subsequent search turns up empty, it is
    //       indicated by `state.status` being set to the string "end".
    //
    Search.branch_and_bound = function (state, ordering) {
        var space = state.space;
        var stack = state.stack;
        var brancher, next_space, choose_next_space;
        var bestSolution = state.best;

        if (state.error) {
            // If a search tree state with an error is passed in,
            // we throw up immediately.
            throw state;
        }

        // If no stack argument, then search begins with this space.
        if (!stack || stack.length === 0) {
            stack = state.stack = [space];
        }

        if (!state.is_solved) {
            // Set the default "solved" condition to be "all variables".
            state.is_solved = Search.solve_for_variables();
        }

        if (!state.next_choice) {
            // Set the default branch generator to the next_choice
            // function, which is a simple implementation of generating
            // branches from index 0 to N-1.
            state.next_choice = next_choice;
        }

        choose_next_space = state.next_choice;

        while (stack.length > 0) {
            space = stack[stack.length - 1];

            try {
                // Wait for stability. Could throw a 'fail', in which case
                // this becomes a failed space.
                space.propagate();

                if (state.is_solved(space)) {
                    space.succeeded_children++;
                    space.done();
                    stack.pop();
                    state.status = 'solved';
                    state.space = space;
                    state.more = stack.length > 0;

                    // This space is now our "current best solution"
                    state.best = bestSolution = space;

                    // We now try to find something better based on the given
                    // ordering.
                    if (state.more) {
                        next_space = choose_next_space(stack[stack.length - 1], state);
                        while (!next_space && stack.length > 0) {
                            stack[stack.length - 1].done();
                            stack.pop();
                            if (stack.length > 0) {
                                next_space = choose_next_space(stack[stack.length - 1], state);
                            } else {
                                break;
                            }
                        }
                        if (next_space) {
                            // Constrain the search to be better than our current best solution.
                            ordering(next_space, bestSolution.solution());
                            state.needs_constraining = false;
                            stack.push(next_space);

                            // Continue the search. If we've been asked to
                            // single step, then just return the current state.
                            // the stack is already prepared so that the next call
                            // will initiate a search for a solution that is better
                            // than the one in state.space.
                            if (state.single_step) {
                                return state;
                            } else {
                                continue;
                            }
                        } else {
                            // No more spaces to explore. We've already found
                            // the best solution that we can find in this tree.
                            state.more = false;
                        }
                    } 

                    // We have no more branches to explore.
                    // Return the best solution found so far.
                    return state;
                }

                // Now this space is neither solved nor failed,
                // therefore it is stable. (WARNING: Is this correct?)

                // Call up the next brancher and fork the space
                // according to what it says.
                next_space = choose_next_space(space, state);
                if (next_space) {
                    // Push on to the stack and explore further.
                    if (state.needs_constraining && bestSolution) {
                        ordering(next_space, bestSolution.solution());
                    }
                    state.needs_constraining = false;
                    stack.push(next_space);
                } else {
                    // Finished exploring branches of this space. Continue with the previous spaces.
                    // This is a stable space, but isn't a solution. Neither is it a failed space.
                    //
                    // TODO: Ideally, this condition should never occur and if it does, it is 
                    // likely to be an error in the problem specification. Maybe I should
                    // throw up here?
                    space.stable_children++;
                    space.done();
                    stack.pop();
                    state.more = stack.length > 0;
                    state.needs_constraining = true;
                }
            } catch (e) {
                // Some propagators failed so this is now a failed space and we need
                // to pop the stack and continue from above. This is a failed space.
                space.failed = true;
                space.done();
                stack.pop();
                state.more = stack.length > 0;
                state.needs_constraining = true;
            }
        }

        // Failed space and no more options to explore.
        state.status = (bestSolution ? 'solved' : 'end');
        state.more = false;

        // Note that state.space already contains the last - i.e. the "best" solution,
        // If the original space passed to branch_and_bound actually has no solution,
        // then state.space.failed will be true.
        return state;
    };


    exports.SUP = FD_SUP;
    exports.INF = 0;
    exports.space = Space;
    exports.distribute = Distribute;
    exports.search = Search;

    return exports;
})({}, Math);

try {
    module.exports = FD;
} catch (e) {
    // Not in node.js. Likely loaded as FD in a browser.
}

});
require.register("noflo-noflo-finitedomain/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-finitedomain.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("noflo-noflo-finitedomain/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-finitedomain","description":"Finite Domain Constraint Solver","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-finitedomain","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*","bergie/FD.js":"*"},"scripts":["components/CreateSpace.coffee","components/DeclareVariable.coffee","components/GreaterThan.coffee","components/Solve.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"puzzle-piece","components":{"CreateSpace":"components/CreateSpace.coffee","DeclareVariable":"components/DeclareVariable.coffee","GreaterThan":"components/GreaterThan.coffee","Solve":"components/Solve.coffee"}}}');
});
require.register("noflo-noflo-finitedomain/components/CreateSpace.js", function(exports, require, module){
var CreateSpace, FD, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FD = require('fdjs');

CreateSpace = (function(_super) {
  __extends(CreateSpace, _super);

  CreateSpace.prototype.description = 'Create a Finite Domain solving space';

  function CreateSpace() {
    this.inPorts = {
      start: new noflo.Port('bang')
    };
    this.outPorts = {
      space: new noflo.Port('object')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        _this.outPorts.space.send(new FD.space);
        return _this.outPorts.space.disconnect();
      };
    })(this));
  }

  return CreateSpace;

})(noflo.Component);

exports.getComponent = function() {
  return new CreateSpace;
};

});
require.register("noflo-noflo-finitedomain/components/DeclareVariable.js", function(exports, require, module){
var DeclareVariable, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

DeclareVariable = (function(_super) {
  __extends(DeclareVariable, _super);

  DeclareVariable.prototype.description = 'Declare a variable into a Finite Domain solving space';

  function DeclareVariable() {
    this.variable = null;
    this.domain = null;
    this.inPorts = {
      space: new noflo.Port('object'),
      variable: new noflo.Port('string'),
      domain: new noflo.Port('array')
    };
    this.outPorts = {
      space: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.variable.on('data', (function(_this) {
      return function(variable) {
        _this.variable = variable;
      };
    })(this));
    this.inPorts.domain.on('data', (function(_this) {
      return function(domain) {
        if (typeof domain === 'string') {
          return _this.domain = JSON.parse(domain);
        } else {
          return _this.domain = domain;
        }
      };
    })(this));
    this.inPorts.space.on('data', (function(_this) {
      return function(space) {
        if (!_this.variable) {
          _this.error(new Error('No variable defined'));
          return;
        }
        _this.declareVar(space);
        return _this.outPorts.space.send(space);
      };
    })(this));
    this.inPorts.space.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.space.disconnect();
      };
    })(this));
  }

  DeclareVariable.prototype.declareVar = function(space) {
    space.decl(this.variable, this.domain);
    return this.domain = null;
  };

  return DeclareVariable;

})(noflo.Component);

exports.getComponent = function() {
  return new DeclareVariable;
};

});
require.register("noflo-noflo-finitedomain/components/GreaterThan.js", function(exports, require, module){
var GreaterThan, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GreaterThan = (function(_super) {
  __extends(GreaterThan, _super);

  GreaterThan.prototype.description = 'Declare that a variable must be greater than another variable';

  function GreaterThan() {
    this.varA = null;
    this.varB = null;
    this.inPorts = {
      space: new noflo.Port('object'),
      greater: new noflo.Port('string'),
      than: new noflo.Port('string')
    };
    this.outPorts = {
      space: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.greater.on('data', (function(_this) {
      return function(varA) {
        _this.varA = varA;
      };
    })(this));
    this.inPorts.than.on('data', (function(_this) {
      return function(varB) {
        _this.varB = varB;
      };
    })(this));
    this.inPorts.space.on('data', (function(_this) {
      return function(space) {
        if (!_this.varA || !_this.varB) {
          _this.error(new Error('No variables defined'));
          return;
        }
        space.gt(_this.varA, _this.varB);
        return _this.outPorts.space.send(space);
      };
    })(this));
    this.inPorts.space.on('disconnect', (function(_this) {
      return function() {
        return _this.outPorts.space.disconnect();
      };
    })(this));
  }

  return GreaterThan;

})(noflo.Component);

exports.getComponent = function() {
  return new GreaterThan;
};

});
require.register("noflo-noflo-finitedomain/components/Solve.js", function(exports, require, module){
var FD, Solve, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

FD = require('fdjs');

Solve = (function(_super) {
  __extends(Solve, _super);

  Solve.prototype.description = 'Solve a Finite Domain solving space';

  function Solve() {
    this.variables = null;
    this.distribution = 'fail_first';
    this.search = 'depth_first';
    this.inPorts = {
      space: new noflo.Port('object'),
      variables: new noflo.Port('array'),
      distribution: new noflo.Port('string'),
      search: new noflo.Port('string')
    };
    this.outPorts = {
      solution: new noflo.Port('object'),
      error: new noflo.Port('object')
    };
    this.inPorts.variables.on('data', (function(_this) {
      return function(variables) {
        if (typeof variables === 'string') {
          return _this.variables = variables.split(',');
        } else {
          return _this.variables = variables;
        }
      };
    })(this));
    this.inPorts.distribution.on('data', (function(_this) {
      return function(distribution) {
        if (!FD.distribute[distribution]) {
          _this.error(new Error("Finite Domain distribution strategy " + distribution + " not found"));
          return;
        }
        return _this.distribution = distribution;
      };
    })(this));
    this.inPorts.search.on('data', (function(_this) {
      return function(search) {
        if (!FD.search[search]) {
          _this.error(new Error("Finite Domain search strategy " + search + " not found"));
          return;
        }
        return _this.search = search;
      };
    })(this));
    Solve.__super__.constructor.call(this, 'space', 'solution');
  }

  Solve.prototype.doAsync = function(space, callback) {
    var initialState, step;
    if (!this.variables) {
      this.error(new Error('No variables to solve provided'));
    }
    FD.distribute[this.distribution](space, this.variables);
    step = (function(_this) {
      return function(state) {
        FD.search[_this.search](state);
        if (state.space.is_solved()) {
          _this.outPorts.solution.send(state.space.solution());
        }
        if (state.more) {
          setTimeout(function() {
            return step(state);
          }, 0);
          return;
        }
        return _this.outPorts.solution.disconnect();
      };
    })(this);
    initialState = {
      space: space,
      more: true
    };
    return step(initialState);
  };

  return Solve;

})(noflo.AsyncComponent);

exports.getComponent = function() {
  return new Solve;
};

});
require.register("d4tocchini-noflo-draggabilly/index.js", function(exports, require, module){
/*
 * This file can be used for general library features that are exposed as CommonJS modules
 * that the components then utilize
 */

});
require.register("d4tocchini-noflo-draggabilly/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-draggabilly","description":"Draggabilly components for the NoFlo flow-based programming environment","author":"D4 Tocchini <d4@rituwall.com>","repo":"d4tocchini/noflo-draggabilly","version":"0.0.1","keywords":["fbp","drag","dnd","draggable"],"dependencies":{"noflo/noflo":"*"},"scripts":["components/Draggabilly.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"Draggabilly":"components/Draggabilly.coffee"}}}');
});
require.register("d4tocchini-noflo-draggabilly/components/Draggabilly.js", function(exports, require, module){
var NoFloDraggabilly, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');


/*
if typeof process is 'object' and process.title is 'node'
  noflo = require "../../lib/NoFlo"
else
  noflo = require '../lib/NoFlo'
 */

NoFloDraggabilly = (function(_super) {
  __extends(NoFloDraggabilly, _super);

  NoFloDraggabilly.prototype.description = 'Make shiz draggable';

  function NoFloDraggabilly() {
    this.dragend = __bind(this.dragend, this);
    this.dragmove = __bind(this.dragmove, this);
    this.dragstart = __bind(this.dragstart, this);
    this.subscribe = __bind(this.subscribe, this);
    this.options = {};
    this.inPorts = {
      container: new noflo.Port('object'),
      options: new noflo.Port,
      element: new noflo.Port('object')
    };
    this.outPorts = {
      start: new noflo.ArrayPort('object'),
      movex: new noflo.ArrayPort('number'),
      movey: new noflo.ArrayPort('number'),
      end: new noflo.ArrayPort('object')
    };
    this.inPorts.container.on("data", (function(_this) {
      return function(data) {
        return _this.setOptions({
          containment: data
        });
      };
    })(this));
    this.inPorts.options.on("data", (function(_this) {
      return function(data) {
        return _this.setOptions(data);
      };
    })(this));
    this.inPorts.element.on('data', (function(_this) {
      return function(element) {
        return _this.subscribe(element);
      };
    })(this));
  }

  NoFloDraggabilly.prototype.subscribe = function(element) {
    var draggie;
    draggie = this.draggie = new Draggabilly(element, this.options);
    draggie.on('dragStart', this.dragstart);
    draggie.on('dragMove', this.dragmove);
    return draggie.on('dragEnd', this.dragend);
  };

  NoFloDraggabilly.prototype.setOptions = function(options) {
    var key, value, _results;
    if (typeof options !== "object") {
      throw new Error("Options is not an object");
    }
    _results = [];
    for (key in options) {
      if (!__hasProp.call(options, key)) continue;
      value = options[key];
      _results.push(this.options[key] = value);
    }
    return _results;
  };

  NoFloDraggabilly.prototype.dragstart = function(draggie, event, pointer) {
    this.outPorts.start.send(event);
    this.outPorts.start.disconnect();
    this.outPorts.movex.send(draggie.position.x);
    return this.outPorts.movey.send(draggie.position.y);
  };

  NoFloDraggabilly.prototype.dragmove = function(draggie, event, pointer) {
    this.outPorts.movex.send(draggie.position.x);
    return this.outPorts.movey.send(draggie.position.y);
  };

  NoFloDraggabilly.prototype.dragend = function(draggie, event, pointer) {
    if (this.outPorts.movex.isConnected()) {
      this.outPorts.movex.disconnect();
    }
    if (this.outPorts.movey.isConnected()) {
      this.outPorts.movey.disconnect();
    }
    this.outPorts.end.send(event);
    return this.outPorts.end.disconnect();
  };

  return NoFloDraggabilly;

})(noflo.Component);

exports.getComponent = function() {
  return new NoFloDraggabilly;
};

});
require.register("forresto-noflo-gum/index.js", function(exports, require, module){
/* nothing here */
});
require.register("forresto-noflo-gum/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-gum","description":"getUserMedia components for getting webcam and mic into NoFlo","author":"Forrest Oliphant <forrest@sembiki.com>","repo":"forresto/noflo-gum","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["components/GetUserMedia.coffee","index.js"],"json":["component.json"],"noflo":{"components":{"GetUserMedia":"components/GetUserMedia.coffee"}}}');
});
require.register("forresto-noflo-gum/components/GetUserMedia.js", function(exports, require, module){
var GetUserMedia, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

GetUserMedia = (function(_super) {
  __extends(GetUserMedia, _super);

  GetUserMedia.prototype.description = 'initialize camera and/or microphone';

  GetUserMedia.prototype.icon = 'video-camera';

  function GetUserMedia() {
    this.video = true;
    this.audio = false;
    this.stream = null;
    this.inPorts = {
      start: new noflo.Port('bang'),
      stop: new noflo.Port('bang'),
      video: new noflo.Port('boolean'),
      audio: new noflo.Port('boolean')
    };
    this.outPorts = {
      stream: new noflo.Port('object'),
      url: new noflo.Port('string'),
      error: new noflo.Port('object')
    };
    this.inPorts.start.on('data', (function(_this) {
      return function() {
        return _this.resetStream();
      };
    })(this));
    this.inPorts.stop.on('data', (function(_this) {
      return function() {
        return _this.stopStream();
      };
    })(this));
    this.inPorts.video.on('data', (function(_this) {
      return function(video) {
        _this.video = video;
        if (_this.stream) {
          return _this.resetStream();
        }
      };
    })(this));
    this.inPorts.audio.on('data', (function(_this) {
      return function(audio) {
        _this.audio = audio;
        if (_this.stream) {
          return _this.resetStream();
        }
      };
    })(this));
    this.stopStream = (function(_this) {
      return function() {
        if (_this.stream) {
          if (_this.stream.stop) {
            _this.stream.stop();
          }
          return _this.stream = null;
        }
      };
    })(this);
    this.resetStream = (function(_this) {
      return function() {
        _this.stopStream();
        if (!navigator.getUserMedia) {
          navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || null;
        }
        if (!navigator.getUserMedia) {
          _this.error('getUserMedia not available in this browser.');
          return;
        }
        return navigator.getUserMedia({
          video: _this.video,
          audio: _this.audio
        }, function(stream) {
          _this.stream = stream;
          if (!window.URL) {
            window.URL = window.webkitURL || window.msURL || window.oURL || null;
          }
          if (_this.outPorts.url.isAttached()) {
            if (window.URL.createObjectURL) {
              _this.outPorts.url.send(window.URL.createObjectURL(stream));
            } else {
              _this.outPorts.url.send(stream);
            }
          }
          if (_this.outPorts.stream.isAttached()) {
            return _this.outPorts.stream.send(stream);
          }
        }, function() {
          return _this.error('Access denied or no device available.');
        });
      };
    })(this);
  }

  GetUserMedia.prototype.error = function(msg) {
    if (this.outPorts.error.isAttached()) {
      this.outPorts.error.send(new Error(msg));
      this.outPorts.error.disconnect();
      return;
    }
    throw new Error(msg);
  };

  GetUserMedia.prototype.shutdown = function() {
    return this.stopStream();
  };

  return GetUserMedia;

})(noflo.Component);

exports.getComponent = function() {
  return new GetUserMedia;
};

});
require.register("forresto-noflo-seriously/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-seriously.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

// require.alias("forresto-noflo-seriously/vendor/seriously.js", "seriously");
});
require.register("forresto-noflo-seriously/vendor/seriously.js", function(exports, require, module){
/*jslint devel: true, bitwise: true, browser: true, white: true, nomen: true, plusplus: true, maxerr: 50, indent: 4, todo: true */
/*global Float32Array, Uint8Array, Uint16Array, WebGLTexture, HTMLInputElement, HTMLSelectElement, HTMLElement, WebGLFramebuffer, HTMLCanvasElement, WebGLRenderingContext, define, module, exports */
(function (root, factory) {
	'use strict';
	if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like enviroments that support module.exports,
		// like Node.
		module.exports = factory(root);
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define('seriously', function () {
			var Seriously = factory(root);
			if (!root.Seriously) {
				root.Seriously = Seriously;
			}
			return Seriously;
		});
	} else {
		// Browser globals
		root.Seriously = factory(root);
	}
}(this, function (window, undefined) {
	'use strict';

	var document = window.document,
		console = window.console,

	/*
		Global environment variables
	*/

	testContext,
	colorElement,
	incompatibility,
	seriousEffects = {},
	seriousTransforms = {},
	timeouts = [],
	allEffectsByHook = {},
	allTransformsByHook = {},
	identity,
	nop = function () {},

	/*
		Global reference variables
	*/

	// http://www.w3.org/TR/css3-color/#svg-color
	colorNames = {
		transparent: [0, 0, 0, 0],
		red: [1, 0, 0, 1],
		green: [0, 1, 0, 1],
		blue: [0, 0, 1, 1],
		white: [1, 1, 1, 1]
	},

	vectorFields = ['x', 'y', 'z', 'w'],
	colorFields = ['r', 'g', 'b', 'a'],

	/*
		utility functions
	*/

	/*
	mat4 matrix functions borrowed from gl-matrix by toji
	https://github.com/toji/gl-matrix
	License: https://github.com/toji/gl-matrix/blob/master/LICENSE.md
	*/
	mat4 = {
		/*
		 * mat4.frustum
		 * Generates a frustum matrix with the given bounds
		 *
		 * Params:
		 * left, right - scalar, left and right bounds of the frustum
		 * bottom, top - scalar, bottom and top bounds of the frustum
		 * near, far - scalar, near and far bounds of the frustum
		 * dest - Optional, mat4 frustum matrix will be written into
		 *
		 * Returns:
		 * dest if specified, a new mat4 otherwise
		 */
		frustum: function (left, right, bottom, top, near, far, dest) {
			if(!dest) { dest = mat4.create(); }
			var rl = (right - left),
				tb = (top - bottom),
				fn = (far - near);
			dest[0] = (near*2) / rl;
			dest[1] = 0;
			dest[2] = 0;
			dest[3] = 0;
			dest[4] = 0;
			dest[5] = (near*2) / tb;
			dest[6] = 0;
			dest[7] = 0;
			dest[8] = (right + left) / rl;
			dest[9] = (top + bottom) / tb;
			dest[10] = -(far + near) / fn;
			dest[11] = -1;
			dest[12] = 0;
			dest[13] = 0;
			dest[14] = -(far*near*2) / fn;
			dest[15] = 0;
			return dest;
		},

		perspective: function (fovy, aspect, near, far, dest) {
			var top = near*Math.tan(fovy*Math.PI / 360.0),
				right = top*aspect;
			return mat4.frustum(-right, right, -top, top, near, far, dest);
		},
		multiply: function (dest, mat, mat2) {
			// Cache the matrix values (makes for huge speed increases!)
			var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
				a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
				a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
				a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

			// Cache only the current line of the second matrix
			b0 = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];
			dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			b0 = mat2[4];
			b1 = mat2[5];
			b2 = mat2[6];
			b3 = mat2[7];
			dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			b0 = mat2[8];
			b1 = mat2[9];
			b2 = mat2[10];
			b3 = mat2[11];
			dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			b0 = mat2[12];
			b1 = mat2[13];
			b2 = mat2[14];
			b3 = mat2[15];
			dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
			dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
			dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
			dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

			return dest;
		},
		identity: function (dest) {
			dest[0] = 1;
			dest[1] = 0;
			dest[2] = 0;
			dest[3] = 0;
			dest[4] = 0;
			dest[5] = 1;
			dest[6] = 0;
			dest[7] = 0;
			dest[8] = 0;
			dest[9] = 0;
			dest[10] = 1;
			dest[11] = 0;
			dest[12] = 0;
			dest[13] = 0;
			dest[14] = 0;
			dest[15] = 1;
			return dest;
		},
		copy: function (out, a) {
			out[0] = a[0];
			out[1] = a[1];
			out[2] = a[2];
			out[3] = a[3];
			out[4] = a[4];
			out[5] = a[5];
			out[6] = a[6];
			out[7] = a[7];
			out[8] = a[8];
			out[9] = a[9];
			out[10] = a[10];
			out[11] = a[11];
			out[12] = a[12];
			out[13] = a[13];
			out[14] = a[14];
			out[15] = a[15];
			return out;
		}
	},

	requestAnimationFrame = (function (){
		var lastTime = 0;
		return  window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function (callback) {
					var currTime, timeToCall, id;

					function timeoutCallback() {
						callback(currTime + timeToCall);
					}

					currTime = new Date().getTime();
					timeToCall = Math.max(0, 16 - (currTime - lastTime));
					id = window.setTimeout(timeoutCallback, timeToCall);
					lastTime = currTime + timeToCall;
					return id;
				};
	}()),

	cancelAnimFrame = (function (){
		return  window.cancelAnimationFrame ||
				window.webkitCancelAnimationFrame ||
				window.mozCancelAnimationFrame ||
				window.oCancelAnimationFrame ||
				window.msCancelAnimationFrame ||
				function (id) {
					window.cancelTimeout(id);
				};
	}()),

	reservedNames = ['source', 'target', 'effect', 'effects', 'benchmark', 'incompatible',
		'util', 'ShaderProgram', 'inputValidators', 'save', 'load',
		'plugin', 'removePlugin', 'alias', 'removeAlias', 'stop', 'go',
		'destroy', 'isDestroyed'];

	function getElement(input, tags) {
		var element,
			tag;
		if (typeof input === 'string') {
			//element = document.getElementById(input) || document.getElementsByTagName(input)[0];
			element = document.querySelector(input);
		} else if (!input) {
			return false;
		}

		if (input.tagName) {
			element = input;
		}

		if (!element) {
			return input;
		}

		tag = element.tagName.toLowerCase();
		if (tags && tags.indexOf(tag) < 0) {
			return input;
		}

		return element;
	}

	function extend(dest, src) {
		var property,
			descriptor;

		//todo: are we sure this is safe?
		if (dest.prototype && src.prototype && dest.prototype !== src.prototype) {
			extend(dest.prototype, src.prototype);
		}

		for (property in src) {
			if (src.hasOwnProperty(property)) {
				descriptor = Object.getOwnPropertyDescriptor(src, property);

				if (descriptor.get || descriptor.set) {
					Object.defineProperty(dest, property, {
						configurable: true,
						enumerable: true,
						get: descriptor.get,
						set: descriptor.set
					});
				} else {
					dest[property] = src[property];
				}
			}
		}

		return dest;
	}

	//http://www.w3.org/TR/css3-color/#hsl-color
	function hslToRgb(h, s, l, a, out) {
		function hueToRgb(m1, m2, h) {
			h = h % 1;
			if (h < 0) {
				h += 1;
			}
			if (h < 1 / 6) {
				return m1 + (m2 - m1) * h * 6;
			}
			if (h < 1 / 2) {
				return m2;
			}
			if (h < 2 / 3) {
				return m1 + (m2 - m1) * (2/3 - h) * 6;
			}
			return m1;
		}

		var m1, m2;
		if (l < 0.5) {
			m2 = l * (s + 1);
		} else {
			m2 = l + s - l * s;
		}
		m1 = l * 2 - m2;

		if (!out) {
			out = [];
		}

		out[0] = hueToRgb(m1, m2, h + 1/3);
		out[1] = hueToRgb(m1, m2, h);
		out[2] = hueToRgb(m1, m2, h - 1/3);
		out[3] = a;

		return out;
	}

	/*
	faster than setTimeout(fn, 0);
	http://dbaron.org/log/20100309-faster-timeouts
	*/
	function setTimeoutZero(fn) {
		/*
		Workaround for postMessage bug in Firefox if the page is loaded from the file system
		https://bugzilla.mozilla.org/show_bug.cgi?id=740576
		Should run fine, but maybe a few milliseconds slower per frame.
		*/
		function timeoutFunction() {
			if (timeouts.length) {
				(timeouts.shift())();
			}
		}

		if (typeof fn !== 'function') {
			throw 'setTimeoutZero argument is not a function';
		}

		timeouts.push(fn);
		if (window.location.protocol === 'file:') {
			setTimeout(timeoutFunction, 0);
			return;
		}

		window.postMessage('seriously-timeout-message', window.location);
	}

	function isArrayLike(obj) {
		return Array.isArray(obj) ||
			(obj && obj.BYTES_PER_ELEMENT && 'length' in obj);
	}

	window.addEventListener('message', function (event) {
		if (event.source === window && event.data === 'seriously-timeout-message') {
			event.stopPropagation();
			if (timeouts.length > 0) {
				var fn = timeouts.shift();
				fn();
			}
		}
	}, true);

	function getTestContext() {
		var canvas;

		if (testContext || !window.WebGLRenderingContext) {
			return testContext;
		}

		canvas = document.createElement('canvas');
		try {
			testContext = canvas.getContext('experimental-webgl');
			canvas.addEventListener('webglcontextlost', function (event) {
				/*
				If/When context is lost, just clear testContext and create
				a new one the next time it's needed
				*/
				event.preventDefault();
				if (testContext && testContext.canvas === this) {
					testContext = undefined;
				}
			}, false);
		} catch (webglError) {
			console.log('Unable to access WebGL.');
		}

		return testContext;
	}

	function checkSource(source) {
		var element, canvas, ctx, texture;

		//todo: don't need to create a new array every time we do this
		element = getElement(source, ['img', 'canvas', 'video']);
		if (!element) {
			return false;
		}

		canvas = document.createElement('canvas');
		if (!canvas) {
			console.log('Browser does not support canvas or Seriously.js');
			return false;
		}

		ctx = getTestContext();

		if (ctx) {
			texture = ctx.createTexture();
			ctx.bindTexture(ctx.TEXTURE_2D, texture);

			try {
				ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, ctx.RGBA, ctx.UNSIGNED_BYTE, element);
			} catch (textureError) {
				if (textureError.code === window.DOMException.SECURITY_ERR) {
					console.log('Unable to access cross-domain image');
				} else {
					console.log('Error: ' + textureError.message);
				}
				ctx.deleteTexture(texture);
				return false;
			}
			ctx.deleteTexture(texture);
		} else {
			ctx = canvas.getContext('2d');
			try {
				ctx.drawImage(element, 0, 0);
				ctx.getImageData(0, 0, 1, 1);
			} catch (drawImageError) {
				if (drawImageError.code === window.DOMException.SECURITY_ERR) {
					console.log('Unable to access cross-domain image');
				} else {
					console.log('Error: ' + drawImageError.message);
				}
				return false;
			}
		}

		// This method will return a false positive for resources that aren't
		// actually images or haven't loaded yet

		return true;
	}

	function validateInputSpecs(effect) {
		var reserved = ['render', 'initialize', 'original', 'plugin', 'alias',
			'prototype', 'destroy', 'isDestroyed'],
			input,
			name;

		function nop(value) {
			return value;
		}

		for (name in effect.inputs) {
			if (effect.inputs.hasOwnProperty(name)) {
				if (reserved.indexOf(name) >= 0 || Object.prototype[name]) {
					throw 'Reserved effect input name: ' + name;
				}

				input = effect.inputs[name];

				if (isNaN(input.min)) {
					input.min = -Infinity;
				}

				if (isNaN(input.max)) {
					input.max = Infinity;
				}

				if (isNaN(input.minCount)) {
					input.minCount = -Infinity;
				}

				if (isNaN(input.maxCount)) {
					input.maxCount = Infinity;
				}

				if (isNaN(input.step)) {
					input.step = 0;
				}

				if (input.defaultValue === undefined || input.defaultValue === null) {
					if (input.type === 'number') {
						input.defaultValue = Math.min(Math.max(0, input.min), input.max);
					} else if (input.type === 'color') {
						input.defaultValue = [0, 0, 0, 0];
					} else if (input.type === 'enum') {
						if (input.options && input.options.length) {
							input.defaultValue = input.options[0];
						} else {
							input.defaultValue = '';
						}
					} else if (input.type === 'boolean') {
						input.defaultValue = false;
					} else {
						input.defaultValue = '';
					}
				}

				if (input.type === 'vector') {
					if (input.dimensions < 2) {
						input.dimensions = 2;
					} else if (input.dimensions > 4) {
						input.dimensions = 4;
					} else if (!input.dimensions || isNaN(input.dimensions)) {
						input.dimensions = 4;
					} else {
						input.dimensions = Math.round(input.dimensions);
					}
				} else {
					input.dimensions = 1;
				}

				input.shaderDirty = !!input.shaderDirty;

				if (typeof input.validate !== 'function') {
					input.validate = Seriously.inputValidators[input.type] || nop;
				}

				if (!effect.defaultImageInput && input.type === 'image') {
					effect.defaultImageInput = name;
				}
			}
		}
	}

	/*
		helper Classes
	*/

	function FrameBuffer(gl, width, height, options) {
		var frameBuffer,
			renderBuffer,
			tex,
			status,
			useFloat = options === true ? options : (options && options.useFloat);

		useFloat = false;//useFloat && !!gl.getExtension("OES_texture_float"); //useFloat is not ready!
		if (useFloat) {
			this.type = gl.FLOAT;
		} else {
			this.type = gl.UNSIGNED_BYTE;
		}

		frameBuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

		if (options && options.texture) {
			this.texture = options.texture;
			gl.bindTexture(gl.TEXTURE_2D, this.texture);
			this.ownTexture = false;
		} else {
			this.texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, this.texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			this.ownTexture = true;
		}

		try {
			if (this.type === gl.FLOAT) {
				tex = new Float32Array(width * height * 4);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, tex);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
				this.type = gl.UNSIGNED_BYTE;
			}
		} catch (e) {
			// Null rejected
			this.type = gl.UNSIGNED_BYTE;
			tex = new Uint8Array(width * height * 4);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tex);
		}

		renderBuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderBuffer);

		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

		status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

		if (status === gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
			throw('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
		}

		if (status === gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
			throw('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
		}

		if (status === gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {
			throw('Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
		}

		if (status === gl.FRAMEBUFFER_UNSUPPORTED) {
			throw('Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED');
		}

		if (status !== gl.FRAMEBUFFER_COMPLETE) {
			throw('Incomplete framebuffer: ' + status);
		}

		//clean up
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		this.gl = gl;
		this.frameBuffer = frameBuffer;
		this.renderBuffer = renderBuffer;
		this.width = width;
		this.height = height;
	}

	FrameBuffer.prototype.resize = function (width, height) {
		var gl = this.gl;

		if (this.width === width && this.height === height) {
			return;
		}

		this.width = width;
		this.height = height;

		if (!gl) {
			return;
		}

		gl.bindTexture(gl.TEXTURE_2D, this.texture);
		gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);

		//todo: handle float
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);

		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	};

	FrameBuffer.prototype.destroy = function () {
		var gl = this.gl;

		if (gl) {
			gl.deleteFramebuffer(this.frameBuffer);
			gl.deleteRenderbuffer(this.renderBuffer);
			if (this.ownTexture) {
				gl.deleteTexture(this.texture);
			}
		}

		delete this.frameBuffer;
		delete this.renderBuffer;
		delete this.texture;
		delete this.gl;
	};

	/* ShaderProgram - utility class for building and accessing WebGL shaders */

	function ShaderProgram(gl, vertexShaderSource, fragmentShaderSource) {
		var program, vertexShader, fragmentShader,
			programError = '',
			shaderError,
			i, l,
			obj;

		function compileShader(source, fragment) {
			var shader, i;
			if (fragment) {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else {
				shader = gl.createShader(gl.VERTEX_SHADER);
			}

			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				source = source.split(/[\n\r]/);
				for (i = 0; i < source.length; i++) {
					source[i] = (i + 1) + ":\t" + source[i];
				}
				console.log(source.join('\n'));
				throw 'Shader error: ' + gl.getShaderInfoLog(shader);
			}

			return shader;
		}

		function makeShaderSetter(info, loc) {
			if (info.type === gl.SAMPLER_2D) {
				return function (value) {
					info.glTexture = gl['TEXTURE' + value];
					gl.uniform1i(loc, value);
				};
			}

			if (info.type === gl.BOOL|| info.type === gl.INT) {
				if (info.size > 1) {
					return function (value) {
						gl.uniform1iv(loc, value);
					};
				}

				return function (value) {
					gl.uniform1i(loc, value);
				};
			}

			if (info.type === gl.FLOAT) {
				if (info.size > 1) {
					return function (value) {
						gl.uniform1fv(loc, value);
					};
				}

				return function (value) {
					gl.uniform1f(loc, value);
				};
			}

			if (info.type === gl.FLOAT_VEC2) {
				return function (obj) {
					gl.uniform2f(loc, obj[0], obj[1]);
				};
			}

			if (info.type === gl.FLOAT_VEC3) {
				return function (obj) {
					gl.uniform3f(loc, obj[0], obj[1], obj[2]);
				};
			}

			if (info.type === gl.FLOAT_VEC4) {
				return function (obj) {
					gl.uniform4f(loc, obj[0], obj[1], obj[2], obj[3]);
				};
			}

			if (info.type === gl.FLOAT_MAT3) {
				return function (mat3) {
					gl.uniformMatrix3fv(loc, false, mat3);
				};
			}

			if (info.type === gl.FLOAT_MAT4) {
				return function (mat4) {
					gl.uniformMatrix4fv(loc, false, mat4);
				};
			}

			throw "Unknown shader uniform type: " + info.type;
		}

		function makeShaderGetter(loc) {
			return function () {
				return gl.getUniform(program, loc);
			};
		}

		vertexShader = compileShader(vertexShaderSource);
		fragmentShader = compileShader(fragmentShaderSource, true);

		program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		shaderError = gl.getShaderInfoLog(vertexShader);
		if (shaderError) {
			programError += 'Vertex shader error: ' + shaderError + "\n";
		}
		gl.attachShader(program, fragmentShader);
		shaderError = gl.getShaderInfoLog(fragmentShader);
		if (shaderError) {
			programError += 'Fragment shader error: ' + shaderError + "\n";
		}
		gl.linkProgram(program);

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			programError += gl.getProgramInfoLog(program);
			gl.deleteProgram(program);
			gl.deleteShader(vertexShader);
			gl.deleteShader(fragmentShader);
			throw 'Could not initialise shader: ' + programError;
		}

		gl.useProgram(program);

		this.uniforms = {};

		l = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		for (i = 0; i < l; ++i) {
			obj = {
				info: gl.getActiveUniform(program, i)
			};

			obj.name = obj.info.name;
			obj.loc = gl.getUniformLocation(program, obj.name);
			obj.set = makeShaderSetter(obj.info, obj.loc);
			obj.get = makeShaderGetter(obj.loc);
			this.uniforms[obj.name] = obj;

			if (!this[obj.name]) {
				//for convenience
				this[obj.name] = obj;
			}
		}

		this.attributes = {};
		this.location = {};
		l = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
		for (i = 0; i < l; ++i) {
			obj = {
				info: gl.getActiveAttrib(program, i)
			};

			obj.name = obj.info.name;
			obj.location = gl.getAttribLocation(program, obj.name);
			this.attributes[obj.name] = obj;
			this.location[obj.name] = obj.location;
		}

		this.gl = gl;
		this.program = program;

		this.destroy = function () {
			var i;

			if (gl) {
				gl.deleteProgram(program);
				gl.deleteShader(vertexShader);
				gl.deleteShader(fragmentShader);
			}

			for (i in this) {
				if (this.hasOwnProperty(i)) {
					delete this[i];
				}
			}

			program = null;
			vertexShader = null;
			fragmentShader = null;
		};
	}

	ShaderProgram.prototype.use = function () {
		this.gl.useProgram(this.program);
	};

	/*
		main class: Seriously
	*/

	function Seriously(options) {

		//if called without 'new', make a new object and return that
		if (window === this || !(this instanceof Seriously)) {
			return new Seriously(options);
		}

		//initialize object, private properties
		var seriously = this,
			nodes = [],
			nodesById = {},
			nodeId = 0,
			sources = [],
			targets = [],
			transforms = [],
			effects = [],
			aliases = {},
			preCallbacks = [],
			postCallbacks = [],
			glCanvas,
			gl,
			rectangleModel,
			baseShader,
			baseVertexShader, baseFragmentShader,
			Node, SourceNode, EffectNode, TransformNode, TargetNode,
			Effect, Source, Transform, Target,
			auto = false,
			isDestroyed = false,
			rafId;

		function makeGlModel(shape, gl) {
			var vertex, index, texCoord;

			if (!gl) {
				return false;
			}

			vertex = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertex);
			gl.bufferData(gl.ARRAY_BUFFER, shape.vertices, gl.STATIC_DRAW);
			vertex.size = 3;

			index = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);

			texCoord = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, texCoord);
			gl.bufferData(gl.ARRAY_BUFFER, shape.coords, gl.STATIC_DRAW);
			texCoord.size = 2;

			return {
				vertex: vertex,
				index: index,
				texCoord: texCoord,
				length: shape.indices.length,
				mode: shape.mode || gl.TRIANGLES
			};
		}

		function buildRectangleModel(gl) {
			var shape = {};

			shape.vertices = new Float32Array([
				-1, -1, 0,
				1, -1, 0,
				1, 1, 0,
				-1, 1, 0
			]);

			shape.indices = new Uint16Array([
				0, 1, 2,
				0, 2, 3	// Front face
			]);

			shape.coords = new Float32Array([
				0, 0,
				1, 0,
				1, 1,
				0, 1
			]);

			return makeGlModel(shape, gl);
		}

		function attachContext(context) {
			var i, node;

			gl = context;
			glCanvas = context.canvas;

			rectangleModel = buildRectangleModel(gl);

			baseShader = new ShaderProgram(gl, baseVertexShader, baseFragmentShader);

			for (i = 0; i < effects.length; i++) {
				node = effects[i];

				node.gl = gl;

				if (node.initialized) {
					node.buildShader();
				}
			}

			for (i = 0; i < sources.length; i++) {
				node = sources[i];
				node.initialize();
			}

			for (i = 0; i < targets.length; i++) {
				node = targets[i];

				if (!node.model) {
					node.model = rectangleModel;
				}

				//todo: initialize frame buffer if not main canvas
			}
		}

		/*
		runs on every frame, as long as there are media sources (img, video, canvas, etc.) to check,
		dirty target nodes or pre/post callbacks to run. any sources that are updated are set to dirty,
		forcing all dependent nodes to render
		*/
		function renderDaemon() {
			var i, node, media,
				keepRunning = false;

			rafId = null;

			if (preCallbacks.length) {
				keepRunning = true;
				for (i = 0; i < preCallbacks.length; i++) {
					preCallbacks[i].call(seriously);
				}
			}

			if (sources && sources.length) {
				keepRunning = true;
				for (i = 0; i < sources.length; i++) {
					node = sources[i];

					media = node.source;
					if (node.lastRenderTime === undefined ||
							node.dirty ||
							media.currentTime !== undefined && node.lastRenderTime !== media.currentTime) {
						node.dirty = false;
						node.setDirty();
					}
				}
			}

			for (i = 0; i < targets.length; i++) {
				node = targets[i];
				if (node.auto && node.dirty) {
					node.render();
				}
			}

			if (postCallbacks.length) {
				keepRunning = true;
				for (i = 0; i < postCallbacks.length; i++) {
					postCallbacks[i].call(seriously);
				}
			}

			//rafId may have been set again by a callback or in target.setDirty()
			if (keepRunning && !rafId) {
				rafId = requestAnimationFrame(renderDaemon);
			}
		}

		function draw(shader, model, uniforms, frameBuffer, node, options) {
			var numTextures = 0,
				name, value, shaderUniform,
				width, height,
				nodeGl = (node && node.gl) || gl;

			if (!nodeGl) {
				return;
			}

			if (node) {
				width = options && options.width || node.width || nodeGl.canvas.width;
				height = options && options.height || node.height || nodeGl.canvas.height;
			} else {
				width = options && options.width || nodeGl.canvas.width;
				height = options && options.height || nodeGl.canvas.height;
			}

			shader.use();

			nodeGl.viewport(0, 0, width, height);

			nodeGl.bindFramebuffer(nodeGl.FRAMEBUFFER, frameBuffer);

			/* todo: do this all only once at the beginning, since we only have one model? */
			nodeGl.enableVertexAttribArray(shader.location.position);
			nodeGl.enableVertexAttribArray(shader.location.texCoord);

			if (model.texCoord) {
				nodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.texCoord);
				nodeGl.vertexAttribPointer(shader.location.texCoord, model.texCoord.size, nodeGl.FLOAT, false, 0, 0);
			}

			nodeGl.bindBuffer(nodeGl.ARRAY_BUFFER, model.vertex);
			nodeGl.vertexAttribPointer(shader.location.position, model.vertex.size, nodeGl.FLOAT, false, 0, 0);

			nodeGl.bindBuffer(nodeGl.ELEMENT_ARRAY_BUFFER, model.index);

			//default for depth is disable
			if (options && options.depth) {
				gl.enable(gl.DEPTH_TEST);
			} else {
				gl.disable(gl.DEPTH_TEST);
			}

			//default for blend is enable
			if (!options || options.blend === undefined || options.blend) {
				gl.enable(gl.BLEND);
				gl.blendFunc(
					options && options.srcRGB || gl.SRC_ALPHA,
					options && options.dstRGB || gl.ONE_MINUS_SRC_ALPHA
				);

				/*
				gl.blendFuncSeparate(
					options && options.srcRGB || gl.SRC_ALPHA,
					options && options.dstRGB || gl.ONE_MINUS_SRC_ALPHA,
					options && options.srcAlpha || gl.SRC_ALPHA,
					options && options.dstAlpha || gl.DST_ALPHA
				);
				*/
				gl.blendEquation(options && options.blendEquation || gl.FUNC_ADD);
			} else {
				gl.disable(gl.BLEND);
			}

			/* set uniforms to current values */
			for (name in uniforms) {
				if (uniforms.hasOwnProperty(name)) {
					value = uniforms[name];
					shaderUniform = shader.uniforms[name];
					if (shaderUniform) {
						if (value instanceof WebGLTexture) {
							nodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures);
							nodeGl.bindTexture(nodeGl.TEXTURE_2D, value);
							shaderUniform.set(numTextures);
							numTextures++;
						} else if (value instanceof SourceNode ||
								value instanceof EffectNode ||
								value instanceof TransformNode) {
							if (value.texture) {
								nodeGl.activeTexture(nodeGl.TEXTURE0 + numTextures);
								nodeGl.bindTexture(nodeGl.TEXTURE_2D, value.texture);
								shaderUniform.set(numTextures);
								numTextures++;
							}
						} else if(value !== undefined && value !== null) {
							shaderUniform.set(value);
						}
					}
				}
			}

			//default for clear is true
			if (!options || options.clear === undefined || options.clear) {
				nodeGl.clearColor(0.0, 0.0, 0.0, 0.0);
				nodeGl.clear(nodeGl.COLOR_BUFFER_BIT | nodeGl.DEPTH_BUFFER_BIT);
			}

			// draw!
			nodeGl.drawElements(model.mode, model.length, nodeGl.UNSIGNED_SHORT, 0);

			//to protect other 3D libraries that may not remember to turn their depth tests on
			gl.enable(gl.DEPTH_TEST);
		}

		function findInputNode(source, options) {
			var node, i;

			if (source instanceof SourceNode ||
					source instanceof EffectNode ||
					source instanceof TransformNode) {
				node = source;
			} else if (source instanceof Effect ||
					source instanceof Source ||
					source instanceof Transform) {
				node = nodesById[source.id];

				if (!node) {
					throw 'Cannot connect a foreign node';
				}
			} else {
				if (typeof source === 'string' && isNaN(source)) {
					source = getElement(source, ['canvas', 'img', 'video']);
				}

				for (i = 0; i < sources.length; i++) {
					if (sources[i].source === source) {
						return sources[i];
					}
				}

				node = new SourceNode(source, options);
			}

			return node;
		}

		//trace back all sources to make sure we're not making a cyclical connection
		function traceSources(node, original) {
			var i,
				source,
				sources;

			if (!(node instanceof EffectNode) && !(node instanceof TransformNode)) {
				return false;
			}

			sources = node.sources;

			for (i in sources) {
				if (sources.hasOwnProperty(i)) {
					source = sources[i];

					if (source === original || traceSources(source, original)) {
						return true;
					}
				}
			}

			return false;
		}

		Node = function () {
			this.width = 1;
			this.height = 1;

			this.gl = gl;

			this.uniforms = {
				resolution: [this.width, this.height],
				transform: null
			};

			this.dirty = true;
			this.isDestroyed = false;

			this.seriously = seriously;

			this.id = nodeId;
			nodes.push(this);
			nodesById[nodeId] = this;
			nodeId++;
		};

		Node.prototype.setDirty = function () {
			//loop through all targets calling setDirty (depth-first)
			var i;

			if (!this.dirty) {
				this.dirty = true;
				if (this.targets) {
					for (i = 0; i < this.targets.length; i++) {
						this.targets[i].setDirty();
					}
				}
			}
		};

		Node.prototype.initFrameBuffer = function (useFloat) {
			if (gl) {
				this.frameBuffer = new FrameBuffer(gl, this.width, this.height, useFloat);
			}
		};

		Node.prototype.readPixels = function (x, y, width, height, dest) {

			if (!gl) {
				//todo: is this the best approach?
				throw 'Cannot read pixels until a canvas is connected';
			}

			//todo: check on x, y, width, height

			if (!this.frameBuffer) {
				this.initFrameBuffer();
			}

			//todo: should we render here?
			this.render();

			//todo: figure out formats and types
			if (dest === undefined) {
				dest = new Uint8Array(width * height * 4);
			} else if (!dest instanceof Uint8Array) {
				throw 'Incompatible array type';
			}

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer.frameBuffer); //todo: are we sure about this?
			gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, dest);

			return dest;
		};

		Node.prototype.resize = function () {
			var width,
				height;

			if (this.source) {
				width = this.source.width;
				height = this.source.height;
			} else if (this.sources && this.sources.source) {
				width = this.sources.source.width;
				height = this.sources.source.height;
			} else if (this.inputs && this.inputs.width) {
				width = this.inputs.width;
				height = this.inputs.height || width;
			} else if (this.inputs && this.inputs.height) {
				width = height = this.inputs.height;
			} else {
				//this node will be responsible for calculating its own size
				width = 1;
				height = 1;
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.setDirty();
			}

			if (this.uniforms && this.uniforms.resolution) {
				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;
			}

			if (this.frameBuffer && this.frameBuffer.resize) {
				this.frameBuffer.resize(width, height);
			}
		};

		Node.prototype.destroy = function () {
			var i;

			delete this.gl;
			delete this.seriously;

			//clear out uniforms
			for (i in this.uniforms) {
				if (this.uniforms.hasOwnProperty(i)) {
					delete this.uniforms[i];
				}
			}

			//clear out list of targets and disconnect each
			if (this.targets) {
				delete this.targets;
			}

			//clear out frameBuffer
			if (this.frameBuffer && this.frameBuffer.destroy) {
				this.frameBuffer.destroy();
				delete this.frameBuffer;
			}

			//remove from main nodes index
			i = nodes.indexOf(this);
			if (i >= 0) {
				nodes.splice(i, 1);
			}
			delete nodesById[this.id];

			this.isDestroyed = true;
		};

		Effect = function (effectNode) {
			var name, me = effectNode;

			function arrayToHex(color) {
				var i, val, s = '#';
				for (i = 0; i < 4; i++) {
					val = Math.min(255, Math.round(color[i] * 255 || 0));
					s += val.toString(16);
				}
				return s;
			}

			function setInput(inputName, input) {
				var lookup, value, effectInput, i;

				effectInput = me.effect.inputs[inputName];

				lookup = me.inputElements[inputName];

				if (typeof input === 'string' && isNaN(input)) {
					if (effectInput.type === 'enum') {
						if (effectInput.options && effectInput.options.filter) {
							i = String(input).toLowerCase();
							value = effectInput.options.filter(function (e) {
								return (typeof e === 'string' && e.toLowerCase() === i) ||
									(e.length && typeof e[0] === 'string' && e[0].toLowerCase() === i);
							});

							value = value.length;
						}

						if (!value) {
							input = getElement(input, ['select']);
						}

					} else if (effectInput.type === 'number' || effectInput.type === 'boolean') {
						input = getElement(input, ['input', 'select']);
					} else if (effectInput.type === 'image') {
						input = getElement(input, ['canvas', 'img', 'video']);
					}
					//todo: color? date/time?
				}

				if (input instanceof HTMLInputElement || input instanceof HTMLSelectElement) {
					value = input.value;

					if (lookup && lookup.element !== input) {
						lookup.element.removeEventListener('change', lookup.listener, true);
						lookup.element.removeEventListener('input', lookup.listener, true);
						delete me.inputElements[inputName];
						lookup = null;
					}

					if (!lookup) {
						lookup = {
							element: input,
							listener: (function (name, element) {
								return function () {
									var oldValue, newValue;

									if (input.type === 'checkbox') {
										//special case for check box
										oldValue = input.checked;
									} else {
										oldValue = element.value;
									}
									newValue = me.setInput(name, oldValue);

									//special case for color type
									if (effectInput.type === 'color') {
										newValue = arrayToHex(newValue);
									}

									//if input validator changes our value, update HTML Element
									//todo: make this optional...somehow
									if (newValue !== oldValue) {
										element.value = newValue;
									}
								};
							}(inputName, input))
						};

						me.inputElements[inputName] = lookup;
						if (input.type === 'range') {
							input.addEventListener('input', lookup.listener, true);
							input.addEventListener('change', lookup.listener, true);
						} else {
							input.addEventListener('change', lookup.listener, true);
						}
					}

					if (lookup && input.type === 'checkbox') {
						value = input.checked;
					}
				} else {
					if (lookup) {
						lookup.element.removeEventListener('change', lookup.listener, true);
						lookup.element.removeEventListener('input', lookup.listener, true);
						delete me.inputElements[inputName];
					}
					value = input;
				}

				me.setInput(inputName, value);
				return me.inputs[inputName];
			}

			function makeImageSetter(inputName) {
				return function (value) {
					var val = setInput(inputName, value);
					return val && val.pub;
				};
			}

			function makeImageGetter(inputName) {
				return function () {
					var val = me.inputs[inputName];
					return val && val.pub;
				};
			}

			function makeSetter(inputName) {
				return function (value) {
					return setInput(inputName, value);
				};
			}

			function makeGetter(inputName) {
				return function () {
					return me.inputs[inputName];
				};
			}

			//priveleged publicly accessible methods/setters/getters
			//todo: provide an alternate method
			for (name in me.effect.inputs) {
				if (me.effect.inputs.hasOwnProperty(name)) {
					if (this[name] === undefined) {
						if (me.effect.inputs[name].type === 'image') {
							Object.defineProperty(this, name, {
								configurable: true,
								enumerable: true,
								get: makeImageGetter(name),
								set: makeImageSetter(name)
							});
						} else {
							Object.defineProperty(this, name, {
								configurable: true,
								enumerable: true,
								get: makeGetter(name),
								set: makeSetter(name)
							});
						}
					} else {
						//todo: this is temporary. get rid of it.
						throw 'Cannot overwrite Seriously.' + name;
					}
				}
			}

			Object.defineProperties(this, {
				inputs: {
					enumerable: true,
					configurable: true,
					get: function () {
						return {
							source: {
								type: 'image'
							}
						};
					}
				},
				original: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.source;
					}
				},
				width: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.width;
					}
				},
				height: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.height;
					}
				},
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				}
			});

			this.render = function () {
				me.render();
				return this;
			};

			this.readPixels = function (x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest);
			};

			this.alias = function (inputName, aliasName) {
				me.alias(inputName, aliasName);
				return this;
			};

			this.matte = function (polygons) {
				me.matte(polygons);
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		EffectNode = function (hook, options) {
			var key, name, input;

			Node.call(this, options);

			this.effectRef = seriousEffects[hook];
			this.sources = {};
			this.targets = [];
			this.inputElements = {};
			this.dirty = true;
			this.shaderDirty = true;
			this.hook = hook;
			this.options = options;
			this.transform = null;

			if (this.effectRef.definition) {
				this.effect = this.effectRef.definition.call(this, options);
				/*
				todo: copy over inputs object separately in case some are specified
				in advance and some are specified in definition function
				*/
				for (key in this.effectRef) {
					if (this.effectRef.hasOwnProperty(key) && !this.effect[key]) {
						this.effect[key] = this.effectRef[key];
					}
				}
				if (this.effect.inputs !== this.effectRef.inputs) {
					validateInputSpecs(this.effect);
				}
			} else {
				this.effect = extend({}, this.effectRef);
			}

			//todo: set up frame buffer(s), inputs, transforms, stencils, draw method. allow plugin to override

			this.uniforms.transform = identity;
			this.inputs = {};
			for (name in this.effect.inputs) {
				if (this.effect.inputs.hasOwnProperty(name)) {
					input = this.effect.inputs[name];

					this.inputs[name] = input.defaultValue;
					if (input.uniform) {
						this.uniforms[input.uniform] = input.defaultValue;
					}
				}
			}

			if (gl) {
				this.buildShader();
			}

			this.inPlace = this.effect.inPlace;

			this.pub = new Effect(this);

			effects.push(this);

			allEffectsByHook[hook].push(this);
		};

		extend(EffectNode, Node);

		EffectNode.prototype.initialize = function () {
			if (!this.initialized) {
				var that = this;

				if (this.shape) {
					this.model = makeGlModel(this.shape, this.gl);
				} else {
					this.model = rectangleModel;
				}

				if (typeof this.effect.initialize === 'function') {
					this.effect.initialize.call(this, function () {
						that.initFrameBuffer(true);
					}, gl);
				} else {
					this.initFrameBuffer(true);
				}

				if (this.frameBuffer) {
					this.texture = this.frameBuffer.texture;
				}

				this.initialized = true;
			}
		};

		EffectNode.prototype.resize = function () {
			var i;

			Node.prototype.resize.call(this);

			if (this.effect.resize) {
				this.effect.resize.call(this);
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		EffectNode.prototype.setTarget = function (target) {
			var i;
			for (i = 0; i < this.targets.length; i++) {
				if (this.targets[i] === target) {
					return;
				}
			}

			this.targets.push(target);
		};

		EffectNode.prototype.removeTarget = function (target) {
			var i = this.targets && this.targets.indexOf(target);
			if (i >= 0) {
				this.targets.splice(i, 1);
			}
		};

		EffectNode.prototype.removeSource = function (source) {
			var i, pub = source && source.pub;

			for (i in this.inputs) {
				if (this.inputs.hasOwnProperty(i) &&
					(this.inputs[i] === source || this.inputs[i] === pub)) {
					this.inputs[i] = null;
				}
			}

			for (i in this.sources) {
				if (this.sources.hasOwnProperty(i) &&
					(this.sources[i] === source || this.sources[i] === pub)) {
					this.sources[i] = null;
				}
			}
		};

		EffectNode.prototype.buildShader = function () {
			var shader, effect = this.effect;
			if (this.shaderDirty) {
				if (effect.shader) {
					shader = effect.shader.call(this, this.inputs, {
						vertex: baseVertexShader,
						fragment: baseFragmentShader
					}, Seriously.util);

					if (shader instanceof ShaderProgram) {
						this.shader = shader;
					} else if (shader && shader.vertex && shader.fragment) {
						this.shader = new ShaderProgram(gl, shader.vertex, shader.fragment);
					} else {
						this.shader = baseShader;
					}
				} else {
					this.shader = baseShader;
				}

				this.shaderDirty = false;
			}
		};

		EffectNode.prototype.render = function () {
			var i,
				frameBuffer,
				effect = this.effect,
				that = this,
				inPlace;

			function drawFn(shader, model, uniforms, frameBuffer, node, options) {
				draw(shader, model, uniforms, frameBuffer, node || that, options);
			}

			if (!this.initialized) {
				this.initialize();
			}

			if (this.shaderDirty) {
				this.buildShader();
			}

			if (this.dirty) {
				for (i in this.sources) {
					if (this.sources.hasOwnProperty(i) &&
						(!effect.requires || effect.requires.call(this, i, this.inputs))) {

						//todo: set source texture
						//sourcetexture = this.sources[i].render() || this.sources[i].texture

						inPlace = typeof this.inPlace === 'function' ? this.inPlace(i) : this.inPlace;
						this.sources[i].render(!inPlace);
					}
				}

				if (this.frameBuffer) {
					frameBuffer = this.frameBuffer.frameBuffer;
				}

				if (typeof effect.draw === 'function') {
					effect.draw.call(this, this.shader, this.model, this.uniforms, frameBuffer, drawFn);
				} else if (frameBuffer) {
					draw(this.shader, this.model, this.uniforms, frameBuffer, this);
				}

				this.dirty = false;
			}

			return this.texture;
		};

		EffectNode.prototype.setInput = function (name, value) {
			var input, uniform,
				sourceKeys,
				source;

			if (this.effect.inputs.hasOwnProperty(name)) {
				input = this.effect.inputs[name];
				if (input.type === 'image') {
					//&& !(value instanceof Effect) && !(value instanceof Source)) {

					if (value) {
						value = findInputNode(value);

						if (value !== this.sources[name]) {
							if (this.sources[name]) {
								this.sources[name].removeTarget(this);
							}

							if (traceSources(value, this)) {
								throw 'Attempt to make cyclical connection.';
							}

							this.sources[name] = value;
							value.setTarget(this);
						}
					} else {
						delete this.sources[name];
						value = false;
					}

					uniform = this.sources[name];

					sourceKeys = Object.keys(this.sources);
					if (this.inPlace === true && sourceKeys.length === 1) {
						source = this.sources[sourceKeys[0]];
						this.uniforms.transform = source && source.cumulativeMatrix || identity;
					} else {
						this.uniforms.transform = identity;
					}

					this.resize();
				} else {
					value = input.validate.call(this, value, input, this.inputs[name]);
					uniform = value;
				}

				if (this.inputs[name] === value && input.type !== 'color' && input.type !== 'vector') {
					return value;
				}

				this.inputs[name] = value;

				if (input.uniform) {
					this.uniforms[input.uniform] = uniform;
				}

				if (input.shaderDirty) {
					this.shaderDirty = true;
				}

				this.setDirty();

				if (input.update) {
					input.update.call(this, value);
				}

				return value;
			}
		};

		EffectNode.prototype.alias = function (inputName, aliasName) {
			var that = this;

			if (reservedNames.indexOf(aliasName) >= 0) {
				throw aliasName + ' is a reserved name and cannot be used as an alias.';
			}

			if (this.effect.inputs.hasOwnProperty(inputName)) {
				if (!aliasName) {
					aliasName = inputName;
				}

				seriously.removeAlias(aliasName);

				aliases[aliasName] = {
					node: this,
					input: inputName
				};

				Object.defineProperty(seriously, aliasName, {
					configurable: true,
					enumerable: true,
					get: function () {
						return that.inputs[inputName];
					},
					set: function (value) {
						return that.setInput(inputName, value);
					}
				});
			}

			return this;
		};

		/*
		matte function to be assigned as a method to EffectNode and TargetNode
		*/
		EffectNode.prototype.matte = function (poly) {
			var polys,
				polygons = [],
				polygon,
				vertices = [],
				i, j, v,
				vert, prev,
				//triangles = [],
				shape = {};

			//detect whether it's multiple polygons or what
			function makePolygonsArray(poly) {
				if (!poly || !poly.length || !Array.isArray(poly)) {
					return [];
				}

				if (!Array.isArray(poly[0])) {
					return [poly];
				}

				if (Array.isArray(poly[0]) && !isNaN(poly[0][0])) {
					return [poly];
				}

				return poly;
			}

			function linesIntersect(a1, a2, b1, b2) {
				var ua_t, ub_t, u_b, ua, ub;
				ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
				ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
				u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
				if (u_b) {
					ua = ua_t / u_b;
					ub = ub_t / u_b;
					if (ua > 0 && ua <= 1 && ub > 0 && ub <= 1) {
						return {
							x: a1.x + ua * (a2.x - a1.x),
							y: a1.y + ua * (a2.y - a1.y)
						};
					}
				}
				return false;
			}

			function makeSimple(poly) {
				/*
				this uses a slow, naive approach to detecting line intersections.
				Use Bentley-Ottmann Algorithm
				see: http://softsurfer.com/Archive/algorithm_0108/algorithm_0108.htm#Bentley-Ottmann Algorithm
				see: https://github.com/tokumine/sweepline
				*/
				var i, j,
					edge1, edge2,
					intersect,
					intersections = [],
					newPoly,
					head, point,
					newPolygons,
					point1, point2;

				if (poly.simple) {
					return;
				}

				for (i = 0; i < poly.edges.length; i++) {
					edge1 = poly.edges[i];
					for (j = i + 1; j < poly.edges.length; j++) {
						edge2 = poly.edges[j];
						intersect = linesIntersect(edge1[0], edge1[1], edge2[0], edge2[1]);
						if (intersect) {
							intersect.edge1 = edge1;
							intersect.edge2 = edge2;
							intersections.push(intersect);
						}
					}
				}

				if (intersections.length) {
					newPolygons = [];

					for (i = 0; i < intersections.length; i++) {
						intersect = intersections[i];
						edge1 = intersect.edge1;
						edge2 = intersect.edge2;

						//make new points
						//todo: set ids for points
						point1 = {
							x: intersect.x,
							y: intersect.y,
							prev: edge1[0],
							next: edge2[1],
							id: vertices.length
						};
						poly.vertices.push(point1);
						vertices.push(point1);

						point2 = {
							x: intersect.x,
							y: intersect.y,
							prev: edge2[0],
							next: edge1[1],
							id: vertices.length
						};
						poly.vertices.push(point2);
						vertices.push(point1);

						//modify old points
						point1.prev.next = point1;
						point1.next.prev = point1;
						point2.prev.next = point2;
						point2.next.prev = point2;

						//don't bother modifying the old edges. we're just gonna throw them out
					}

					//make new polygons
					do {
						newPoly = {
							edges: [],
							vertices: [],
							simple: true
						};
						newPolygons.push(newPoly);
						point = poly.vertices[0];
						head = point;
						//while (point.next !== head && poly.vertices.length) {
						do {
							i = poly.vertices.indexOf(point);
							poly.vertices.splice(i, 1);
							newPoly.edges.push([point, point.next]);
							newPoly.vertices.push(point);
							point = point.next;
						} while (point !== head);
					} while (poly.vertices.length);

					//remove original polygon from list
					i = polygons.indexOf(poly);
					polygons.splice(i, 1);

					//add new polygons to list
					for (i = 0; i < newPolygons.length; i++) {
						polygons.push(newPolygons[i]);
					}
				} else {
					poly.simple = true;
				}
			}

			function clockWise(poly) {
				var p, q, n = poly.vertices.length,
					pv, qv, sum = 0;
				for (p = n - 1, q = 0; q < n; p = q, q++) {
					pv = poly.vertices[p];
					qv = poly.vertices[q];
					//sum += (next.x - v.x) * (next.y + v.y);
					//sum += (v.next.x + v.x) * (v.next.y - v.y);
					sum += pv.x * qv.y - qv.x * pv.y;
				}
				return sum > 0;
			}

			function triangulate(poly) {
				var v, points = poly.vertices,
					n, V = [], indices = [],
					nv, count, m, u, w,

					//todo: give these variables much better names
					a, b, c, s, t;

				function pointInTriangle(a, b, c, p) {
					var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy,
						cXap, bXcp, aXbp;

					ax = c.x - b.x;
					ay = c.y - b.y;
					bx = a.x - c.x;
					by = a.y - c.y;
					cx = b.x - a.x;
					cy = b.y - a.y;
					apx = p.x - a.x;
					apy = p.y - a.y;
					bpx = p.x - b.x;
					bpy = p.y - b.y;
					cpx = p.x - c.x;
					cpy = p.y - c.y;

					aXbp = ax * bpy - ay * bpx;
					cXap = cx * apy - cy * apx;
					bXcp = bx * cpy - by * cpx;

					return aXbp >= 0 && bXcp >=0 && cXap >=0;
				}

				function snip(u, v, w, n, V) {
					var p, a, b, c, point;
					a = points[V[u]];
					b = points[V[v]];
					c = points[V[w]];
					if (0 > (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) {
						return false;
					}
					for (p = 0; p < n; p++) {
						if (!(p === u || p === v || p === w)) {
							point = points[V[p]];
							if (pointInTriangle(a, b, c, point)) {
								return false;
							}
						}
					}
					return true;
				}

				//copy points
				//for (v = 0; v < poly.vertices.length; v++) {
				//	points.push(poly.vertices[v]);
				//}
				n = points.length;

				if (poly.clockWise) {
					for (v = 0; v < n; v++) {
						V[v] = v;
					}
				} else {
					for (v = 0; v < n; v++) {
						V[v] = (n - 1) - v;
					}
				}

				nv = n;
				count = 2 * nv;
				m = 0;
				v = nv - 1;
				while (nv > 2) {
					if ((count--) <= 0) {
						return indices;
					}

					u = v;
					if (nv <= u) {
						u = 0;
					}

					v = u + 1;
					if (nv <= v) {
						v = 0;
					}

					w = v + 1;
					if (nv < w) {
						w = 0;
					}

					if (snip(u, v, w, nv, V)) {
						a = V[u];
						b = V[v];
						c = V[w];
						if (poly.clockWise) {
							indices.push(points[a]);
							indices.push(points[b]);
							indices.push(points[c]);
						} else {
							indices.push(points[c]);
							indices.push(points[b]);
							indices.push(points[a]);
						}
						m++;
						for (s = v, t = v + 1; t < nv; s++, t++) {
							V[s] = V[t];
						}
						nv--;
						count = 2 * nv;
					}
				}

				polygon.indices = indices;
			}

			polys = makePolygonsArray(poly);

			for (i = 0; i < polys.length; i++) {
				poly = polys[i];
				prev = null;
				polygon = {
					vertices: [],
					edges: []
				};

				for (j = 0; j < poly.length; j++) {
					v = poly[j];
					if (typeof v ==='object' && !isNaN(v.x) && !isNaN(v.y)) {
						vert = {
							x: v.x,
							y: v.y,
							id: vertices.length
						};
					} else if (v.length >= 2 && !isNaN(v[0]) && !isNaN(v[1])) {
						vert = {
							x: v[0],
							y: v[1],
							id: vertices.length
						};
					}
					if (vert) {
						if (prev) {
							prev.next = vert;
							vert.prev = prev;
							vert.next = polygon.vertices[0];
							polygon.vertices[0].prev = vert;
						} else {
							polygon.head = vert;
							vert.next = vert;
							vert.prev = vert;
						}
						vertices.push(vert);
						polygon.vertices.push(vert);
						prev = vert;
					}
				}

				if (polygon.vertices.length > 2) {
					if (polygon.vertices.length === 3) {
						polygon.simple = true;
					}

					polygons.push(polygon);

					//save edges
					for (j = 0; j < polygon.vertices.length; j++) {
						vert = polygon.vertices[j];
						polygon.edges.push([
							vert, vert.next
						]);
					}
				}
			}

			for (i = polygons.length - 1; i >= 0; i--) {
				polygon = polygons[i];
				makeSimple(polygon);
			}

			for (i = 0; i < polygons.length; i++) {
				polygon = polygons[i];
				polygon.clockWise = clockWise(polygon);
				triangulate(polygon);
			}

			//build shape
			shape.vertices = [];
			shape.coords = [];
			for (i = 0; i < vertices.length; i++) {
				v = vertices[i];
				shape.vertices.push(v.x * 2 - 1);
				shape.vertices.push(v.y * -2 + 1);
				shape.vertices.push(-1);

				shape.coords.push(v.x);
				shape.coords.push(v.y * -1 + 1);
			}
			shape.vertices = new Float32Array(shape.vertices);
			shape.coords = new Float32Array(shape.coords);

			shape.indices = [];
			for (i = 0; i < polygons.length; i++) {
				polygon = polygons[i];
				for (j = 0; j < polygon.indices.length; j++) {
					v = polygon.indices[j];
					shape.indices.push(v.id);
					//shape.indices.push(v[1].id);
					//shape.indices.push(v[2].id);
				}
			}
			shape.indices = new Uint16Array(shape.indices);

			this.shape = shape;
			if (this.gl) {
				makeGlModel(shape, this.gl);
			}
		};

		EffectNode.prototype.destroy = function () {
			var i, key, item, hook = this.hook;

			//let effect destroy itself
			if (this.effect.destroy && typeof this.effect.destroy === 'function') {
				this.effect.destroy.call(this);
			}
			delete this.effect;

			//shader
			if (this.shader && this.shader.destroy && this.shader !== baseShader) {
				this.shader.destroy();
			}
			delete this.shader;

			//stop watching any input elements
			for (key in this.inputElements) {
				if (this.inputElements.hasOwnProperty(key)) {
					item = this.inputElements[key];
					item.element.removeEventListener('change', item.listener, true);
					item.element.removeEventListener('input', item.listener, true);
				}
			}

			//sources
			for (key in this.sources) {
				if (this.sources.hasOwnProperty(key)) {
					item = this.sources[key];
					if (item && item.removeTarget) {
						item.removeTarget(this);
					}
					delete this.sources[key];
				}
			}

			//targets
			while (this.targets.length) {
				item = this.targets.pop();
				if (item && item.removeSource) {
					item.removeSource(this);
				}
			}

			for (i in this) {
				if (this.hasOwnProperty(key) && key !== 'id') {
					delete this[key];
				}
			}

			//remove any aliases
			for (key in aliases) {
				if (aliases.hasOwnProperty(key)) {
					item = aliases[key];
					if (item.node === this) {
						seriously.removeAlias(key);
					}
				}
			}

			//remove self from master list of effects
			i = effects.indexOf(this);
			if (i >= 0) {
				effects.splice(i, 1);
			}

			i = allEffectsByHook[hook].indexOf(this);
			if (i >= 0) {
				allEffectsByHook[hook].splice(i, 1);
			}

			Node.prototype.destroy.call(this);
		};

		Source = function (sourceNode) {
			var me = sourceNode;

			//priveleged accessor methods
			Object.defineProperties(this, {
				original: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.source;
					}
				},
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				}
			});

			this.render = function () {
				me.render();
			};

			this.update = function () {
				me.setDirty();
			};

			this.readPixels = function (x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest);
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		/*
			possible sources: img, video, canvas (2d or 3d), texture, ImageData, array, typed array
		*/
		SourceNode = function (source, options) {
			var opts = options || {},
				flip = opts.flip === undefined ? true : opts.flip,
				width = opts.width,
				height = opts.height,
				deferTexture = false,
				that = this,
				matchedType = false;

			Node.call(this);

			if (typeof source === 'string' && isNaN(source)) {
				source = getElement(source, ['canvas', 'img', 'video']);
			}

			if (source instanceof HTMLElement) {
				if (source.tagName === 'CANVAS') {
					this.width = source.width;
					this.height = source.height;

					this.render = this.renderImageCanvas;
				} else if (source.tagName === 'IMG') {
					this.width = source.naturalWidth || 1;
					this.height = source.naturalHeight || 1;

					if (!source.complete) {
						deferTexture = true;

						source.addEventListener('load', function () {
							that.width = source.naturalWidth;
							that.height = source.naturalHeight;
							that.resize();
							that.initialize();
						}, true);
					}

					this.render = this.renderImageCanvas;
				} else if (source.tagName === 'VIDEO') {
					this.width = source.videoWidth || 1;
					this.height = source.videoHeight || 1;

					if (!source.readyState) {
						deferTexture = true;

						source.addEventListener('loadedmetadata', function () {
							that.width = source.videoWidth;
							that.height = source.videoHeight;
							that.resize();
							that.initialize();
						}, true);
					}

					this.render = this.renderVideo;
				} else {
					throw 'Not a valid HTML element: ' + source.tagName + ' (must be img, video or canvas)';
				}
				matchedType = true;

			} else if (source instanceof Object && source.data &&
				source.width && source.height &&
				source.width * source.height * 4 === source.data.length
				) {

				//Because of this bug, Firefox doesn't recognize ImageData, so we have to duck type
				//https://bugzilla.mozilla.org/show_bug.cgi?id=637077

				this.width = source.width;
				this.height = source.height;
				matchedType = true;

				this.render = this.renderImageCanvas;
			} else if (isArrayLike(source)) {
				if (!width || !height) {
					throw 'Height and width must be provided with an Array';
				}

				if (width * height * 4 !== source.length) {
					throw 'Array length must be height x width x 4.';
				}

				this.width = width;
				this.height = height;

				matchedType = true;

				//use opposite default for flip
				if (opts.flip === undefined) {
					flip = false;
				}

				if (!(source instanceof Uint8Array)) {
					source = new Uint8Array(source);
				}
				this.render = this.renderTypedArray;
			} else if (source instanceof WebGLTexture) {
				if (gl && !gl.isTexture(source)) {
					throw 'Not a valid WebGL texture.';
				}

				//different defaults
				if (!isNaN(width)) {
					if (isNaN(height)) {
						height = width;
					}
				} else if (!isNaN(height)) {
					width = height;
				}/* else {
					//todo: guess based on dimensions of target canvas
					//throw 'Must specify width and height when using a WebGL texture as a source';
				}*/

				this.width = width;
				this.height = height;

				if (opts.flip === undefined) {
					flip = false;
				}
				matchedType = true;

				this.texture = source;
				this.initialized = true;

				//todo: if WebGLTexture source is from a different context render it and copy it over
				this.render = function () {};
			}

			if (!matchedType) {
				throw 'Unknown source type';
			}

			this.source = source;
			this.flip = flip;

			this.targets = [];

			if (!deferTexture) {
				this.resize();
				this.initialize();
			}

			this.pub = new Source(this);

			sources.push(this);

			if (sources.length && !rafId) {
				renderDaemon();
			}
		};

		extend(SourceNode, Node);

		SourceNode.prototype.initialize = function () {
			if (!gl || this.texture) {
				return;
			}

			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindTexture(gl.TEXTURE_2D, null);

			this.texture = texture;
			this.initialized = true;
			this.allowRefresh = true;
			this.setDirty();
		};

		SourceNode.prototype.initFrameBuffer = function (useFloat) {
			if (gl) {
				this.frameBuffer = new FrameBuffer(gl, this.width, this.height, {
					texture: this.texture,
					useFloat: useFloat
				});
			}
		};

		SourceNode.prototype.setTarget = function (target) {
			var i;
			for (i = 0; i < this.targets.length; i++) {
				if (this.targets[i] === target) {
					return;
				}
			}

			this.targets.push(target);
		};

		SourceNode.prototype.removeTarget = function (target) {
			var i = this.targets && this.targets.indexOf(target);
			if (i >= 0) {
				this.targets.splice(i, 1);
			}
		};

		SourceNode.prototype.resize = function () {
			var i,
				target;

			this.uniforms.resolution[0] = this.width;
			this.uniforms.resolution[1] = this.height;

			if (this.framebuffer) {
				this.framebuffer.resize(this.width, this.height);
			}

			this.setDirty();

			for (i = 0; i < this.targets.length; i++) {
				target = this.targets[i];
				target.resize();
				if (target.setTransformDirty) {
					target.setTransformDirty();
				}
			}
		};

		SourceNode.prototype.renderVideo = function () {
			var video = this.source;

			if (!gl || !video || !video.videoHeight || !video.videoWidth || video.readyState < 2) {
				return;
			}

			if (!this.initialized) {
				this.initialize();
			}

			if (!this.allowRefresh) {
				return;
			}

			if (this.dirty ||
				this.lastRenderFrame !== video.mozPresentedFrames ||
				this.lastRenderTime !== video.currentTime) {

				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip);
				try {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
				} catch (securityError) {
					if (securityError.name === 'SECURITY_ERR') {
						this.allowRefresh = false;
						console.log('Unable to access cross-domain image');
					}
				}

				// Render a few extra times because the canvas takes a while to catch up
				if (Date.now() - 100 > this.lastRenderTimeStamp) {
					this.lastRenderTime = video.currentTime;
				}
				this.lastRenderFrame = video.mozPresentedFrames;
				this.lastRenderTimeStamp = Date.now();
				this.dirty = false;
			}
		};

		SourceNode.prototype.renderImageCanvas = function () {
			var media = this.source;

			if (!gl || !media || !media.height || !media.width) {
				return;
			}

			if (!this.initialized) {
				this.initialize();
			}

			if (!this.allowRefresh) {
				return;
			}

			if (this.dirty) {
				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip);
				try {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, media);
				} catch (securityError) {
					if (securityError.name === 'SECURITY_ERR') {
						this.allowRefresh = false;
						console.log('Unable to access cross-domain image');
					}
				}

				this.lastRenderTime = Date.now() / 1000;
				this.dirty = false;
			}
		};

		SourceNode.prototype.renderTypedArray = function () {
			var media = this.source;

			if (!gl || !media || !media.length) {
				return;
			}

			if (!this.initialized) {
				this.initialize();
			}

			//this.currentTime = media.currentTime || 0;

			if (!this.allowRefresh) {
				return;
			}

			if (this.dirty) {
				gl.bindTexture(gl.TEXTURE_2D, this.texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flip);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, media);

				this.lastRenderTime = Date.now() / 1000;
				this.dirty = false;
			}
		};

		SourceNode.prototype.destroy = function () {
			var i, key, item;

			if (this.gl && this.texture) {
				this.gl.deleteTexture(this.texture);
			}

			//targets
			while (this.targets.length) {
				item = this.targets.pop();
				if (item && item.removeSource) {
					item.removeSource(this);
				}
			}

			//remove self from master list of sources
			i = sources.indexOf(this);
			if (i >= 0) {
				sources.splice(i, 1);
			}

			for (key in this) {
				if (this.hasOwnProperty(key) && key !== 'id') {
					delete this[key];
				}
			}

			Node.prototype.destroy.call(this);
		};

		//todo: implement render for array and typed array

		Target = function (targetNode) {
			var me = targetNode;

			//priveleged accessor methods
			Object.defineProperties(this, {
				inputs: {
					enumerable: true,
					configurable: true,
					get: function () {
						return {
							source: {
								type: 'image'
							}
						};
					}
				},
				source: {
					enumerable: true,
					configurable: true,
					get: function () {
						if (me.source) {
							return me.source.pub;
						}
					},
					set: function (value) {
						me.setSource(value);
					}
				},
				original: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.target;
					}
				},
				width: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.width;
					},
					set: function (value) {
						if (!isNaN(value) && value >0 && me.width !== value) {
							me.width = me.desiredWidth = value;
							me.target.width = value;

							me.setTransformDirty();
							/*
							if (this.source && this.source.resize) {
								this.source.resize(value);

								//todo: for secondary webgl nodes, we need a new array
								//if (this.pixels && this.pixels.length !== (this.width * this.height * 4)) {
								//	delete this.pixels;
								//}
							}
							*/
						}
					}
				},
				height: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.height;
					},
					set: function (value) {
						if (!isNaN(value) && value >0 && me.height !== value) {
							me.height = me.desiredHeight = value;
							me.target.height = value;

							me.setTransformDirty();

							/*
							if (this.source && this.source.resize) {
								this.source.resize(undefined, value);

								//for secondary webgl nodes, we need a new array
								//if (this.pixels && this.pixels.length !== (this.width * this.height * 4)) {
								//	delete this.pixels;
								//}
							}
							*/
						}
					}
				},
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				}
			});

			this.render = function () {
				me.render();
			};

			this.readPixels = function (x, y, width, height, dest) {
				return me.readPixels(x, y, width, height, dest);
			};

			this.go = function (options) {
				me.go(options);
			};

			this.stop = function () {
				me.stop();
			};

			this.getTexture = function () {
				return me.frameBuffer.texture;
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		/*
			possible targets: canvas (2d or 3d), gl render buffer (must be same canvas)
		*/
		TargetNode = function (target, options) {
			var opts = options || {},
				flip = opts.flip === undefined ? true : opts.flip,
				width = parseInt(opts.width, 10),
				height = parseInt(opts.height, 10),
				matchedType = false,
				i, element, elements, context,
				frameBuffer;

			Node.call(this, opts);

			this.renderToTexture = opts.renderToTexture;

			if (typeof target === 'string') {
				elements = document.querySelectorAll(target);

				for (i = 0; i < elements.length; i++) {
					element = elements[i];
					if (element.tagName === 'CANVAS') {
						break;
					}
				}

				if (i >= elements.length) {
					throw 'not a valid HTML element (must be image, video or canvas)';
				}

				target = element;
			} else if (target instanceof WebGLFramebuffer) {

				frameBuffer = target;

				if (opts instanceof HTMLCanvasElement) {
					target = opts;
				} else if (opts instanceof WebGLRenderingContext) {
					target = opts.canvas;
				} else if (opts.canvas instanceof HTMLCanvasElement) {
					target = opts.canvas;
				} else if (opts.context instanceof WebGLRenderingContext) {
					target = opts.context.canvas;
				} else {
					//todo: search all canvases for matching contexts?
					throw "Must provide a canvas with WebGLFramebuffer target";
				}
			}

			if (target instanceof HTMLElement && target.tagName === 'CANVAS') {
				width = target.width;
				height = target.height;

				//todo: try to get a webgl context. if not, get a 2d context, and set up a different render function
				try {
					if (window.WebGLDebugUtils) {
						context = window.WebGLDebugUtils.makeDebugContext(target.getContext('experimental-webgl', {
							alpha: true,
							premultipliedAlpha: false,
							preserveDrawingBuffer: true,
							stencil: true
						}));
					} else {
						context = target.getContext('experimental-webgl', {
							alpha: true,
							premultipliedAlpha: false,
							preserveDrawingBuffer: true,
							stencil: true
						});
					}
				} catch (expError) {
				}

				if (!context) {
					try {
						context = target.getContext('webgl', {
							alpha: true,
							premultipliedAlpha: false,
							preserveDrawingBuffer: true,
							stencil: true
						});
					} catch (error) {

					}
				}

				if (!context) {
					context = target.getContext('2d');
					//todo: set up ImageData and alternative drawing method (or drawImage)
					this.render = this.render2D;
					this.use2D = true;
				} else if (!gl || gl === context) {
					//this is our main WebGL canvas
					if (!gl) {
						attachContext(context);
					}
					this.render = this.renderWebGL;
					if (opts.renderToTexture) {
						this.frameBuffer = new FrameBuffer(gl, width, height, false);
					} else {
						this.frameBuffer = {
							frameBuffer: frameBuffer || null
						};
					}
				} else if (context !== gl) {
					//set up alternative drawing method using ArrayBufferView
					this.gl = context;
					//this.pixels = new Uint8Array(width * height * 4);
					//todo: probably need another framebuffer for renderToTexture
					if (frameBuffer) {
						this.frameBuffer = {
							frameBuffer: frameBuffer
						};
					} else {
						this.frameBuffer = new FrameBuffer(this.gl, width, height, false);
					}
					this.shader = new ShaderProgram(this.gl, baseVertexShader, baseFragmentShader);
					this.model = buildRectangleModel.call(this, this.gl);

					this.texture = this.gl.createTexture();
					this.gl.bindTexture(gl.TEXTURE_2D, this.texture);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					this.gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

					this.render = this.renderSecondaryWebGL;
				} else {
					//todo: this should theoretically never happen
				}

				matchedType = true;
			}

			if (!matchedType) {
				throw 'Unknown target type';
			}

			this.target = target;
			this.transform = null;
			this.transformDirty = true;
			this.flip = flip;
			this.width = width;
			this.height = height;

			this.uniforms.resolution[0] = this.width;
			this.uniforms.resolution[1] = this.height;

			if (opts.auto !== undefined) {
				this.auto = opts.auto;
			} else {
				this.auto = auto;
			}
			this.frames = 0;

			this.pub = new Target(this);

			targets.push(this);
		};

		extend(TargetNode, Node);

		TargetNode.prototype.setSource = function (source) {
			var newSource;

			//todo: what if source is null/undefined/false

			newSource = findInputNode(source);

			//todo: check for cycles

			if (newSource !== this.source) {
				if (this.source) {
					this.source.removeTarget(this);
				}
				this.source = newSource;
				newSource.setTarget(this);

				this.setDirty();
			}
		};

		TargetNode.prototype.setDirty = function () {
			this.dirty = true;

			if (this.auto && !rafId) {
				rafId = requestAnimationFrame(renderDaemon);
			}
		};

		TargetNode.prototype.resize = function () {
			//if target is a canvas, reset size to canvas size
			if (this.target instanceof HTMLCanvasElement &&
					(this.width !== this.target.width || this.height !== this.target.height)) {
				this.width = this.target.width;
				this.height = this.target.height;
				this.uniforms.resolution[0] = this.width;
				this.uniforms.resolution[1] = this.height;
				this.setTransformDirty();
			}

			if (this.source &&
				(this.source.width !== this.width || this.source.height !== this.height)) {
				if (!this.transform) {
					this.transform = new Float32Array(16);
				}
			}
		};

		TargetNode.prototype.setTransformDirty = function () {
			this.transformDirty = true;
			this.setDirty();
		};

		TargetNode.prototype.go = function () {
			this.auto = true;
			this.setDirty();
		};

		TargetNode.prototype.stop = function () {
			this.auto = false;
		};

		TargetNode.prototype.renderWebGL = function () {
			var matrix, x, y;

			this.resize();

			if (this.dirty) {
				if (!this.source) {
					return;
				}

				this.source.render();

				this.uniforms.source = this.source.texture;

				if (this.source.width === this.width && this.source.height === this.height) {
					this.uniforms.transform = this.source.cumulativeMatrix || identity;
				} else if (this.transformDirty) {
					matrix = this.transform;
					mat4.copy(matrix, this.source.cumulativeMatrix || identity);
					x = this.source.width / this.width;
					y = this.source.height / this.height;
					matrix[0] *= x;
					matrix[1] *= x;
					matrix[2] *= x;
					matrix[3] *= x;
					matrix[4] *= y;
					matrix[5] *= y;
					matrix[6] *= y;
					matrix[7] *= y;
					this.uniforms.transform = matrix;
					this.transformDirty = false;
				}

				draw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this);

				this.dirty = false;
			}
		};

		TargetNode.prototype.renderSecondaryWebGL = function () {
			if (this.dirty && this.source) {
				this.source.render();

				var width = this.source.width,
					height = this.source.height;

				if (!this.pixels || this.pixels.length !== width * height * 4) {
					this.pixels = new Uint8Array(width * height * 4);
				}

				this.source.readPixels(0, 0, this.source.width, this.source.height, this.pixels);

				this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.pixels);

				this.uniforms.source = this.texture;
				draw(this.shader, this.model, this.uniforms, null, this);

				this.dirty = false;
			}
		};

		TargetNode.prototype.render2D = function () {
			//todo: make this actually do something?
		};

		TargetNode.prototype.removeSource = function (source) {
			if (this.source === source || this.source === source.pub) {
				this.source = null;
			}
		};

		TargetNode.prototype.destroy = function () {
			var i;

			//source
			if (this.source && this.source.removeTarget) {
				this.source.removeTarget(this);
			}
			delete this.source;
			delete this.target;
			delete this.pub;
			delete this.uniforms;
			delete this.pixels;
			delete this.auto;

			//remove self from master list of targets
			i = targets.indexOf(this);
			if (i >= 0) {
				targets.splice(i, 1);
			}

			Node.prototype.destroy.call(this);
		};

		Transform = function (transformNode) {
			var me = transformNode,
				self = this,
				key;

			function setProperty(name, def) {
				// todo: validate value passed to 'set'
				Object.defineProperty(self, name, {
					configurable: true,
					enumerable: true,
					get: function () {
						return def.get.call(me);
					},
					set: function (val) {
						if (def.set.call(me, val)) {
							me.setTransformDirty();
						}
					}
				});
			}

			function makeMethod(method) {
				return function () {
					if (method.apply(me, arguments)) {
						me.setTransformDirty();
					}
				};
			}

			//priveleged accessor methods
			Object.defineProperties(this, {
				id: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.id;
					}
				},
				source: {
					enumerable: true,
					configurable: true,
					get: function () {
						return me.source.pub;
					},
					set: function (source) {
						me.setSource(source);
					}
				}
			});

			// attach methods
			for (key in me.methods) {
				if (me.methods.hasOwnProperty(key)) {
					this[key] = makeMethod(me.methods[key].bind(me));
				}
			}

			for (key in me.inputs) {
				if (me.inputs.hasOwnProperty(key)) {
					setProperty(key, me.inputs[key]);
				}
			}

			this.update = function () {
				me.setDirty();
			};

			this.alias = function (inputName, aliasName) {
				me.alias(inputName, aliasName);
				return this;
			};

			this.destroy = function () {
				var i,
					descriptor;

				me.destroy();

				for (i in this) {
					if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
						//todo: probably can simplify this if the only setter/getter is id
						descriptor = Object.getOwnPropertyDescriptor(this, i);
						if (descriptor.get || descriptor.set ||
								typeof this[i] !== 'function') {
							delete this[i];
						} else {
							this[i] = nop;
						}
					}
				}
			};

			this.isDestroyed = function () {
				return me.isDestroyed;
			};
		};

		TransformNode = function (hook, options) {
			var key,
				input;

			this.matrix = new Float32Array(16);
			this.cumulativeMatrix = new Float32Array(16);

			this.width = 1;
			this.height = 1;

			this.seriously = seriously;

			this.transformRef = seriousTransforms[hook];
			this.hook = hook;
			this.id = nodeId;
			nodes.push(this);
			nodesById[nodeId] = this;
			nodeId++;

			this.options = options;
			this.sources = null;
			this.targets = [];
			this.inputElements = {};
			this.inputs = {};
			this.methods = {};

			this.texture = null;
			this.frameBuffer = null;
			this.uniforms = null;

			this.dirty = true;
			this.transformDirty = true;
			this.renderDirty = false;
			this.isDestroyed = false;
			this.transformed = false;

			if (this.transformRef.definition) {
				this.plugin = this.transformRef.definition.call(this, options);
				for (key in this.transformRef) {
					if (this.transformRef.hasOwnProperty(key) && !this.plugin[key]) {
						this.plugin[key] = this.transformRef[key];
					}
				}

				/*
				todo: validate method definitions, check against reserved names
				if (this.plugin.inputs !== this.transformRef.inputs) {
					validateInputSpecs(this.plugin);
				}
				*/
			} else {
				this.plugin = extend({}, this.transformRef);
			}

			for (key in this.plugin.inputs) {
				if (this.plugin.inputs.hasOwnProperty(key)) {
					input = this.plugin.inputs[key];

					if (input.method && typeof input.method === 'function') {
						this.methods[key] = input.method;
					} else if (typeof input.set === 'function' && typeof input.get === 'function') {
						this.inputs[key] = input;
					}
				}
			}

			this.pub = new Transform(this);

			transforms.push(this);

			allTransformsByHook[hook].push(this);
		};

		TransformNode.prototype.setDirty = function () {
			this.renderDirty = true;
			Node.prototype.setDirty.call(this);
		};

		TransformNode.prototype.setTransformDirty = function () {
			var i,
				target;
			this.transformDirty = true;
			this.dirty = true;
			this.renderDirty = true;
			for (i = 0; i < this.targets.length; i++) {
				target = this.targets[i];
				if (target.setTransformDirty) {
					target.setTransformDirty();
				} else {
					target.setDirty();
				}
			}
		};

		TransformNode.prototype.resize = function () {
			var i;

			Node.prototype.resize.call(this);

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}

			this.setTransformDirty();
		};

		TransformNode.prototype.setSource = function (source) {
			var newSource;

			//todo: what if source is null/undefined/false

			newSource = findInputNode(source);

			if (newSource === this.source) {
				return;
			}

			if (traceSources(newSource, this)) {
				throw 'Attempt to make cyclical connection.';
			}

			if (this.source) {
				this.source.removeTarget(this);
			}
			this.source = newSource;
			newSource.setTarget(this);

			this.resize();
		};

		TransformNode.prototype.setTarget = function (target) {
			var i;
			for (i = 0; i < this.targets.length; i++) {
				if (this.targets[i] === target) {
					return;
				}
			}

			this.targets.push(target);
		};

		TransformNode.prototype.removeTarget = function (target) {
			var i = this.targets && this.targets.indexOf(target);
			if (i >= 0) {
				this.targets.splice(i, 1);
			}

			if (this.targets && this.targets.length) {
				this.resize();
			}
		};

		TransformNode.prototype.alias = function (inputName, aliasName) {
			var me = this,
				input,
				def;

			if (reservedNames.indexOf(aliasName) >= 0) {
				throw aliasName + ' is a reserved name and cannot be used as an alias.';
			}

			if (this.plugin.inputs.hasOwnProperty(inputName)) {
				if (!aliasName) {
					aliasName = inputName;
				}

				seriously.removeAlias(aliasName);

				input = this.inputs[inputName];
				if (input) {
					def = me.inputs[inputName];
					Object.defineProperty(seriously, aliasName, {
						configurable: true,
						enumerable: true,
						get: function () {
							return def.get.call(me);
						},
						set: function (val) {
							if (def.set.call(me, val)) {
								me.setTransformDirty();
							}
						}
					});
				} else {
					input = this.methods[inputName];
					if (input) {
						def = input;
						seriously[aliasName] = function () {
							if (def.apply(me, arguments)) {
								me.setTransformDirty();
							}
						};
					}
				}

				if (input) {
					aliases[aliasName] = {
						node: this,
						input: inputName
					};
				}
			}

			return this;
		};

		TransformNode.prototype.render = function (renderTransform) {
			if (!this.source) {
				if (this.transformDirty) {
					mat4.copy(this.cumulativeMatrix, this.matrix);
					this.transformDirty = false;
				}
				this.texture = null;
				this.dirty = false;

				return;
			}

			this.source.render();

			if (this.transformDirty) {
				if (this.transformed) {
					//use this.matrix
					if (this.source.cumulativeMatrix) {
						mat4.multiply(this.cumulativeMatrix, this.matrix, this.source.cumulativeMatrix);
					} else {
						mat4.copy(this.cumulativeMatrix, this.matrix);
					}
				} else {
					//copy source.cumulativeMatrix
					mat4.copy(this.cumulativeMatrix, this.source.cumulativeMatrix || identity);
				}

				this.transformDirty = false;
			}

			if (renderTransform && gl) {
				if (this.renderDirty) {
					if (!this.frameBuffer) {
						this.uniforms = {
							resolution: [this.width, this.height]
						};
						this.frameBuffer = new FrameBuffer(gl, this.width, this.height);
					}

					this.uniforms.source = this.source.texture;
					this.uniforms.transform = this.cumulativeMatrix || identity;
					draw(baseShader, rectangleModel, this.uniforms, this.frameBuffer.frameBuffer, this);

					this.renderDirty = false;
				}
				this.texture = this.frameBuffer.texture;
			} else if (this.source) {
				this.texture = this.source.texture;
			} else {
				this.texture = null;
			}

			this.dirty = false;

			return this.texture;
		};

		TransformNode.prototype.destroy = function () {
			var i, key, item, hook = this.hook;

			//let effect destroy itself
			if (this.plugin.destroy && typeof this.plugin.destroy === 'function') {
				this.plugin.destroy.call(this);
			}
			delete this.effect;

			//stop watching any input elements
			for (i in this.inputElements) {
				if (this.inputElements.hasOwnProperty(i)) {
					item = this.inputElements[i];
					item.element.removeEventListener('change', item.listener, true);
					item.element.removeEventListener('input', item.listener, true);
				}
			}

			//sources
			if (this.source) {
				this.source.removeTarget(this);
			}

			//targets
			while (this.targets.length) {
				item = this.targets.pop();
				if (item && item.removeSource) {
					item.removeSource(this);
				}
			}

			for (key in this) {
				if (this.hasOwnProperty(key) && key !== 'id') {
					delete this[key];
				}
			}

			//remove any aliases
			for (key in aliases) {
				if (aliases.hasOwnProperty(key)) {
					item = aliases[key];
					if (item.node === this) {
						seriously.removeAlias(key);
					}
				}
			}

			//remove self from master list of effects
			i = transforms.indexOf(this);
			if (i >= 0) {
				transforms.splice(i, 1);
			}

			i = allTransformsByHook[hook].indexOf(this);
			if (i >= 0) {
				allTransformsByHook[hook].splice(i, 1);
			}

			Node.prototype.destroy.call(this);
		};

		/*
		Initialize Seriously object based on options
		*/

		if (options instanceof HTMLCanvasElement) {
			options = {
				canvas: options
			};
		} else {
			options = options || {};
		}

		if (options.canvas) {
		}

		/*
		priveleged methods
		*/
		this.effect = function (hook, options) {
			if (!seriousEffects[hook]) {
				throw 'Unknown effect: ' + hook;
			}

			var effectNode = new EffectNode(hook, options);
			return effectNode.pub;
		};

		this.source = function (source, options) {
			var sourceNode = findInputNode(source, options);
			//var sourceNode = new SourceNode(source, options);
			return sourceNode.pub;
		};

		this.transform = function (hook, opts) {
			var transformNode;

			if (typeof hook !== 'string') {
				opts = hook;
				hook = false;
			}

			if (hook) {
				if (!seriousTransforms[hook]) {
					throw 'Unknown transforms: ' + hook;
				}
			} else {
				hook = options && options.defaultTransform || '2d';
				if (!seriousTransforms[hook]) {
					throw 'No transform specified';
				}
			}

			transformNode = new TransformNode(hook, opts);
			return transformNode.pub;
		};

		this.target = function (target, options) {
			var targetNode, i;

			for (i = 0; i < targets.length; i++) {
				if (targets[i] === target || targets[i].target === target) {
					if (!!(options && options.renderToTexture) === !!targets[i].renderToTexture) {
						return targets[i].pub;
					}
				}
			}

			targetNode = new TargetNode(target, options);

			return targetNode.pub;
		};

		this.aliases = function () {
			return Object.keys(aliases);
		};

		this.removeAlias = function (name) {
			if (aliases[name]) {
				delete this[name];
				delete aliases[name];
			}
		};

		this.go = function (pre, post) {
			var i;

			if (typeof pre === 'function' && preCallbacks.indexOf(pre) < 0) {
				preCallbacks.push(pre);
			}

			if (typeof post === 'function' && postCallbacks.indexOf(post) < 0) {
				postCallbacks.push(post);
			}

			auto = true;
			for (i = 0; i < targets.length; i++) {
				targets[i].go();
			}

			if (!rafId && (preCallbacks.length || postCallbacks.length)) {
				renderDaemon();
			}
		};

		this.stop = function () {
			preCallbacks.length = 0;
			postCallbacks.length = 0;
			cancelAnimFrame(rafId);
			rafId = null;
		};

		this.render = function () {
			var i;
			for (i = 0; i < targets.length; i++) {
				targets[i].render(options);
			}
		};

		this.destroy = function () {
			var i,
				node,
				descriptor;

			while (nodes.length) {
				node = nodes.shift();
				node.destroy();
			}

			if (baseShader) {
				baseShader.destroy();
				baseShader = null;
			}

			//clean up rectangleModel
			if (gl) {
				gl.deleteBuffer(rectangleModel.vertex);
				gl.deleteBuffer(rectangleModel.texCoord);
				gl.deleteBuffer(rectangleModel.index);
			}

			if (rectangleModel) {
				delete rectangleModel.vertex;
				delete rectangleModel.texCoord;
				delete rectangleModel.index;
			}

			for (i in this) {
				if (this.hasOwnProperty(i) && i !== 'isDestroyed') {
					descriptor = Object.getOwnPropertyDescriptor(this, i);
					if (descriptor.get || descriptor.set ||
							typeof this[i] !== 'function') {
						delete this[i];
					} else {
						this[i] = nop;
					}
				}
			}

			baseFragmentShader = null;
			baseVertexShader = null;
			rectangleModel = null;
			gl = null;
			seriously = null;
			sources = [];
			targets = [];
			effects = [];
			nodes = [];
			preCallbacks.length = 0;
			postCallbacks.length = 0;
			cancelAnimFrame(rafId);
			rafId = null;


			isDestroyed = true;
		};

		this.isDestroyed = function () {
			return isDestroyed;
		};

		this.incompatible = function (pluginHook) {
			var i,
				plugin,
				failure = false;

			failure = Seriously.incompatible(pluginHook);

			if (failure) {
				return failure;
			}

			if (!pluginHook) {
				for (i in allEffectsByHook) {
					if (allEffectsByHook.hasOwnProperty(i) && allEffectsByHook[i].length) {
						plugin = seriousEffects[i];
						if (plugin && typeof plugin.compatible === 'function' &&
							!plugin.compatible.call(this)) {

							return 'plugin-' + i;
						}
					}
				}
			}

			return false;
		};

		//todo: load, save, find

		baseVertexShader = [
			'#ifdef GL_ES',
			'precision mediump float;',
			'#endif',

			'attribute vec4 position;',
			'attribute vec2 texCoord;',

			'uniform vec2 resolution;',
			'uniform mat4 transform;',

			'varying vec2 vTexCoord;',
			'varying vec4 vPosition;',

			'void main(void) {',
			// first convert to screen space
			'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
			'	screenPosition = transform * screenPosition;',

			// convert back to OpenGL coords
			'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
			'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
			'	gl_Position.w = screenPosition.w;',
			'	vTexCoord = texCoord;',
			'	vPosition = gl_Position;',
			'}\n'
		].join('\n');

		baseFragmentShader = [
			'#ifdef GL_ES',
			'precision mediump float;',
			'#endif',
			'varying vec2 vTexCoord;',
			'varying vec4 vPosition;',
			'uniform sampler2D source;',
			'void main(void) {',
			/*
			'	if (any(lessThan(vTexCoord, vec2(0.0))) || any(greaterThanEqual(vTexCoord, vec2(1.0)))) {',
			'		gl_FragColor = vec4(0.0);',
			'	} else {',
			*/
			'		gl_FragColor = texture2D(source, vTexCoord);',
			//'	}',
			'}'
		].join('\n');
	}

	Seriously.incompatible = function (pluginHook) {
		var canvas, gl, plugin;

		if (incompatibility === undefined) {
			canvas = document.createElement('canvas');
			if (!canvas || !canvas.getContext) {
				incompatibility = 'canvas';
			} else if (!window.WebGLRenderingContext) {
				incompatibility = 'webgl';
			} else {
				gl = getTestContext();
				if (!gl) {
					incompatibility = 'context';
				}
			}
		}

		if (incompatibility) {
			return incompatibility;
		}

		if (pluginHook) {
			plugin = seriousEffects[pluginHook];
			if (plugin && typeof plugin.compatible === 'function' &&
				!plugin.compatible(gl)) {

				return 'plugin-' + pluginHook;
			}
		}

		return false;
	};

	Seriously.plugin = function (hook, definition, meta) {
		var effect;

		if (seriousEffects[hook]) {
			console.log('Effect [' + hook + '] already loaded');
			return;
		}

		if (meta === undefined && typeof definition === 'object') {
			meta = definition;
		}

		if (!meta) {
			return;
		}

		effect = extend({}, meta);

		if (typeof definition === 'function') {
			effect.definition = definition;
		}

		if (effect.inputs) {
			validateInputSpecs(effect);
		}

		if (!effect.title) {
			effect.title = hook;
		}

		/*
		if (typeof effect.requires !== 'function') {
			effect.requires = false;
		}
		*/

		seriousEffects[hook] = effect;
		allEffectsByHook[hook] = [];

		return effect;
	};

	Seriously.removePlugin = function (hook) {
		var all, effect, plugin;

		if (!hook) {
			return this;
		}

		plugin = seriousEffects[hook];

		if (!plugin) {
			return this;
		}

		all = allEffectsByHook[hook];
		if (all) {
			while (all.length) {
				effect = all[0];
				effect.destroy();
			}
			delete allEffectsByHook[hook];
		}

		delete seriousEffects[hook];

		return this;
	};

	Seriously.transform = function (hook, definition, meta) {
		var transform;

		if (seriousTransforms[hook]) {
			console.log('Transform [' + hook + '] already loaded');
			return;
		}

		if (meta === undefined && typeof definition === 'object') {
			meta = definition;
		}

		if (!meta && !definition) {
			return;
		}

		transform = extend({}, meta);

		if (typeof definition === 'function') {
			transform.definition = definition;
		}

		/*
		todo: validate method definitions
		if (effect.inputs) {
			validateInputSpecs(effect);
		}
		*/

		if (!transform.title) {
			transform.title = hook;
		}


		seriousTransforms[hook] = transform;
		allTransformsByHook[hook] = [];

		return transform;
	};

	Seriously.removeTransform = function (hook) {
		var all, transform, plugin;

		if (!hook) {
			return this;
		}

		plugin = seriousTransforms[hook];

		if (!plugin) {
			return this;
		}

		all = allTransformsByHook[hook];
		if (all) {
			while (all.length) {
				transform = all[0];
				transform.destroy();
			}
			delete allTransformsByHook[hook];
		}

		delete seriousTransforms[hook];

		return this;
	};

	//todo: validators should not allocate new objects/arrays if input is valid
	Seriously.inputValidators = {
		color: function (value, input, oldValue) {
			var s, a, i, computed, bg;

			a = oldValue || [];

			if (typeof value === 'string') {
				//todo: support percentages, decimals
				s = (/^(rgb|hsl)a?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*(\d+(\.\d*)?)\s*)?\)/i).exec(value);
				if (s && s.length) {
					if (s.length < 3) {
						a[0] = a[1] = a[2] = a[3] = 0;
						return a;
					}

					a[3] = 1;
					for (i = 0; i < 3; i++) {
						a[i] = parseFloat(s[i+2]) / 255;
					}
					if (!isNaN(s[6])) {
						a[3] = parseFloat(s[6]);
					}
					if (s[1].toLowerCase() === 'hsl') {
						return hslToRgb(a[0], a[1], a[2], a[3], a);
					}
					return a;
				}

				s = (/^#(([0-9a-fA-F]{3,8}))/).exec(value);
				if (s && s.length) {
					s = s[1];
					if (s.length === 3) {
						a[0] = parseInt(s[0], 16) / 15;
						a[1] = parseInt(s[1], 16) / 15;
						a[2] = parseInt(s[2], 16) / 15;
						a[3] = 1;
					} else if (s.length === 4) {
						a[0] = parseInt(s[0], 16) / 15;
						a[1] = parseInt(s[1], 16) / 15;
						a[2] = parseInt(s[2], 16) / 15;
						a[3] = parseInt(s[3], 16) / 15;
					} else if (s.length === 6) {
						a[0] = parseInt(s.substr(0, 2), 16) / 255;
						a[1] = parseInt(s.substr(2, 2), 16) / 255;
						a[2] = parseInt(s.substr(4, 2), 16) / 255;
						a[3] = 1;
					} else if (s.length === 8) {
						a[0] = parseInt(s.substr(0, 2), 16) / 255;
						a[1] = parseInt(s.substr(2, 2), 16) / 255;
						a[2] = parseInt(s.substr(4, 2), 16) / 255;
						a[3] = parseInt(s.substr(6, 2), 16) / 255;
					} else {
						a[0] = a[1] = a[2] = a[3] = 0;
					}
					return a;
				}

				s = colorNames[value.toLowerCase()];
				if (s) {
					for (i = 0; i < 4; i++) {
						a[i] = s[i];
					}
					return a;
				}

				if (!colorElement) {
					colorElement = document.createElement('a');
				}
				colorElement.style.backgroundColor = '';
				colorElement.style.backgroundColor = value;
				computed = window.getComputedStyle(colorElement);
				bg = computed.getPropertyValue('background-color') ||
					computed.getPropertyValue('backgroundColor') ||
					colorElement.style.backgroundColor;
				if (bg && bg !== value) {
					return Seriously.inputValidators.color(bg, input, oldValue);
				}

				a[0] = a[1] = a[2] = a[3] = 0;
				return a;
			}

			if (isArrayLike(value)) {
				a = value;
				if (a.length < 3) {
					a[0] = a[1] = a[2] = a[3] = 0;
					return a;
				}
				for (i = 0; i < 3; i++) {
					if (isNaN(a[i])) {
						a[0] = a[1] = a[2] = a[3] = 0;
						return a;
					}
				}
				if (a.length < 4) {
					a.push(1);
				}
				return a;
			}

			if (typeof value === 'number') {
				a[0] = a[1] = a[2] = value;
				a[3] = 1;
				return a;
			}

			if (typeof value === 'object') {
				for (i = 0; i < 4; i++) {
					s = colorFields[i];
					if (value[s] === null || isNaN(value[s])) {
						a[i] = i === 3 ? 1 : 0;
					} else {
						a[i] = value[s];
					}
				}
				return a;
			}

			a[0] = a[1] = a[2] = a[3] = 0;
			return a;
		},
		number: function (value, input) {
			if (isNaN(value)) {
				return input.defaultValue || 0;
			}

			value = parseFloat(value);

			if (value < input.min) {
				return input.min;
			}

			if (value > input.max) {
				return input.max;
			}

			if (input.step) {
				return Math.round(value / input.step) * input.step;
			}

			return value;
		},
		'enum': function (value, input) {
			var options = input.options || [],
				filtered;

			filtered = options.filter(function (opt) {
				return (isArrayLike(opt) && opt.length && opt[0] === value) || opt === value;
			});

			if (filtered.length) {
				return value;
			}

			return input.defaultValue || '';
		},
		vector: function (value, input, oldValue) {
			var a, i, s, n = input.dimensions || 4;

			a = oldValue || [];
			if (isArrayLike(value)) {
				for (i = 0; i < n; i++) {
					a[i] = value[i] || 0;
				}
				return a;
			}

			if (typeof value === 'object') {
				for (i = 0; i < n; i++) {
					s = vectorFields[i];
					if (value[s] === undefined) {
						s = colorFields[i];
					}
					a[i] = value[s] || 0;
				}
				return a;
			}

			value = parseFloat(value) || 0;
			for (i = 0; i < n; i++) {
				a[i] = value;
			}

			return a;
		},
		'boolean': function (value) {
			if (!value) {
				return false;
			}

			if (value && value.toLowerCase && value.toLowerCase() === 'false') {
				return false;
			}

			return true;
		}
		//todo: date/time
	};

	Seriously.prototype.effects = Seriously.effects = function () {
		var name,
			effect,
			manifest,
			effects = {},
			input,
			i;

		for (name in seriousEffects) {
			if (seriousEffects.hasOwnProperty(name)) {
				effect = seriousEffects[name];
				manifest = {
					title: effect.title || name,
					description: effect.description || '',
					inputs: {}
				};

				for (i in effect.inputs) {
					if (effect.inputs.hasOwnProperty(i)) {
						input = effect.inputs[i];
						manifest.inputs[i] = {
							type: input.type,
							defaultValue: input.defaultValue,
							step: input.step,
							min: input.min,
							max: input.max,
							minCount: input.minCount,
							maxCount: input.maxCount,
							dimensions: input.dimensions,
							title: input.title || i,
							description: input.description || '',
							options: input.options || []
						};
					}
				}

				effects[name] = manifest;
			}
		}

		return effects;
	};

	if (window.Float32Array) {
		identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]);
	}

	//check for plugins loaded out of order
	if (window.Seriously) {
		if (typeof window.Seriously === 'object') {
			(function () {
				var i;
				for (i in window.Seriously) {
					if (window.Seriously.hasOwnProperty(i) &&
						i !== 'plugin' &&
						typeof window.Seriously[i] === 'object') {

						Seriously.plugin(i, window.Seriously[i]);
					}
				}
			}());
		} else {
			//seriously has already been loaded, so don't replace it
			return;
		}
	}

	//expose Seriously to the global object
	Seriously.util = {
		mat4: mat4,
		checkSource: checkSource,
		hslToRgb: hslToRgb,
		colors: colorNames,
		setTimeoutZero: setTimeoutZero,
		ShaderProgram: ShaderProgram,
		FrameBuffer: FrameBuffer,
		requestAnimationFrame: requestAnimationFrame,
		shader: {
			makeNoise: 'float makeNoise(float u, float v, float timer) {\n' +
						'	float x = u * v * mod(timer * 1000.0, 100.0);\n' +
						'	x = mod(x, 13.0) * mod(x, 127.0);\n' +
						'	float dx = mod(x, 0.01);\n' +
						'	return clamp(0.1 + dx * 100.0, 0.0, 1.0);\n' +
						'}\n',
			random: '#ifndef RANDOM\n' +
				'#define RANDOM\n' +
				'float random(vec2 n) {\n' +
				'	return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n' +
				'}\n' +
				'#endif\n'
		}
	};

	/*
	Default transform - 2D
	Affine transforms
	- translate
	- rotate (degrees)
	- scale
	- skew

	todo: move this to a different file when we have a build tool
	*/
	Seriously.transform('2d', function (options) {
		var me = this,
			degrees = !(options && options.radians),

			centerX = 0,
			centerY = 0,
			scaleX = 1,
			scaleY = 1,
			translateX = 0,
			translateY = 0,
			rotation = 0,
			skewX = 0,
			skewY = 0;

		//todo: skew order
		//todo: invert?

		function recompute() {
			var matrix = me.matrix,
				angle,
				s, c,
				m00,
				m01,
				m02,
				m03,
				m10,
				m11,
				m12,
				m13;

			function translate(x, y) {
				matrix[12] = matrix[0] * x + matrix[4] * y + matrix[12];
				matrix[13] = matrix[1] * x + matrix[5] * y + matrix[13];
				matrix[14] = matrix[2] * x + matrix[6] * y + matrix[14];
				matrix[15] = matrix[3] * x + matrix[7] * y + matrix[15];
			}

			if (!translateX &&
					!translateY &&
					!rotation &&
					!skewX &&
					!skewY &&
					scaleX === 1 &&
					scaleY === 1
					) {
				me.transformed = false;
				return;
			}

			//calculate transformation matrix
			mat4.identity(matrix);

			translate(translateX + centerX, translateY + centerY);

			//skew
			if (skewX) {
				matrix[4] = skewX / me.width;
			}
			if (skewY) {
				matrix[1] = skewY / me.height;
			}

			if (rotation) {
				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];

				//rotate
				angle = -(degrees ? rotation * Math.PI / 180 : rotation);
				//...rotate
				s = Math.sin(angle);
				c = Math.cos(angle);
				matrix[0] = m00 * c + m10 * s;
				matrix[1] = m01 * c + m11 * s;
				matrix[2] = m02 * c + m12 * s;
				matrix[3] = m03 * c + m13 * s;
				matrix[4] = m10 * c - m00 * s;
				matrix[5] = m11 * c - m01 * s;
				matrix[6] = m12 * c - m02 * s;
				matrix[7] = m13 * c - m03 * s;
			}

			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}

			translate(-centerX, -centerY);

			me.transformed = true;
		}

		return {
			inputs: {
				reset: {
					method: function () {
						centerX = 0;
						centerY = 0;
						scaleX = 1;
						scaleY = 1;
						translateX = 0;
						translateY = 0;
						rotation = 0;
						skewX = 0;
						skewY = 0;

						if (me.transformed) {
							me.transformed = false;
							return true;
						}

						return false;
					}
				},
				translate: {
					method: function (x, y) {
						if (isNaN(x)) {
							x = translateX;
						}

						if (isNaN(y)) {
							y = translateY;
						}

						if (x === translateX && y === translateY) {
							return false;
						}

						translateX = x;
						translateY = y;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				translateX: {
					get: function () {
						return translateX;
					},
					set: function (x) {
						if (x === translateX) {
							return false;
						}

						translateX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				translateY: {
					get: function () {
						return translateY;
					},
					set: function (y) {
						if (y === translateY) {
							return false;
						}

						translateY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotation: {
					get: function () {
						return rotation;
					},
					set: function (angle) {
						if (angle === rotation) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotation = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				center: {
					method: function (x, y) {
						if (isNaN(x)) {
							x = centerX;
						}

						if (isNaN(y)) {
							y = centerY;
						}

						if (x === centerX && y === centerY) {
							return false;
						}

						centerX = x;
						centerY = y;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				centerX: {
					get: function () {
						return centerX;
					},
					set: function (x) {
						if (x === centerX) {
							return false;
						}

						centerX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerY: {
					get: function () {
						return centerY;
					},
					set: function (y) {
						if (y === centerY) {
							return false;
						}

						centerY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				skew: {
					method: function (x, y) {
						if (isNaN(x)) {
							x = skewX;
						}

						if (isNaN(y)) {
							y = skewY;
						}

						if (x === skewX && y === skewY) {
							return false;
						}

						skewX = x;
						skewY = y;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				skewX: {
					get: function () {
						return skewX;
					},
					set: function (x) {
						if (x === skewX) {
							return false;
						}

						skewX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				skewY: {
					get: function () {
						return skewY;
					},
					set: function (y) {
						if (y === skewY) {
							return false;
						}

						skewY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				scale: {
					method: function (x, y) {
						var newX, newY;

						if (isNaN(x)) {
							newX = scaleX;
						} else {
							newX = x;
						}

						/*
						if only one value is specified, set both x and y to the same scale
						*/
						if (isNaN(y)) {
							if (isNaN(x)) {
								return false;
							}

							newY = newX;
						} else {
							newY = y;
						}

						if (newX === scaleX && newY === scaleY) {
							return false;
						}

						scaleX = newX;
						scaleY = newY;

						recompute();
						return true;
					},
					type: [
						'number',
						'number'
					]
				},
				scaleX: {
					get: function () {
						return scaleX;
					},
					set: function (x) {
						if (x === scaleX) {
							return false;
						}

						scaleX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				scaleY: {
					get: function () {
						return scaleY;
					},
					set: function (y) {
						if (y === scaleY) {
							return false;
						}

						scaleY = y;

						recompute();
						return true;
					},
					type: 'number'
				}
			}
		};
	}, {
		title: '2D Transform',
		description: 'Translate, Rotate, Scale, Skew'
	});

	/*
	todo: move this to a different file when we have a build tool
	*/
	Seriously.transform('flip', function () {
		var me = this,
			horizontal = true;

		function recompute() {
			var matrix = me.matrix;

			//calculate transformation matrix
			//mat4.identity(matrix);

			//scale
			if (horizontal) {
				matrix[0] = -1;
				matrix[5] = 1;
			} else {
				matrix[0] = 1;
				matrix[5] = -1;
			}
		}

		mat4.identity(me.matrix);
		recompute();

		me.transformDirty = true;

		me.transformed = true;

		return {
			inputs: {
				direction: {
					get: function () {
						return horizontal ? 'horizontal' : 'vertical';
					},
					set: function (d) {
						var horiz;
						if (d === 'vertical') {
							horiz = false;
						} else {
							horiz = true;
						}

						if (horiz === horizontal) {
							return false;
						}

						horizontal = horiz;
						recompute();
						return true;
					},
					type: 'string'
				}
			}
		};
	}, {
		title: 'Flip',
		description: 'Flip Horizontal/Vertical'
	});

	/*
	Reformat
	todo: move this to a different file when we have a build tool
	*/
	Seriously.transform('reformat', function () {
		var me = this,
			forceWidth,
			forceHeight,
			mode = 'contain';

		function recompute() {
			var matrix = me.matrix,
				width = forceWidth || me.width,
				height = forceHeight || me.height,
				scaleX,
				scaleY,
				source = me.source,
				sourceWidth = source && source.width || 1,
				sourceHeight = source && source.height || 1,
				aspectIn,
				aspectOut;

			if (mode === 'distort' || width === sourceWidth && height === sourceHeight) {
				me.transformed = false;
				return;
			}

			aspectIn = sourceWidth / sourceHeight;

			aspectOut = width / height;

			if (mode === 'width' || mode === 'contain' && aspectOut <= aspectIn) {
				scaleX = 1;
				scaleY = aspectOut / aspectIn;
			} else if (mode === 'height' || mode === 'contain' && aspectOut > aspectIn) {
				scaleX = aspectIn / aspectOut;
				scaleY = 1;
			} else {
				//mode === 'cover'
				if (aspectOut > aspectIn) {
					scaleX = 1;
					scaleY = aspectOut / aspectIn;
				} else {
					scaleX = aspectIn / aspectOut;
					scaleY = 1;
				}
			}

			if (scaleX === 1 && scaleY === 1) {
				me.transformed = false;
				return;
			}

			//calculate transformation matrix
			mat4.identity(matrix);

			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}
			me.transformed = true;
		}

		function getWidth() {
			return forceWidth || me.source && me.source.width || 1;
		}

		function getHeight() {
			return forceHeight || me.source && me.source.height || 1;
		}

		this.resize = function () {
			var width = getWidth(),
				height = getHeight(),
				i;

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				if (this.uniforms && this.uniforms.resolution) {
					this.uniforms.resolution[0] = width;
					this.uniforms.resolution[1] = height;
				}

				if (this.frameBuffer && this.frameBuffer.resize) {
					this.frameBuffer.resize(width, height);
				}

				for (i = 0; i < this.targets.length; i++) {
					this.targets[i].resize();
				}
			}

			this.setTransformDirty();

			recompute();
		};

		return {
			inputs: {
				width: {
					get: getWidth,
					set: function (x) {
						if (x === forceWidth) {
							return false;
						}

						forceWidth = x;

						this.resize();

						//don't need to run setTransformDirty again
						return false;
					},
					type: 'number'
				},
				height: {
					get: getHeight,
					set: function (y) {
						if (y === forceHeight) {
							return false;
						}

						forceHeight = y;

						this.resize();

						//don't need to run setTransformDirty again
						return false;
					},
					type: 'number'
				},
				mode: {
					get: function () {
						return mode;
					},
					set: function (m) {
						if (m === mode) {
							return false;
						}

						mode = m;

						recompute();
						return true;
					},
					type: 'enum',
					options: [
						'cover',
						'contain',
						'distort',
						'width',
						'height'
					]
				}
			}
		};
	}, {
		title: 'Reformat',
		description: 'Change output dimensions'
	});

	/*
	todo: additional transform node types
	- perspective
	- matrix
	- crop? - maybe not - probably would just scale.
	- camera shake?
	*/

	/*
	 * simplex noise shaders
	 * https://github.com/ashima/webgl-noise
	 * Copyright (C) 2011 by Ashima Arts (Simplex noise)
	 * Copyright (C) 2011 by Stefan Gustavson (Classic noise)
	 */

	Seriously.util.shader.noiseHelpers = '#ifndef NOISE_HELPERS\n' +
		'#define NOISE_HELPERS\n' +
		'vec2 mod289(vec2 x) {\n' +
		'	return x - floor(x * (1.0 / 289.0)) * 289.0;\n' +
		'}\n' +
		'vec3 mod289(vec3 x) {\n' +
		'	return x - floor(x * (1.0 / 289.0)) * 289.0;\n' +
		'}\n' +
		'vec4 mod289(vec4 x) {\n' +
		'	return x - floor(x * (1.0 / 289.0)) * 289.0;\n' +
		'}\n' +
		'vec3 permute(vec3 x) {\n' +
		'	return mod289(((x*34.0)+1.0)*x);\n' +
		'}\n' +
		'vec4 permute(vec4 x) {\n' +
		'	return mod289(((x*34.0)+1.0)*x);\n' +
		'}\n' +
		'vec4 taylorInvSqrt(vec4 r) {\n' +
		'	return 1.79284291400159 - 0.85373472095314 * r;\n' +
		'}\n' +
		'float taylorInvSqrt(float r) {\n' +
		'	return 1.79284291400159 - 0.85373472095314 * r;\n' +
		'}\n' +
		'#endif\n';

	Seriously.util.shader.snoise2d = '#ifndef NOISE2D\n' +
		'#define NOISE2D\n' +
		'float snoise(vec2 v) {\n' +
		'	const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n' +
		'		0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n' +
		'		-0.577350269189626, // -1.0 + 2.0 * C.x\n' +
		'		0.024390243902439); // 1.0 / 41.0\n' +
		'	vec2 i = floor(v + dot(v, C.yy));\n' +
		'	vec2 x0 = v - i + dot(i, C.xx);\n' +
		'	vec2 i1;\n' +
		'	//i1.x = step(x0.y, x0.x); // x0.x > x0.y ? 1.0 : 0.0\n' +
		'	//i1.y = 1.0 - i1.x;\n' +
		'	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n' +
		'	// x0 = x0 - 0.0 + 0.0 * C.xx ;\n' +
		'	// x1 = x0 - i1 + 1.0 * C.xx ;\n' +
		'	// x2 = x0 - 1.0 + 2.0 * C.xx ;\n' +
		'	vec4 x12 = x0.xyxy + C.xxzz;\n' +
		'	x12.xy -= i1;\n' +
		'	i = mod289(i); // Avoid truncation effects in permutation\n' +
		'	vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n' +
		'	vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n' +
		'	m = m*m ;\n' +
		'	m = m*m ;\n' +
		'	vec3 x = 2.0 * fract(p * C.www) - 1.0;\n' +
		'	vec3 h = abs(x) - 0.5;\n' +
		'	vec3 ox = floor(x + 0.5);\n' +
		'	vec3 a0 = x - ox;\n' +
		'	m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n' +
		'	vec3 g;\n' +
		'	g.x = a0.x * x0.x + h.x * x0.y;\n' +
		'	g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n' +
		'	return 130.0 * dot(m, g);\n' +
		'}\n' +
		'#endif\n';

	Seriously.util.shader.snoise3d = '#ifndef NOISE3D\n' +
		'#define NOISE3D\n' +
		'float snoise(vec3 v) {\n' +
		'	const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n' +
		'	const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n' +

		// First corner
		'	vec3 i = floor(v + dot(v, C.yyy));\n' +
		'	vec3 x0 = v - i + dot(i, C.xxx) ;\n' +

		// Other corners
		'	vec3 g = step(x0.yzx, x0.xyz);\n' +
		'	vec3 l = 1.0 - g;\n' +
		'	vec3 i1 = min(g.xyz, l.zxy);\n' +
		'	vec3 i2 = max(g.xyz, l.zxy);\n' +

		'	// x0 = x0 - 0.0 + 0.0 * C.xxx;\n' +
		'	// x1 = x0 - i1 + 1.0 * C.xxx;\n' +
		'	// x2 = x0 - i2 + 2.0 * C.xxx;\n' +
		'	// x3 = x0 - 1.0 + 3.0 * C.xxx;\n' +
		'	vec3 x1 = x0 - i1 + C.xxx;\n' +
		'	vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n' +
		'	vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n' +

		// Permutations
		'	i = mod289(i);\n' +
		'	vec4 p = permute(permute(permute(\n' +
		'						i.z + vec4(0.0, i1.z, i2.z, 1.0))\n' +
		'						+ i.y + vec4(0.0, i1.y, i2.y, 1.0))\n' +
		'						+ i.x + vec4(0.0, i1.x, i2.x, 1.0));\n' +

		// Gradients: 7x7 points over a square, mapped onto an octahedron.
		// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
		'	float n_ = 0.142857142857; // 1.0/7.0\n' +
		'	vec3 ns = n_ * D.wyz - D.xzx;\n' +

		'	vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p, 7 * 7)\n' +

		'	vec4 x_ = floor(j * ns.z);\n' +
		'	vec4 y_ = floor(j - 7.0 * x_); // mod(j, N)\n' +

		'	vec4 x = x_ * ns.x + ns.yyyy;\n' +
		'	vec4 y = y_ * ns.x + ns.yyyy;\n' +
		'	vec4 h = 1.0 - abs(x) - abs(y);\n' +

		'	vec4 b0 = vec4(x.xy, y.xy);\n' +
		'	vec4 b1 = vec4(x.zw, y.zw);\n' +

		'	//vec4 s0 = vec4(lessThan(b0, 0.0)) * 2.0 - 1.0;\n' +
		'	//vec4 s1 = vec4(lessThan(b1, 0.0)) * 2.0 - 1.0;\n' +
		'	vec4 s0 = floor(b0) * 2.0 + 1.0;\n' +
		'	vec4 s1 = floor(b1) * 2.0 + 1.0;\n' +
		'	vec4 sh = -step(h, vec4(0.0));\n' +

		'	vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n' +
		'	vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n' +

		'	vec3 p0 = vec3(a0.xy, h.x);\n' +
		'	vec3 p1 = vec3(a0.zw, h.y);\n' +
		'	vec3 p2 = vec3(a1.xy, h.z);\n' +
		'	vec3 p3 = vec3(a1.zw, h.w);\n' +

		//Normalise gradients
		'	vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n' +
		'	p0 *= norm.x;\n' +
		'	p1 *= norm.y;\n' +
		'	p2 *= norm.z;\n' +
		'	p3 *= norm.w;\n' +

		// Mix final noise value
		'	vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n' +
		'	m = m * m;\n' +
		'	return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n' +
		'}\n' +
		'#endif\n';

	Seriously.util.shader.snoise4d = '#ifndef NOISE4D\n' +
		'#define NOISE4D\n' +
		'vec4 grad4(float j, vec4 ip)\n' +
		'	{\n' +
		'	const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n' +
		'	vec4 p, s;\n' +
		'\n' +
		'	p.xyz = floor(fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n' +
		'	p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n' +
		'	s = vec4(lessThan(p, vec4(0.0)));\n' +
		'	p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n' +
		'\n' +
		'	return p;\n' +
		'	}\n' +
		'\n' +
		// (sqrt(5) - 1)/4 = F4, used once below\n
		'#define F4 0.309016994374947451\n' +
		'\n' +
		'float snoise(vec4 v)\n' +
		'	{\n' +
		'	const vec4 C = vec4(0.138196601125011, // (5 - sqrt(5))/20 G4\n' +
		'						0.276393202250021, // 2 * G4\n' +
		'						0.414589803375032, // 3 * G4\n' +
		'						-0.447213595499958); // -1 + 4 * G4\n' +
		'\n' +
		// First corner
		'	vec4 i = floor(v + dot(v, vec4(F4)));\n' +
		'	vec4 x0 = v - i + dot(i, C.xxxx);\n' +
		'\n' +
		// Other corners
		'\n' +
		// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
		'	vec4 i0;\n' +
		'	vec3 isX = step(x0.yzw, x0.xxx);\n' +
		'	vec3 isYZ = step(x0.zww, x0.yyz);\n' +
		// i0.x = dot(isX, vec3(1.0));
		'	i0.x = isX.x + isX.y + isX.z;\n' +
		'	i0.yzw = 1.0 - isX;\n' +
		// i0.y += dot(isYZ.xy, vec2(1.0));
		'	i0.y += isYZ.x + isYZ.y;\n' +
		'	i0.zw += 1.0 - isYZ.xy;\n' +
		'	i0.z += isYZ.z;\n' +
		'	i0.w += 1.0 - isYZ.z;\n' +
		'\n' +
			// i0 now contains the unique values 0,1,2,3 in each channel
		'	vec4 i3 = clamp(i0, 0.0, 1.0);\n' +
		'	vec4 i2 = clamp(i0-1.0, 0.0, 1.0);\n' +
		'	vec4 i1 = clamp(i0-2.0, 0.0, 1.0);\n' +
		'\n' +
		'	vec4 x1 = x0 - i1 + C.xxxx;\n' +
		'	vec4 x2 = x0 - i2 + C.yyyy;\n' +
		'	vec4 x3 = x0 - i3 + C.zzzz;\n' +
		'	vec4 x4 = x0 + C.wwww;\n' +
		'\n' +
		// Permutations
		'	i = mod289(i);\n' +
		'	float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n' +
		'	vec4 j1 = permute(permute(permute(permute (\n' +
		'					i.w + vec4(i1.w, i2.w, i3.w, 1.0))\n' +
		'					+ i.z + vec4(i1.z, i2.z, i3.z, 1.0))\n' +
		'					+ i.y + vec4(i1.y, i2.y, i3.y, 1.0))\n' +
		'					+ i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n' +
		'\n' +
		// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
		// 7*7*6 = 294, which is close to the ring size 17*17 = 289.
		'	vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n' +
		'\n' +
		'	vec4 p0 = grad4(j0, ip);\n' +
		'	vec4 p1 = grad4(j1.x, ip);\n' +
		'	vec4 p2 = grad4(j1.y, ip);\n' +
		'	vec4 p3 = grad4(j1.z, ip);\n' +
		'	vec4 p4 = grad4(j1.w, ip);\n' +
		'\n' +
		// Normalise gradients
		'	vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n' +
		'	p0 *= norm.x;\n' +
		'	p1 *= norm.y;\n' +
		'	p2 *= norm.z;\n' +
		'	p3 *= norm.w;\n' +
		'	p4 *= taylorInvSqrt(dot(p4, p4));\n' +
		'\n' +
		// Mix contributions from the five corners
		'	vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n' +
		'	vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n' +
		'	m0 = m0 * m0;\n' +
		'	m1 = m1 * m1;\n' +
		'	return 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)))\n' +
		'							+ dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))) ;\n' +
		'}\n' +
		'#endif\n';

	return Seriously;

}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.ascii.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	todo: consider an alternative algorithm:
	http://tllabs.io/asciistreetview/
	http://sol.gfxile.net/textfx/index.html
	*/

	var identity, letters;

	letters = document.createElement('img');
	letters.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAvAAAAAICAYAAACf+MsnAAAFY0lEQVR4Xu2Z644bOwyDN+//0NsOigEMQdRHyU6CFDnA+bHVWNaFojiTx8/Pz+/f/4/89/v7z9Xj8Tjib3XyTN9usFcMz8gt3h9zXf/O6nD/W1V7Vb9uXad+nHucZ9xenX7OqTHdSfmRXfmPsSn8xPMrllcfCkdVfHSe7Ned0/yp7jv2GPfqK+MCByc0zzvxKi5RPq8cuvE4+JrwpFM7N78K2yu+qb9kd3qV+ZjUx5n/+xnXP81ctW/UHQ5P3Gd360vxKf+n8dGpxXTeKu6h2ansFT6pvo5G2/FP99NsUf9d/xleInfetcj629m9cf9WOV5K+78R8ERGRLYO8VQiecd/1vwKEJV46JBJRzhRfXftVL/MTgM48UmL0l2OSmzs9kctAJfE4/1KkNFzbj8cjFHsJ/u460vhnPDfqddujJ27poLCWWBuHt0YKr/ki+yOKJnk5Z7pPLfLf4TZif+qvi7XuDWg+HbtNEe79ds9H7m1m2/3+YzLK5Hc9e/gYxdfNP+ZfdV9lT3usWn+9310/qiAdxa1O5gTEqVhoLudxVwVNPrvCqDp/ZX4d0Uk1Y7sbgyU4zooCk8nB3i9Y61V5wWpIjDlP+ZJsxPvmLxEOD2sntk5Pz1LBOb0L+sPfQGs6ksYpt7QAiHuUwtkgl+F3Qyf2YxTX53+Vdjfjc8VYIq7KT+abzof7ervZ8fX8d/Jyc3PmTcnRrrPEbyVTnD8T+Y38pH624mfNIr6muzO95S/sh1Gvog/XmW/a6N+scww43zgqLjcOX9cwFeESQK3Gpx32QggTlwk8Ei8OXfE4VMLeCLQiLBjfJM7VA069XefnZBGJz7Vr24dK3GwEoqLD7p/1+4IMWdRdxaMK9CmP4E62F7nm8S7s4B3BMCkBzQPVQ0IM06+2WLvzlDlI+NfF4d0ljiHuF/Zb/4m/4ojTgnA6f0qfiWA135P5l/NoFv/7txm+5ZyyOw0e1R/skd8ZKKwwnjXf9xLrkBV+2x3Pib9Vz3JOMaNL/KZ+oCkXhDUTLxEwLsC41OfI5DEYe9+mXfr0l2mJH5ISHTOUw2U8IjD5LyVUtxEmrvi4V5ejvijWNWicBbOyfsrYejkMMXmdIFEAZH19ASWnNyrPlBdKH+yU3y0gGjGKf4Mv51ft9zzKk83vul5qr9r7+CT9gHx2zvs0/yofpGX1AuC4svqhYJeJJydNZk/urcSxet91dfiUy94HX6oBHCHi5+F38svCeg1h+zZ6nyF5VUzVC8Q0X9LwE/IkMjmpJ3i27XvxuqQ0c4dp/JTfnb9T847AoNIW/nokIYrYKvnJvln/siPwtD0XAeTU+x0luEugWdLNeY4ecl260vxK8Efl3OnZi4uaZZIMBFeJ/hw6xrFvppvV1Q559d8MwwR50cskIBQ2KhE3y7/ZeddAUjxOr3diZ/8U3+I953z7uzR7Lj4rvjl9HxXvaHaOflSfSkf93y24xx94PpX89I5H2t9+fwK+KVzNOwdIeM+e905+ZqqRIj7pYHiU3FNFnBnkO+41EKige3cpX7GunwoARfjIwKrxNhEJFLfMrsbI+G/smfkojAa60vxPcNeCZCqhjSra6ydBaAWSFzaqnb01c4VEdVCWWPM7svstKDWuKrZpwUb7dVsOzPcxUeGdYdfdgV8Vr+Mv1R8Tn/iHcSNWR8jjjv9URzama9qbp0XlBP4y2Jw6u/E577AZTVz/BM/OfySzSjl79o73FRxaFdfuPG5/XE58PbXEvAT8UBn1HKuSIB8ThYwiZfJnd8z768Aib/3R/iN4J0VeMXcVwvynbl/735OBV6BKTfyT+e/T4/f7dP3uW8F3Aqs/PIHbWXeeeKjnSsAAAAASUVORK5CYII=";
	identity = new Float32Array([
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]);

	Seriously.plugin('ascii', function () {
		var baseShader,
			scaledBuffer,
			lettersTexture,
			gl,
			width,
			height,
			scaledWidth,
			scaledHeight,
			unif;
		return {
			initialize: function (parent) {
				function setLetters() {
					gl.bindTexture(gl.TEXTURE_2D, lettersTexture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, letters);
					gl.bindTexture(gl.TEXTURE_2D, null);
				}

				var me = this;

				parent();
				this.texture = this.frameBuffer.texture;

				gl = this.gl;

				lettersTexture = gl.createTexture();
				if (letters.naturalWidth) {
					setLetters();
				} else {
					letters.addEventListener('load', function () {
						setLetters();
						me.setDirty();
					});
				}

				unif = {
					letters: lettersTexture
				};

				//when the output scales up, don't smooth it out
				gl.bindTexture(gl.TEXTURE_2D, this.texture || this.frameBuffer && this.frameBuffer.texture);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.bindTexture(gl.TEXTURE_2D, null);

				scaledBuffer = new Seriously.util.FrameBuffer(gl, 1, 1);

				this.uniforms.transform = identity;
			},
			shader: function (inputs, shaderSource) {
				baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform sampler2D letters;\n' +
					'uniform vec4 background;\n' +
					'uniform vec2 resolution;\n' +
					'\n' +
					'const vec3 lumcoeff = vec3(0.2125,0.7154,0.0721);\n' +
					'const vec2 fontSize = vec2(8.0, 8.0);\n' +
					'\n' +
					'vec4 lookup(float ascii) {\n' +
					'	vec2 pos = mod(vTexCoord * resolution, fontSize) / vec2(752.0, fontSize.x) + vec2(ascii, 0.0);\n' +
					'	return texture2D(letters, pos);\n' +
					'}\n' +
					'\n' +
					'void main(void) {\n' +
					'	vec4 sample = texture2D(source, vTexCoord);\n' +
					'	float luma = dot(sample.rgb,lumcoeff);\n' +
					'	vec4 clamped = vec4(floor(sample.rgb * 8.0) / 8.0, sample.a);\n' +
					'	float char = floor(luma * 94.0) / 94.0;\n' +
					'	gl_FragColor = mix(background, clamped, lookup(char).r);\n' +
					'}\n';

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				//set up scaledBuffer if (width or height have changed)
				if (height !== this.height || width !== this.width) {
					height = this.height;
					width = this.width;
					scaledWidth = Math.ceil(width / 8);
					scaledHeight = Math.ceil(height / 8);

					unif.resolution = uniforms.resolution;
					unif.transform = identity;

					scaledBuffer.resize(scaledWidth, scaledHeight);

					//so it stays blocky
					gl.bindTexture(gl.TEXTURE_2D, scaledBuffer.texture);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				}


				parent(baseShader, model, uniforms, scaledBuffer.frameBuffer, false, {
					width: scaledWidth,
					height: scaledHeight,
					blend: false
				});

				unif.source = scaledBuffer.texture;
				unif.background = uniforms.background;

				parent(shader, model, unif, frameBuffer);
			},
			destroy: function () {
				if (scaledBuffer) {
					scaledBuffer.destroy();
				}
				if (gl && lettersTexture) {
					gl.deleteTexture(lettersTexture);
				}
			}
		};
	},
	{
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			background: {
				type: 'color',
				uniform: 'background',
				defaultValue: [0, 0, 0, 1]
			}
		},
		description: 'Display image as ascii text in 8-bit color.',
		title: 'Ascii Text'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.bleach-bypass.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Shader code:
	* Copyright vade - Anton Marini
	* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

	http://v002.info/?page_id=34

	Modified to keep alpha channel constant
	*/

	Seriously.plugin('bleach-bypass', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform float amount;\n' +
				'\n' +
				'//constant variables.\n' +
				'const vec4 one = vec4(1.0);\n' +
				'const vec4 two = vec4(2.0);\n' +
				'const vec4 lumcoeff = vec4(0.2125,0.7154,0.0721,0.0);\n' +
				'\n' +
				'vec4 overlay(vec4 myInput, vec4 previousmix, vec4 amount) {\n' +
				'	float luminance = dot(previousmix,lumcoeff);\n' +
				'	float mixamount = clamp((luminance - 0.45) * 10.0, 0.0, 1.0);\n' +
				'\n' +
				'	vec4 branch1 = two * previousmix * myInput;\n' +
				'	vec4 branch2 = one - (two * (one - previousmix) * (one - myInput));\n' +
				'\n' +
				'	vec4 result = mix(branch1, branch2, vec4(mixamount) );\n' +
				'\n' +
				'	return mix(previousmix, result, amount);\n' +
				'}\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	vec4 luma = vec4(vec3(dot(pixel,lumcoeff)), pixel.a);\n' +
				'	gl_FragColor = overlay(luma, pixel, vec4(amount));\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 1,
				min: 0,
				max: 1
			}
		},
		title: 'Bleach Bypass',
		categories: ['film'],
		description: 'Bleach Bypass film treatment\n' +
					'http://en.wikipedia.org/wiki/Bleach_bypass\n' +
					'see: "Saving Private Ryan", "Minority Report"'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.blend.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	todo: for prototype version, blend only handles two layers. this should handle multiple layers?
	todo: if transforms are used, do multiple passes and enable depth testing?
	todo: for now, only supporting float blend modes. Add complex ones
	todo: apply proper credit and license

	** Romain Dura | Romz
	** Blog: http://blog.mouaif.org
	** Post: http://blog.mouaif.org/?p=94

	*/
	var modes = {
		'normal': 'BlendNormal',
		'lighten': 'BlendLighten',
		'darken': 'BlendDarken',
		'multiply': 'BlendMultiply',
		'average': 'BlendAverage',
		'add': 'BlendAdd',
		'subtract': 'BlendSubtract',
		'difference': 'BlendDifference',
		'negation': 'BlendNegation',
		'exclusion': 'BlendExclusion',
		'screen': 'BlendScreen',
		'overlay': 'BlendOverlay',
		'softlight': 'BlendSoftLight',
		'hardlight': 'BlendHardLight',
		'colordodge': 'BlendColorDodge',
		'colorburn': 'BlendColorBurn',
		'lineardodge': 'BlendLinearDodge',
		'linearburn': 'BlendLinearBurn',
		'linearlight': 'BlendLinearLight',
		'vividlight': 'BlendVividLight',
		'pinlight': 'BlendPinLight',
		'hardmix': 'BlendHardMix',
		'reflect': 'BlendReflect',
		'glow': 'BlendGlow',
		'phoenix': 'BlendPhoenix'
	},
	nativeBlendModes = {
		normal: ['FUNC_ADD', 'SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA', 'SRC_ALPHA', 'DST_ALPHA']/*,
		add: ['FUNC_ADD', 'SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA', 'SRC_ALPHA', 'DST_ALPHA']*/
	},
	identity = new Float32Array([
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]);

	Seriously.plugin('blend', function () {
		var topUniforms,
			bottomUniforms,
			topOpts = {
				clear: false
			};

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				node,
				fn,
				i,
				bottom = this.inputs.bottom,
				top = this.inputs.top;

			if (mode === 'bottom' || mode === 'top') {
				node = this.inputs[mode];
				if (node) {
					width = node.width;
					height = node.height;
				} else {
					width = 1;
					height = 1;
				}
			} else {
				if (bottom) {
					if (top) {
						fn = (mode === 'union' ? Math.max : Math.min);
						width = fn(bottom.width, top.width);
						height = fn(bottom.height, top.height);
					} else {
						width = bottom.width;
						height = bottom.height;
					}
				} else if (top) {
					width = top.width;
					height = top.height;
				} else {
					width = 1;
					height = 1;
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			if (topUniforms) {
				if (bottom) {
					bottomUniforms.resolution[0] = bottom.width;
					bottomUniforms.resolution[1] = bottom.height;
				}
				if (top) {
					topUniforms.resolution[0] = top.width;
					topUniforms.resolution[1] = top.height;
				}
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			shader: function (inputs, shaderSource) {
				var mode = inputs.mode || 'normal',
					node;
				mode = mode.toLowerCase();

				if (nativeBlendModes[mode]) {
					//todo: move this to an 'update' event for 'mode' input
					if (!topUniforms) {
						node = this.inputs.top;
						topUniforms = {
							resolution: [
								node && node.width || 1,
								node && node.height || 1
							],
							targetRes: this.uniforms.resolution,
							source: node,
							transform: node && node.cumulativeMatrix || identity,
							opacity: 1
						};

						node = this.inputs.bottom;
						bottomUniforms = {
							resolution: [
								node && node.width || 1,
								node && node.height || 1
							],
							targetRes: this.uniforms.resolution,
							source: node,
							transform: node && node.cumulativeMatrix || identity,
							opacity: 1
						};
					}

					shaderSource.vertex = [
						'precision mediump float;',

						'attribute vec4 position;',
						'attribute vec2 texCoord;',

						'uniform vec2 resolution;',
						'uniform vec2 targetRes;',
						'uniform mat4 transform;',

						'varying vec2 vTexCoord;',
						'varying vec4 vPosition;',

						'void main(void) {',
						// first convert to screen space
						'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
						'	screenPosition = transform * screenPosition;',

						// convert back to OpenGL coords
						'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
						'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
						'	gl_Position.xy *= resolution / targetRes;',
						'	gl_Position.w = screenPosition.w;',
						'	vTexCoord = texCoord;',
						'	vPosition = gl_Position;',
						'}\n'
					].join('\n');

					shaderSource.fragment = [
						'precision mediump float;',
						'varying vec2 vTexCoord;',
						'varying vec4 vPosition;',
						'uniform sampler2D source;',
						'uniform float opacity;',
						'void main(void) {',
						'	gl_FragColor = texture2D(source, vTexCoord);',
						'	gl_FragColor.a *= opacity;',
						'}'
					].join('\n');

					return shaderSource;
				}

				topUniforms = null;
				bottomUniforms = null;

				mode = modes[mode] || 'BlendNormal';
				shaderSource.fragment = '#define BlendFunction ' + mode + '\n' +
					'#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'#define BlendLinearDodgef				BlendAddf\n' +
					'#define BlendLinearBurnf				BlendSubtractf\n' +
					'#define BlendAddf(base, blend)			min(base + blend, 1.0)\n' +
					'#define BlendSubtractf(base, blend)	max(base + blend - 1.0, 0.0)\n' +
					'#define BlendLightenf(base, blend)		max(blend, base)\n' +
					'#define BlendDarkenf(base, blend)		min(blend, base)\n' +
					'#define BlendLinearLightf(base, blend)	(blend < 0.5 ? BlendLinearBurnf(base, (2.0 * blend)) : BlendLinearDodgef(base, (2.0 * (blend - 0.5))))\n' +
					'#define BlendScreenf(base, blend)		(1.0 - ((1.0 - base) * (1.0 - blend)))\n' +
					'#define BlendOverlayf(base, blend)		(base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\n' +
					'#define BlendSoftLightf(base, blend)	((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))\n' +
					'#define BlendColorDodgef(base, blend)	((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))\n' +
					'#define BlendColorBurnf(base, blend)	((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))\n' +
					'#define BlendVividLightf(base, blend)	((blend < 0.5) ? BlendColorBurnf(base, (2.0 * blend)) : BlendColorDodgef(base, (2.0 * (blend - 0.5))))\n' +
					'#define BlendPinLightf(base, blend)	((blend < 0.5) ? BlendDarkenf(base, (2.0 * blend)) : BlendLightenf(base, (2.0 *(blend - 0.5))))\n' +
					'#define BlendHardMixf(base, blend)		((BlendVividLightf(base, blend) < 0.5) ? 0.0 : 1.0)\n' +
					'#define BlendReflectf(base, blend)		((blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0))\n' +
					/*
					** Vector3 blending modes
					*/

					// Component wise blending
					'#define Blend(base, blend, funcf)		vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))\n' +
					'#define BlendNormal(base, blend)		(blend)\n' +
					'#define BlendLighten					BlendLightenf\n' +
					'#define BlendDarken					BlendDarkenf\n' +
					'#define BlendMultiply(base, blend)		(base * blend)\n' +
					'#define BlendAverage(base, blend)		((base + blend) / 2.0)\n' +
					'#define BlendAdd(base, blend)			min(base + blend, vec3(1.0))\n' +
					'#define BlendSubtract(base, blend)	max(base + blend - vec3(1.0), vec3(0.0))\n' +
					'#define BlendDifference(base, blend)	abs(base - blend)\n' +
					'#define BlendNegation(base, blend)		(vec3(1.0) - abs(vec3(1.0) - base - blend))\n' +
					'#define BlendExclusion(base, blend)	(base + blend - 2.0 * base * blend)\n' +
					'#define BlendScreen(base, blend)		Blend(base, blend, BlendScreenf)\n' +
					'#define BlendOverlay(base, blend)		Blend(base, blend, BlendOverlayf)\n' +
					'#define BlendSoftLight(base, blend)	Blend(base, blend, BlendSoftLightf)\n' +
					'#define BlendHardLight(base, blend)	BlendOverlay(blend, base)\n' +
					'#define BlendColorDodge(base, blend)	Blend(base, blend, BlendColorDodgef)\n' +
					'#define BlendColorBurn(base, blend)	Blend(base, blend, BlendColorBurnf)\n' +
					'#define BlendLinearDodge				BlendAdd\n' +
					'#define BlendLinearBurn				BlendSubtract\n' +
					// Linear Light is another contrast-increasing mode
					// If the blend color is darker than midgray, Linear Light darkens the image by decreasing the brightness. If the blend color is lighter than midgray, the result is a brighter image due to increased brightness.
					'#define BlendLinearLight(base, blend)	Blend(base, blend, BlendLinearLightf)\n' +
					'#define BlendVividLight(base, blend)	Blend(base, blend, BlendVividLightf)\n' +
					'#define BlendPinLight(base, blend)		Blend(base, blend, BlendPinLightf)\n' +
					'#define BlendHardMix(base, blend)		Blend(base, blend, BlendHardMixf)\n' +
					'#define BlendReflect(base, blend)		Blend(base, blend, BlendReflectf)\n' +
					'#define BlendGlow(base, blend)			BlendReflect(blend, base)\n' +
					'#define BlendPhoenix(base, blend)		(min(base, blend) - max(base, blend) + vec3(1.0))\n' +
					//'#define BlendOpacity(base, blend, F, O)	(F(base, blend) * O + blend * (1.0 - O))\n' +
					'#define BlendOpacity(base, blend, BlendFn, Opacity, Alpha)	((BlendFn(base.rgb * blend.a * Opacity, blend.rgb * blend.a * Opacity) + base.rgb * base.a * (1.0 - blend.a * Opacity)) / Alpha)\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D top;\n' +
					'\n' +
					'uniform sampler2D bottom;\n' +
					'\n' +
					'uniform float opacity;\n' +
					'\n' +
					'void main(void) {\n' +
					'	vec3 color;\n' +
					'	vec4 topPixel = texture2D(top, vTexCoord);\n' +
					'	vec4 bottomPixel = texture2D(bottom, vTexCoord);\n' +

					'	float alpha = topPixel.a + bottomPixel.a * (1.0 - topPixel.a);\n' +
					'	if (alpha == 0.0) {\n' +
					'		color = vec3(0.0);\n' +
					'	} else {\n' +
					'		color = BlendOpacity(bottomPixel, topPixel, BlendFunction, opacity, alpha);\n' +
					'	}\n' +
					'	gl_FragColor = vec4(color, alpha);\n' +
					'}\n';

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				if (nativeBlendModes[this.inputs.mode]) {
					if (this.inputs.bottom) {
						draw(shader, model, bottomUniforms, frameBuffer);
					}

					if (this.inputs.top) {
						draw(shader, model, topUniforms, frameBuffer, null, topOpts);
					}
				} else {
					draw(shader, model, uniforms, frameBuffer);
				}
			},
			inputs: {
				top: {
					type: 'image',
					uniform: 'top',
					update: function () {
						if (topUniforms) {
							topUniforms.source = this.inputs.top;
							topUniforms.transform = this.inputs.top.cumulativeMatrix || identity;
						}
						this.resize();
					}
				},
				bottom: {
					type: 'image',
					uniform: 'bottom',
					update: function () {
						if (bottomUniforms) {
							bottomUniforms.source = this.inputs.bottom;
							bottomUniforms.transform = this.inputs.bottom.cumulativeMatrix || identity;
						}
						this.resize();
					}
				},
				opacity: {
					type: 'number',
					uniform: 'opacity',
					defaultValue: 1,
					min: 0,
					max: 1,
					update: function (opacity) {
						if (topUniforms) {
							topUniforms.opacity = opacity;
						}
					}
				},
				sizeMode: {
					type: 'enum',
					defaultValue: 'bottom',
					options: [
						'bottom',
						'top',
						'union',
						'intersection'
					],
					update: function () {
						this.resize();
					}
				},
				mode: {
					type: 'enum',
					shaderDirty: true,
					defaultValue: 'normal',
					options: [
						['normal', 'Normal'],
						['lighten', 'Lighten'],
						['darken', 'Darken'],
						['multiply', 'Multiply'],
						['average', 'Average'],
						['add', 'Add'],
						['substract', 'Substract'],
						['difference', 'Difference'],
						['negation', 'Negation'],
						['exclusion', 'Exclusion'],
						['screen', 'Screen'],
						['overlay', 'Overlay'],
						['softlight', 'Soft Light'],
						['hardlight', 'Hard Light'],
						['colordodge', 'Color Dodge'],
						['colorburn', 'Color Burn'],
						['lineardodge', 'Linear Dodge'],
						['linearburn', 'Linear Burn'],
						['linearlight', 'Linear Light'],
						['vividlight', 'Vivid Light'],
						['pinlight', 'Pin Light'],
						['hardmix', 'Hard Mix'],
						['reflect', 'Reflect'],
						['glow', 'Glow'],
						['phoenix', 'Phoenix']
					]
				}
			}
		};
	},
	{
		inPlace: function () {
			return !!nativeBlendModes[this.inputs.mode];
		},
		description: 'Blend two layers',
		title: 'Blend'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.blur.js", function(exports, require, module){
/* global define, require */
/*
Blur

Adapted from v002 by Anton Marini and Tom Butterworth
* Copyright vade - Anton Marini
* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

http://v002.info/plugins/v002-blurs/
*/
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var passes = [0.2, 0.3, 0.5, 0.8, 1],
		finalPass = passes.length - 1,
		horizontal = [1, 0],
		vertical = [0, 1],
		identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]);

	Seriously.plugin('blur', function (options) {
		var fbHorizontal,
			fbVertical,
			baseShader,
			loopUniforms = {
				amount: 0,
				inputScale: 1,
				resolution: [this.width, this.height],
				transform: identity,
				direction: null,
				projection: new Float32Array([
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				])
			};

		return {
			initialize: function (parent) {
				var gl;

				parent();

				gl = this.gl;

				if (!gl) {
					return;
				}

				fbHorizontal = new Seriously.util.FrameBuffer(gl, this.width, this.height);
				fbVertical = new Seriously.util.FrameBuffer(gl, this.width, this.height);
			},
			shader: function (inputs, shaderSource) {
				var gl = this.gl,
					/*
					Some devices or browsers (e.g. IE11 preview) don't support enough
					varying vectors, so we need to fallback to a less efficient method
					*/
					maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS),
					defineVaryings = (maxVaryings >= 10 ? '#define USE_VARYINGS' : '');

				baseShader = new Seriously.util.ShaderProgram(gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.vertex = [
					defineVaryings,
					'#define PI ' + Math.PI,
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform mat4 projection;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform vec2 direction;',
					'uniform float amount;',
					'uniform float inputScale;',

					'const vec2 zero = vec2(0.0, 0.0);',
					'#ifdef USE_VARYINGS',
					'vec2 one;',
					'vec2 amount1;',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 one;',
					'varying vec2 amount1;',
					'#endif',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position = screenPosition;',
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',

					'	one = vec2(1.0, 1.0) * inputScale;',
					'	if (inputScale < 1.0) {',
					'		one -= 1.0 / resolution;',
					'	}',
					//'	one *= inputScale;',
					'	vTexCoord = max(zero, min(one, texCoord.st * inputScale));',
					'	amount1 = direction * (inputScale * amount * 5.0 / resolution);',

					'#ifdef USE_VARYINGS',
					'	vec2 amount2 = amount1 * 3.0;',
					'	vec2 amount3 = amount1 * 6.0;',
					'	vec2 amount4 = amount1 * 9.0;',
					'	vec2 amount5 = -amount1;',
					'	vec2 amount6 = amount5 * 3.0;',
					'	vec2 amount7 = amount5 * 6.0;',
					'	vec2 amount8 = amount5 * 9.0;',
					'	vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vTexCoord2 = max(zero, min(one, vTexCoord + amount2));',
					'	vTexCoord3 = max(zero, min(one, vTexCoord + amount3));',
					'	vTexCoord4 = max(zero, min(one, vTexCoord + amount4));',
					'	vTexCoord5 = max(zero, min(one, vTexCoord + amount5));',
					'	vTexCoord6 = max(zero, min(one, vTexCoord + amount6));',
					'	vTexCoord7 = max(zero, min(one, vTexCoord + amount7));',
					'	vTexCoord8 = max(zero, min(one, vTexCoord + amount8));',
					'#endif',
					'}'
				].join('\n');
				shaderSource.fragment = [
					defineVaryings,

					'precision mediump float;\n',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform sampler2D source;',
					'uniform float angle;',
					'uniform float amount;',
					'uniform float inputScale;',

					'#ifdef USE_VARYINGS',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 amount1;',
					'varying vec2 one;',
					'const vec2 zero = vec2(0.0, 0.0);',
					'#endif',

					'void main(void) {',
					'#ifndef USE_VARYINGS',
					'	vec2 vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vec2 vTexCoord2 = max(zero, min(one, vTexCoord + amount1 * 3.0));',
					'	vec2 vTexCoord3 = max(zero, min(one, vTexCoord + amount1 * 6.0));',
					'	vec2 vTexCoord4 = max(zero, min(one, vTexCoord + amount1 * 9.0));',
					'	vec2 vTexCoord5 = max(zero, min(one, vTexCoord - amount1));',
					'	vec2 vTexCoord6 = max(zero, min(one, vTexCoord - amount1 * 3.0));',
					'	vec2 vTexCoord7 = max(zero, min(one, vTexCoord - amount1 * 6.0));',
					'	vec2 vTexCoord8 = max(zero, min(one, vTexCoord - amount1 * 9.0));',
					'#endif',
					'	gl_FragColor = texture2D(source, vTexCoord) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord1) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord2) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord3) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord4) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord5) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord6) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord7) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord8) / 9.0;',
					'}'
				].join('\n');

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				var i,
					pass,
					amount,
					width,
					height,
					opts = {
						width: 0,
						height: 0,
						blend: false
					},
					previousPass = 1;

				amount = this.inputs.amount;
				if (!amount) {
					uniforms.source = this.inputs.source.texture;
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				if (amount <= 0.01) {
					//horizontal pass
					uniforms.inputScale = 1;
					uniforms.direction = horizontal;
					uniforms.source = this.inputs.source.texture;
					parent(shader, model, uniforms, fbHorizontal.frameBuffer);

					//vertical pass
					uniforms.direction = vertical;
					uniforms.source = fbVertical.texture;
					parent(shader, model, uniforms, frameBuffer);
					return;
				}

				loopUniforms.amount = amount;
				loopUniforms.source = this.inputs.source.texture;
				loopUniforms.projection[0] = this.height / this.width;

				for (i = 0; i < passes.length; i++) {
					pass = Math.min(1, passes[i] / amount);
					width = Math.floor(pass * this.width);
					height = Math.floor(pass * this.height);

					loopUniforms.resolution[0] = width;
					loopUniforms.resolution[1] = height;
					loopUniforms.inputScale = previousPass;
					previousPass = pass;

					opts.width = width;
					opts.height = height;

					//horizontal pass
					loopUniforms.direction = horizontal;
					parent(shader, model, loopUniforms, fbHorizontal.frameBuffer, null, opts);

					//vertical pass
					loopUniforms.inputScale = pass;
					loopUniforms.source = fbHorizontal.texture;
					loopUniforms.direction = vertical;
					parent(shader, model, loopUniforms, i === finalPass ? frameBuffer : fbVertical.frameBuffer, null, opts);

					loopUniforms.source = fbVertical.texture;
				}
			},
			resize: function () {
				loopUniforms.resolution[0] = this.width;
				loopUniforms.resolution[1] = this.height;
				if (fbHorizontal) {
					fbHorizontal.resize(this.width, this.height);
					fbVertical.resize(this.width, this.height);
				}
			},
			destroy: function () {
				if (fbHorizontal) {
					fbHorizontal.destroy();
					fbVertical.destroy();
					fbHorizontal = null;
					fbVertical = null;
				}

				if (baseShader) {
					baseShader.destroy();
				}

				loopUniforms = null;
			}
		};
	},
	{
		inputs: {
			source: {
				type: 'image',
				shaderDirty: false
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 0.2,
				min: 0,
				max: 1
			}
		},
		title: 'Gaussian Blur'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.brightness-contrast.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('brightness-contrast', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform float brightness;',
				'uniform float saturation;',
				'uniform float contrast;',

				'const vec3 half3 = vec3(0.5);',

				'void main(void) {',
				'	vec4 pixel = texture2D(source, vTexCoord);',

				//adjust brightness
				'	vec3 color = pixel.rgb * brightness;',

				//adjust contrast
				'	color = (color - half3) * contrast + half3;',

				//keep alpha the same
				'	gl_FragColor = vec4(color, pixel.a);',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			brightness: {
				type: 'number',
				uniform: 'brightness',
				defaultValue: 1,
				min: 0
			},
			contrast: {
				type: 'number',
				uniform: 'contrast',
				defaultValue: 1,
				min: 0
			}
		},
		title: 'Brightness/Contrast',
		description: 'Multiply brightness and contrast values. Works the same as CSS filters.'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.channels.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var channelOptions = [
			'Red',
			'Green',
			'Blue',
			'Alpha'
		],
		channelLookup = {
			r: 0,
			g: 1,
			b: 2,
			a: 3,
			x: 0,
			y: 1,
			z: 2,
			w: 3
		};

	Seriously.plugin('channels', function () {
		var sources = [],
			shaders = [],
			matrices = [],
			me = this;

		function validateChannel(value, input, name) {
			var val;
			if (typeof value === 'string') {
				val = value.charAt(0).toLowerCase();
				val = channelLookup[val];
				if (val === undefined) {
					val = -1;
				}
				if (val < 0) {
					val = parseFloat(value);
				}
			} else {
				val = value;
			}

			if (val === 0 || val === 1 || val === 2 || val === 3) {
				return val;
			}

			return me.inputs[name];
		}

		function updateChannels() {
			var inputs = me.inputs,
				i, j,
				source,
				matrix;

			for (i = 0; i < sources.length; i++) {
				source = sources[i];
				matrix = matrices[i];
				if (!matrix) {
					matrix = matrices[i] = [];
					me.uniforms['channels' + i] = matrix;
				}

				for (j = 0; j < 16; j++) {
					matrix[j] = 0;
				}

				matrix[inputs.red] = (inputs.redSource === source) ? 1 : 0;
				matrix[4 + inputs.green] = (inputs.greenSource === source) ? 1 : 0;
				matrix[8 + inputs.blue] = (inputs.blueSource === source) ? 1 : 0;
				matrix[12 + inputs.alpha] = (inputs.alphaSource === source) ? 1 : 0;
			}
		}

		function updateSources() {
			var inputs = me.inputs;

			function validateSource(name) {
				var s, j;
				s = inputs[name];
				if (!s) {
					s = inputs[name] = inputs.source;
				}

				j = sources.indexOf(s);
				if (j < 0) {
					j = sources.length;
					sources.push(s);
					me.uniforms['source' + j] = s;
				}
			}
			sources.length = 0;

			validateSource('redSource');
			validateSource('greenSource');
			validateSource('blueSource');
			validateSource('alphaSource');

			me.resize();

			updateChannels();
		}

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				i,
				resolution,
				source;

			if (!sources.length) {
				width = 1;
				height = 1;
			} else if (sources.length === 1) {
				source = sources[0];
				width = source.width;
				height = source.height;
			} else if (mode === 'union') {
				width = 0;
				height = 0;
				for (i = 0; i < sources.length; i++) {
					source = sources[0];
					width = Math.max(width, source.width);
					height = Math.max(height, source.height);
				}
			} else if (mode === 'intersection') {
				width = Infinity;
				height = Infinity;
				for (i = 0; i < sources.length; i++) {
					source = sources[0];
					width = Math.min(width, source.width);
					height = Math.min(height, source.height);
				}
			} else {
				source = me.inputs[mode + 'Source'];
				if (source) {
					width = source.width;
					height = source.height;
				} else {
					width = 1;
					height = 1;
				}
			}

			for (i = 0; i < sources.length; i++) {
				source = sources[i];
				resolution = me.uniforms['resolution' + i];
				if (resolution) {
					resolution[0] = source.width;
					resolution[1] = source.height;
				} else {
					me.uniforms['resolution' + i] = [source.width, source.height];
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			shader: function () {
				var i,
					frag,
					vert,
					shader,
					uniforms = '',
					samples = '',
					varyings = '',
					position = '';

				/*
				We'll restore this and the draw function below if we ever figure out a way to
				add/& multiple renders without screwing up the brightness
				shaderSource.fragment = [
					'#ifdef GL_ES',
					'precision mediump float;',
					'#endif',
					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',
					'uniform mat4 channels;',
					'uniform sampler2D source;',
					//'uniform sampler2D previous;',
					'void main(void) {',
					'	vec4 pixel;',
					'	if (any(lessThan(vTexCoord, vec2(0.0))) || any(greaterThanEqual(vTexCoord, vec2(1.0)))) {',
					'		pixel = vec4(0.0);',
					'	} else {',
					'		pixel = texture2D(source, vTexCoord) * channels;',
					//'		if (gl_FragColor.a == 0.0) gl_FragColor.a = 1.0;',
					'	}',
					'	gl_FragColor = pixel;',
					'}'
				].join('\n');

				return shaderSource;
				*/
				if (shaders[sources.length]) {
					return shaders[sources.length];
				}

				for (i = 0; i < sources.length; i++) {
					varyings += 'varying vec2 vTexCoord' + i + ';\n';

					uniforms += 'uniform sampler2D source' + i + ';\n' +
						'uniform mat4 channels' + i + ';\n' +
						'uniform vec2 resolution' + i + ';\n\n';

					position += '    vTexCoord' + i + ' = (position.xy * resolution / resolution' + i + ') * 0.5 + 0.5;\n';

					samples += '    if (all(greaterThanEqual(vTexCoord' + i + ', vec2(0.0))) && all(lessThan(vTexCoord' + i + ', vec2(1.0)))) {\n' +
						'        gl_FragColor += texture2D(source' + i + ', vTexCoord' + i + ') * channels' + i + ';\n    }\n';
				}

				vert = ['#ifdef GL_ES',
					'precision mediump float;',
					'#endif',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					uniforms,

					varyings,

					'void main(void) {',
					position,
					'	gl_Position = position;',
					'}\n'
				].join('\n');

				frag = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					varyings +
					'\n' +
					uniforms +
					'\n' +
					'void main(void) {\n' +
					'	gl_FragColor = vec4(0.0);\n' +
					samples +
					'}\n';

				shader = new Seriously.util.ShaderProgram(this.gl,
					vert,
					frag);

				shaders[sources.length] = shader;
				return shader;
			},
			/*
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					source;

				options.clear = true;
				for (i = 0; i < sources.length; i++) {
				//for (i = sources.length - 1; i >= 0; i--) {
					uniforms.channels = matrices[i];
					source = sources[i];
					uniforms.source = sources[i];
					//uniforms.resolution[]

					draw(shader, model, uniforms, frameBuffer, null, options);
					options.clear = false;
				}
			},
			*/
			inputs: {
				sizeMode: {
					type: 'enum',
					defaultValue: 'red',
					options: [
						'red',
						'green',
						'blue',
						'alpha',
						'union',
						'intersection'
					],
					update: function () {
						this.resize();
					}
				},
				source: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				redSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				greenSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				blueSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				alphaSource: {
					type: 'image',
					update: updateSources,
					shaderDirty: true
				},
				red: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 0
				},
				green: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 1
				},
				blue: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 2
				},
				alpha: {
					type: 'enum',
					options: channelOptions,
					validate: validateChannel,
					update: updateChannels,
					defaultValue: 3
				}
			}
		};
	},
	{
		inPlace: false,
		title: 'Channel Mapping'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.chroma.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*	experimental chroma key algorithm
		todo: see if we can minimize branching
		todo: calculate HSL of screen color outside shader
		todo: try allowing some color despill on opaque pixels
		todo: add different modes?
		todo: rename parameters
	*/
	Seriously.plugin('chroma', {
		shader: function (inputs, shaderSource) {
			shaderSource.vertex = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif ',

				'attribute vec4 position;',
				'attribute vec2 texCoord;',

				'uniform vec2 resolution;',
				'uniform mat4 transform;',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform vec4 screen;',
				'uniform float balance;',
				'varying float screenSat;',
				'varying vec3 screenPrimary;',

				'void main(void) {',
				'	float fmin = min(min(screen.r, screen.g), screen.b);    //Min. value of RGB',
				'	float fmax = max(max(screen.r, screen.g), screen.b);    //Max. value of RGB',
				'	float secondaryComponents;',

				//'	luminance = (fmax + fmin) / 2.0; // Luminance',
				//'	screenSat = fmax - fmin; // Saturation',
				'	screenPrimary = step(fmax, screen.rgb);',
				'	secondaryComponents = dot(1.0 - screenPrimary, screen.rgb);',
				'	screenSat = fmax - mix(secondaryComponents - fmin, secondaryComponents / 2.0, balance);',

				// first convert to screen space
				'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
				'	screenPosition = transform * screenPosition;',

				// convert back to OpenGL coords
				'	gl_Position = screenPosition;',
				'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
				'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
				'	vTexCoord = texCoord;',
				'	vPosition = gl_Position;',
				'}'
			].join('\n');
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec4 screen;',
				'uniform float screenWeight;',
				'uniform float balance;',
				'uniform float clipBlack;',
				'uniform float clipWhite;',
				'uniform bool mask;',

				'varying float screenSat;',
				'varying vec3 screenPrimary;',

				'vec4 sourcePixel;',

				'const mat3 yuv = mat3(',
				'	54.213, 182.376, 18.411,',
				'	-54.213, -182.376, 236.589,',
				'	200.787, -182.376, -18.411',
				');',

				'float round(float n) {',
				'	return floor(n) + step(0.5, fract(n));',
				'}',

				'void main(void) {',
				'	float pixelSat, luminance, secondaryComponents;',
				'	vec3 pixelPrimary;',
				'	vec4 pixel = vec4(0.0);',
				'	sourcePixel = texture2D(source, vTexCoord);',

				'	float fmin = min(min(sourcePixel.r, sourcePixel.g), sourcePixel.b);    //Min. value of RGB',
				'	float fmax = max(max(sourcePixel.r, sourcePixel.g), sourcePixel.b);    //Max. value of RGB',
				//'	float delta = fmax - fmin;             //Delta RGB value',

				//'	luminance = (fmax + fmin) / 2.0; // Luminance',
				//'	luminance = dot(vec3(0.3, 0.59, 0.11), sourcePixel.rgb); // Luminance',
				'	luminance = fmax; // Luminance',
				'	pixelPrimary = step(fmax, sourcePixel.rgb);',
				//'	pixelSat = delta; // Saturation',
				'	secondaryComponents = dot(1.0 - pixelPrimary, sourcePixel.rgb);',
				'	pixelSat = fmax - mix(secondaryComponents - fmin, secondaryComponents / 2.0, balance);', // Saturation
				'	if (pixelSat < 0.1 || luminance < 0.1 || any(notEqual(pixelPrimary, screenPrimary))) {',
				'		pixel = sourcePixel;',
				//'		pixel = vec4(1.0);',

				'	} else if (pixelSat < screenSat) {',
				'		float alpha = 1.0 - pixelSat / screenSat;',
				'		alpha = smoothstep(clipBlack, clipWhite, alpha);',
				//'		float despill = alpha / screenWeight;',
				'		pixel = vec4((sourcePixel.rgb - (1.0 - alpha) * screen.rgb * screenWeight) / alpha, alpha);',
				//'		pixel = vec4(vec3(alpha), 1.0);',
				'	}',

				'	if (mask) {',
				'		gl_FragColor = vec4(vec3(pixel.a), 1.0);',
				'	} else {',
				'		gl_FragColor = pixel;',
				'	}',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			screen: {
				type: 'color',
				uniform: 'screen',
				defaultValue: [66 / 255, 195 / 255, 31 / 255, 1]
			},
			weight: {
				type: 'number',
				uniform: 'screenWeight',
				defaultValue: 1,
				min: 0
			},
			balance: {
				type: 'number',
				uniform: 'balance',
				defaultValue: 1,
				min: 0,
				max: 1
			},
			clipBlack: {
				type: 'number',
				uniform: 'clipBlack',
				defaultValue: 0,
				min: 0,
				max: 1
			},
			clipWhite: {
				type: 'number',
				uniform: 'clipWhite',
				defaultValue: 1,
				min: 0,
				max: 1
			},
			mask: {
				type: 'boolean',
				defaultValue: false,
				uniform: 'mask'
			}

		},
		title: 'Chroma Key',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.color.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('color', {
		shader: function(inputs, shaderSource, utilities) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform vec4 color;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = color;\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			color: {
				type: 'color',
				uniform: 'color',
				defaultValue: [0, 0, 0, 1]
			}
		},
		title: 'Color',
		description: 'Generate color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.colorcomplements.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('colorcomplements', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec4 guideColor;',
				'uniform float correlation;',
				'uniform float amount;',
				'uniform float concentration;',

				'float hueLerp(float h1, float h2, float v) {',
				'	float d = abs(h1 - h2);',
				'	if (d <= 0.5) {',
				'		return mix(h1, h2, v);',
				'	} else if (h1 < h2) {',
				'		return fract(mix((h1 + 1.0), h2, v));',
				'	} else {',
				'		return fract(mix(h1, (h2 + 1.0), v));',
				'	}',
				'}',

				//conversion functions borrowed from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
				'vec3 rgbToHsv(vec3 c) {',
				'	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);',
				'	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);',
				'	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);',

				'	float d = q.x - min(q.w, q.y);',
				'	float e = 1.0e-10;',
				'	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);',
				'}',

				'vec3 hsvToRgb(vec3 c) {',
				'	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);',
				'	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);',
				'	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);',
				'}',

				'vec3 hsvComplement(vec3 hsv) {',
				'	vec3 compl = hsv;',
				'	compl.x = mod(compl.x - 0.5, 1.0);',
				'	return compl;',
				'}',

				'void main(void) {',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	vec3 hsv = rgbToHsv(pixel.rgb);',
				'	vec3 hsvPole1 = rgbToHsv(guideColor.rgb);',
				'	vec3 hsvPole2 = hsvPole1;',
				'	hsvPole2 = hsvComplement(hsvPole1);',
				'	float dist1 = abs(hsv.x - hsvPole1.x);',
				'	dist1 = dist1 > 0.5 ? 1.0 - dist1 : dist1;',
				'	float dist2 = abs(hsv.x - hsvPole2.x);',
				'	dist2 = dist2 > 0.5 ? 1.0 - dist2 : dist2;',

				'	float descent = smoothstep(0.0, correlation, hsv.y);',
				'	vec3 outputHsv = hsv;',
				'	vec3 pole = dist1 < dist2 ? hsvPole1 : hsvPole2;',
				'	float dist = min(dist1, dist2);',
				'	float c = descent * amount * (1.0 - pow((dist * 2.0), 1.0 / concentration));',
				'	outputHsv.x = hueLerp(hsv.x, pole.x, c);',
				'	outputHsv.y = mix(hsv.y, pole.y, c);',

				'	gl_FragColor = vec4(hsvToRgb(outputHsv), pixel.a);',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				min: 0,
				max: 1,
				defaultValue: 0.8
			},
			concentration: {
				type: 'number',
				uniform: 'concentration',
				min: 0.1,
				max: 4,
				defaultValue: 2
			},
			correlation: {
				type: 'number',
				uniform: 'correlation',
				min: 0,
				max: 1,
				defaultValue: 0.5
			},
			guideColor: {
				type: 'color',
				uniform: 'guideColor',
				defaultValue: [1, 0.5, 0, 1]
			}
		},
		title: 'Color Complements',
		categories: ['color'],
		description: 'http://theabyssgazes.blogspot.com/2010/03/teal-and-orange-hollywood-please-stop.html'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.colorcube.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//based on tutorial by to Gregg Tavares 
	//http://www.youtube.com/watch?v=rfQ8rKGTVlg&t=24m30s
	//todo: find a way to not invert every single texture

	Seriously.plugin('colorcube', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif\n' +
				'uniform sampler2D source;\n' +
				'uniform sampler2D colorCube;\n' +
				'varying vec2 vTexCoord;\n' +

				'vec3 sampleAs3DTexture(sampler2D tex, vec3 coord, float size) {\n' +
				'	float sliceSize = 1.0 / size;                         // space of 1 slice\n' +
				'	float slicePixelSize = sliceSize / size;              // space of 1 pixel\n' +
				'	float sliceInnerSize = slicePixelSize * (size - 1.0); // space of size pixels\n' +
				'	float zSlice0 = min(floor(coord.z * size), size - 1.0);\n' +
				'	float zSlice1 = min(zSlice0 + 1.0, size - 1.0);\n' +
				'	float xOffset = slicePixelSize * 0.5 + coord.x * sliceInnerSize;\n' +
				'	float s0 = xOffset + (zSlice0 * sliceSize);\n' +
				'	float s1 = xOffset + (zSlice1 * sliceSize);\n' +
				'	vec3 slice0Color = texture2D(tex, vec2(s0, 1.0 - coord.y)).rgb;\n' +
				'	vec3 slice1Color = texture2D(tex, vec2(s1, 1.0 - coord.y)).rgb;\n' +
				'	float zOffset = mod(coord.z * size, 1.0);\n' +
				'	return mix(slice0Color, slice1Color, zOffset);\n' +
				'}\n' +

				'void main(void) {\n' +
				'	vec4 originalColor = texture2D(source, vTexCoord);\n' +
				'	vec3 color = sampleAs3DTexture(colorCube, originalColor.rgb, 8.0);\n' +
				'	gl_FragColor = vec4(color, originalColor.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			cube: {
				type: 'image',
				uniform: 'colorCube'
			}
		},
		title: 'Color Cube',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.daltonize.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		var Seriously = root.Seriously;
		if (!Seriously) {
			Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

//todo: add Simulate mode http://mudcu.be/labs/Color/Vision/Javascript/Color.Vision.Simulate.js

/*
* Daltonization algorithm from:
* Digital Video Colourmaps for Checking the Legibility of Displays by Dichromats
* http://vision.psychol.cam.ac.uk/jdmollon/papers/colourmaps.pdf
*
* JavaScript implementation:
* http://mudcu.be/labs/Color/Vision/Javascript/Color.Vision.Daltonize.js
*
* Copyright (c) 2013 David Lewis, British Broadcasting Corporation
* (http://www.bbc.co.uk)
*
* MIT Licence:
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:

* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.

* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
	*/
	Seriously.plugin('daltonize', {
		shader: function (inputs, shaderSource) {
			//Vertex shader
			shaderSource.vertex = '#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif \n' +
				'\n' +
				'attribute vec3 position;\n' +
				'attribute vec2 texCoord;\n' +
				'\n' +
				'uniform mat4 transform;\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_Position = transform * vec4(position, 1.0);\n' +
				'	vTexCoord = vec2(texCoord.s, texCoord.t);\n' +
				'}\n';
			//Fragment shader
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float cbtype;\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 color = texture2D(source, vTexCoord);\n' +

				//No change, skip the rest
				'	if (cbtype == 0.0) {\n' +
				'		gl_FragColor = color;\n' +
				'		return;\n' +
				'	}\n' +

				// RGB to LMS matrix conversion
				'	const mat3 RGBLMS = mat3( ' +
				'		17.8824, 43.5161, 4.11935,' +
				'		3.45565, 27.1554, 3.86714,' +
				'		0.0299566, 0.184309, 1.46709' +
				'	);\n' +
				'	vec3 LMS = color.rgb * RGBLMS;\n' +

				'	vec3 lms = vec3(0.0,0.0,0.0);\n' +
				//Protanope
				'	if (cbtype < 0.33) {\n' +
				'		lms = vec3(	' +
				'			(2.02344 * LMS.g) + (-2.52581 * LMS.b),' +
				'			LMS.g,' +
				'			LMS.b' +
				'		);\n' +
				'	}\n' +
				//Deuteranope
				'	if (cbtype > 0.33 && cbtype < 0.66) {\n' +
				'		lms = vec3(	' +
				'			LMS.r,' +
				'			(0.494207 * LMS.r) + (1.24827 * LMS.b),' +
				'			LMS.b' +
				'		);\n' +
				'	}\n' +
				//Tritanope
				'	if (cbtype > 0.66) {\n' +
				'		lms = vec3(	' +
				'			LMS.r,' +
				'			LMS.g,' +
				'			(-0.395913 * LMS.r) + (0.801109 * LMS.g)' +
				'		);\n' +
				'	}\n' +

				// LMS to RGB matrix operation
				'	const mat3 LMSRGB = mat3(    ' +
				'		0.0809444479, -0.130504409, 0.116721066,' +
				'		-0.0102485335, 0.0540193266, -0.113614708,' +
				'		-0.000365296938, -0.00412161469, 0.693511405' +
				'	);\n' +

				'	vec3 RGB = lms * LMSRGB;\n' +

				// Colour shift
				// values may go over 1.0 but will get automatically clamped on output	
				'	RGB.rgb = color.rgb - RGB.rgb;\n' +
				'	RGB.g = 0.7*RGB.r + RGB.g;\n' +
				'	RGB.b = 0.7*RGB.r + RGB.b;\n' +
				'	color.rgb = color.rgb + RGB.rgb;\n' +

				//Output
				'	gl_FragColor = color;\n' +

				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			type: {
				title: 'Type',
				type: 'enum',
				uniform: 'cbtype',
				defaultValue: '0.2',
				options: [
					['0.0', 'Off'],
					['0.2', 'Protanope'],
					['0.6', 'Deuteranope'],
					['0.8', 'Tritanope']
				]
			}
		},
		title: 'Daltonize',
		description: 'Add contrast to colours to assist CVD (colour-blind) users.'
	});
}));
});
require.register("forresto-noflo-seriously/vendor/effects/seriously.directionblur.js", function(exports, require, module){
/* global define, require */
/*
Directional Motion Blur

Adapted from v002 by Anton Marini and Tom Butterworth
* Copyright vade - Anton Marini
* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

http://v002.info/plugins/v002-blurs/
*/
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var passes = [0.2, 0.3, 0.5, 0.8],
		identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]);

	Seriously.plugin('directionblur', function (options) {
		var fbs,
			baseShader,
			loopUniforms = {
				amount: 0,
				angle: 0,
				inputScale: 1,
				resolution: [this.width, this.height],
				transform: identity,
				projection: new Float32Array([
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				])
			};

		return {
			initialize: function (parent) {
				var gl;

				parent();

				gl = this.gl;

				if (!gl) {
					return;
				}

				fbs = [
					new Seriously.util.FrameBuffer(gl, this.width, this.height),
					new Seriously.util.FrameBuffer(gl, this.width, this.height)
				];
			},
			shader: function (inputs, shaderSource) {
				var gl = this.gl,
					/*
					Some devices or browsers (e.g. IE11 preview) don't support enough
					varying vectors, so we need to fallback to a less efficient method
					*/
					maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS),
					defineVaryings = (maxVaryings >= 10 ? '#define USE_VARYINGS' : '');

				baseShader = new Seriously.util.ShaderProgram(gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.vertex = [
					defineVaryings,
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform mat4 projection;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform float angle;',
					'uniform float amount;',
					'uniform float inputScale;',

					'const vec2 zero = vec2(0.0, 0.0);',
					'#ifdef USE_VARYINGS',
					'vec2 one;',
					'vec2 amount1;',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 one;',
					'varying vec2 amount1;',
					'#endif',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position = screenPosition;',
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',

					'	one = vec2(1.0, 1.0) * inputScale;',
					'	if (inputScale < 1.0) {',
					'		one -= 1.0 / resolution;',
					'	}',
					'	vTexCoord = max(zero, min(one, texCoord.st * inputScale));',
					'	amount1 = vec2(cos(angle), sin(angle)) * amount * 5.0 / resolution;',

					'#ifdef USE_VARYINGS',
					'	vec2 amount2 = amount1 * 3.0;',
					'	vec2 amount3 = amount1 * 6.0;',
					'	vec2 amount4 = amount1 * 9.0;',
					'	vec2 amount5 = -amount1;',
					'	vec2 amount6 = amount5 * 3.0;',
					'	vec2 amount7 = amount5 * 6.0;',
					'	vec2 amount8 = amount5 * 9.0;',
					'	vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vTexCoord2 = max(zero, min(one, vTexCoord + amount2));',
					'	vTexCoord3 = max(zero, min(one, vTexCoord + amount3));',
					'	vTexCoord4 = max(zero, min(one, vTexCoord + amount4));',
					'	vTexCoord5 = max(zero, min(one, vTexCoord + amount5));',
					'	vTexCoord6 = max(zero, min(one, vTexCoord + amount6));',
					'	vTexCoord7 = max(zero, min(one, vTexCoord + amount7));',
					'	vTexCoord8 = max(zero, min(one, vTexCoord + amount8));',
					'#endif',
					'}'
				].join('\n');
				shaderSource.fragment = [
					defineVaryings,

					'precision mediump float;\n',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform sampler2D source;',
					'uniform float angle;',
					'uniform float amount;',
					'uniform float inputScale;',

					'#ifdef USE_VARYINGS',
					'varying vec2 vTexCoord1;',
					'varying vec2 vTexCoord2;',
					'varying vec2 vTexCoord3;',
					'varying vec2 vTexCoord4;',
					'varying vec2 vTexCoord5;',
					'varying vec2 vTexCoord6;',
					'varying vec2 vTexCoord7;',
					'varying vec2 vTexCoord8;',
					'#else',
					'varying vec2 amount1;',
					'varying vec2 one;',
					'const vec2 zero = vec2(0.0, 0.0);',
					'#endif',

					'void main(void) {',
					'#ifndef USE_VARYINGS',
					'	vec2 vTexCoord1 = max(zero, min(one, vTexCoord + amount1));',
					'	vec2 vTexCoord2 = max(zero, min(one, vTexCoord + amount1 * 3.0));',
					'	vec2 vTexCoord3 = max(zero, min(one, vTexCoord + amount1 * 6.0));',
					'	vec2 vTexCoord4 = max(zero, min(one, vTexCoord + amount1 * 9.0));',
					'	vec2 vTexCoord5 = max(zero, min(one, vTexCoord - amount1));',
					'	vec2 vTexCoord6 = max(zero, min(one, vTexCoord - amount1 * 3.0));',
					'	vec2 vTexCoord7 = max(zero, min(one, vTexCoord - amount1 * 6.0));',
					'	vec2 vTexCoord8 = max(zero, min(one, vTexCoord - amount1 * 9.0));',
					'#endif',
					'	gl_FragColor = texture2D(source, vTexCoord) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord1) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord2) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord3) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord4) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord5) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord6) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord7) / 9.0;',
					'	gl_FragColor += texture2D(source, vTexCoord8) / 9.0;',
					'}'
				].join('\n');

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				var i,
					fb,
					pass,
					amount,
					width,
					height,
					opts = {
						width: 0,
						height: 0,
						blend: false
					},
					previousPass = 1;

				amount = this.inputs.amount;
				if (!amount) {
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				if (amount <= 0.01) {
					parent(shader, model, uniforms, frameBuffer);
					return;
				}

				loopUniforms.amount = amount;
				loopUniforms.angle = this.inputs.angle;
				loopUniforms.projection[0] = this.height / this.width;

				for (i = 0; i < passes.length; i++) {
					pass = Math.min(1, passes[i] / amount);
					width = Math.floor(pass * this.width);
					height = Math.floor(pass * this.height);

					loopUniforms.source = fb ? fb.texture : this.inputs.source.texture;

					fb = fbs[i % 2];
					loopUniforms.inputScale = previousPass;//pass;
					previousPass = pass;
					opts.width = width;
					opts.height = height;

					parent(shader, model, loopUniforms, fb.frameBuffer, null, opts);
				}

				loopUniforms.source = fb.texture;
				loopUniforms.inputScale = previousPass;
				parent(shader, model, loopUniforms, frameBuffer);
			},
			resize: function () {
				loopUniforms.resolution[0] = this.width;
				loopUniforms.resolution[1] = this.height;
				if (fbs) {
					fbs[0].resize(this.width, this.height);
					fbs[1].resize(this.width, this.height);
				}
			},
			destroy: function () {
				if (fbs) {
					fbs[0].destroy();
					fbs[1].destroy();
					fbs = null;
				}

				if (baseShader) {
					baseShader.destroy();
				}

				loopUniforms = null;
			}
		};
	},
	{
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 0.4,
				min: 0,
				max: 1
			},
			angle: {
				type: 'number',
				uniform: 'angle',
				defaultValue: 0
			}
		},
		title: 'Directional Motion Blur'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.dither.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Shader code:
	Adapted from a blog post by Martin Upitis
	http://devlog-martinsh.blogspot.com.es/2011/03/glsl-dithering.html
	*/

	Seriously.plugin('dither', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'#define mod4(a) (a >= 4 ? a - 4 : a)',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec2 resolution;',

				'const mat4 dither = mat4(' +
					'1.0, 33.0, 9.0, 41.0,' +
					'49.0, 17.0, 57.0, 25.0,' +
					'13.0, 45.0, 5.0, 37.0,' +
					'61.0, 29.0, 53.0, 21.0' +
				');',

				'float find_closest(int x, int y, float c0) {',
				'	float limit = 0.0;',
				'	int x4 = mod4(x);',
				'	int y4 = mod4(y);',
				//annoying hack since GLSL ES doesn't support variable array index
				'	for (int i = 0; i < 4; i++) {',
				'		if (i == x4) {',
				'			for (int j = 0; j < 4; j++) {',
				'				if (j == y4) {',
				'					limit = dither[i][j];',
				'					break;',
				'				}',
				'			}',
				'		}',
				'	}',
				'	if (x < 4) {',
				'		if (y >= 4) {',
				'			limit += 3.0;',
				'		}',
				'	} else {',
				'		if (y >= 4) {',
				'			limit += 1.0;',
				'		} else {',
				'			limit += 2.0;',
				'		}',
				'	}',
				'	limit /= 65.0;',
				'	return c0 < limit ? 0.0 : 1.0;',
				'}',

				'void main (void)  {',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	vec2 coord = vTexCoord * resolution;',
				'	int x = int(mod(coord.x, 8.0));',
				'	int y = int(mod(coord.y, 8.0));',
				'	pixel.r = find_closest(x, y, pixel.r);',
				'	pixel.g = find_closest(x, y, pixel.g);',
				'	pixel.b = find_closest(x, y, pixel.b);',
				'	gl_FragColor = pixel;',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			}
		},
		title: 'Dither'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.edge.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//	Adapted from http://rastergrid.com/blog/2011/01/frei-chen-edge-detector/
	var sqrt = Math.sqrt,
		i, j,
		flatMatrices = [],
		matrices,
		freiChenMatrixConstants,
		sobelMatrixConstants;

	//initialize shader matrix arrays
	function multiplyArray(factor, a) {
		var i;
		for (i = 0; i < a.length; i++) {
			a[i] *= factor;
		}
		return a;
	}

	matrices = [
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [ 1.0, sqrt(2.0), 1.0, 0.0, 0.0, 0.0, -1.0, -sqrt(2.0), -1.0 ]),
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [1.0, 0.0, -1.0, sqrt(2.0), 0.0, -sqrt(2.0), 1.0, 0.0, -1.0]),
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [0.0, -1.0, sqrt(2.0), 1.0, 0.0, -1.0, -sqrt(2.0), 1.0, 0.0]),
		multiplyArray(1.0 / (2.0 * sqrt(2.0)), [sqrt(2.0), -1.0, 0.0, -1.0, 0.0, 1.0, 0.0, 1.0, -sqrt(2.0)]),
		multiplyArray(1.0 / 2.0, [0.0, 1.0, 0.0, -1.0, 0.0, -1.0, 0.0, 1.0, 0.0]),
		multiplyArray(1.0 / 2.0, [-1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, -1.0]),
		multiplyArray(1.0 / 6.0, [1.0, -2.0, 1.0, -2.0, 4.0, -2.0, 1.0, -2.0, 1.0]),
		multiplyArray(1.0 / 6.0, [-2.0, 1.0, -2.0, 1.0, 4.0, 1.0, -2.0, 1.0, -2.0]),
		multiplyArray(1.0 / 3.0, [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
	];

	for (i = 0; i < matrices.length; i++) {
		for (j = 0; j < matrices[i].length; j++) {
			flatMatrices.push(matrices[i][j]);
		}
	}

	freiChenMatrixConstants = new Float32Array(flatMatrices);

	sobelMatrixConstants = new Float32Array([
		1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0,
		1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0
	]);

	Seriously.plugin('edge', {
		shader: function (inputs, shaderSource) {
			var defines;

			if (inputs.mode === 'sobel') {
				defines = '#define N_MATRICES 2\n' +
				'#define SOBEL\n';
			} else {
				//frei-chen
				defines = '#define N_MATRICES 9\n';
			}

			shaderSource.fragment = defines +
				'#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float pixelWidth;\n' +
				'uniform float pixelHeight;\n' +
				'uniform mat3 G[9];\n' +
				'\n' +
				'void main(void) {\n' +
				'	mat3 I;\n' +
				'	float dp3, cnv[9];\n' +
				'	vec3 tc;\n' +

				// fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value
				'	float fi = 0.0, fj = 0.0;\n' +
				'	for (int i = 0; i < 3; i++) {\n' +
				'		fj = 0.0;\n' +
				'		for (int j = 0; j < 3; j++) {\n' +
				'			I[i][j] = length( ' +
							'texture2D(source, ' +
								'vTexCoord + vec2((fi - 1.0) * pixelWidth, (fj - 1.0) * pixelHeight)' +
							').rgb );\n' +
				'			fj += 1.0;\n' +
				'		};\n' +
				'		fi += 1.0;\n' +
				'	};\n' +

				// calculate the convolution values for all the masks

				'	for (int i = 0; i < N_MATRICES; i++) {\n' +
				'		dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\n' +
				'		cnv[i] = dp3 * dp3;\n' +
				'	};\n' +
				'\n' +

				//Sobel
				'#ifdef SOBEL\n' +
				'	tc = vec3(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));\n' +
				'#else\n' +

				//Frei-Chen
				// Line detector
				'	float M = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]);\n' +
				'	float S = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]) + (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + cnv[8];\n' +
				'	tc = vec3(sqrt(M/S));\n' +
				'#endif\n' +

				'	gl_FragColor = vec4(tc, 1.0);\n' +
				'}\n';

			return shaderSource;
		},
		draw: function (shader, model, uniforms, frameBuffer, parent) {

			uniforms.pixelWidth = 1 / this.width;
			uniforms.pixelHeight = 1 / this.height;

			if (this.inputs.mode === 'sobel') {
				uniforms['G[0]'] = sobelMatrixConstants;
			} else {
				uniforms['G[0]'] = freiChenMatrixConstants;
			}

			parent(shader, model, uniforms, frameBuffer);
		},
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			mode: {
				type: 'enum',
				shaderDirty: true,
				defaultValue: 'sobel',
				options: [
					['sobel', 'Sobel'],
					['frei-chen', 'Frei-Chen']
				]
			}
		},
		description: 'Edge Detect',
		title: 'Edge Detect'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.emboss.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('emboss', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float amount;\n' +
				'\n' +
				'uniform vec2 dim;\n' +
				'\n' +
				//'const vec4 weight = vec4(2.0, 2.0, 2.0, 0.5);\n' +
				'const vec3 average = vec3(1.0 / 3.0);\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec2 offset = 1.0 / dim;\n' +
				'	vec4 pixel = vec4(0.5, 0.5, 0.5, 1.0);\n' +
				'	pixel -= texture2D(source, vTexCoord - offset) * amount;\n' +
				'	pixel += texture2D(source, vTexCoord + offset) * amount;\n' +
				'	float val = dot(pixel.rgb, average);\n' +
				'	pixel.rgb = vec3(val);\n' +
				'	gl_FragColor = pixel;\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		draw: function (shader, model, uniforms, frameBuffer, parent) {
			if (!uniforms.dim) {
				uniforms.dim = [];
			}
			uniforms.dim[0] = this.width;
			uniforms.dim[1] = this.height;
			parent(shader, model, uniforms, frameBuffer);
		},
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 1
			}
		},
		title: 'Emboss',
		categories: [],
		description: 'Emboss'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.exposure.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Shader code:
	* Copyright vade - Anton Marini
	* Creative Commons, Attribution - Non Commercial - Share Alike 3.0

	http://v002.info/?page_id=34

	*/

	Seriously.plugin('exposure', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform float exposure;\n' +
				'\n' +
				'//constant variables.\n' +
				'const float sqrtoftwo = 1.41421356237;\n' +
				'\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = log2(vec4(pow(exposure + sqrtoftwo, 2.0))) * pixel;\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			exposure: {
				type: 'number',
				uniform: 'exposure',
				defaultValue: 0.6,
				min: 0,
				max: 1
			}
		},
		title: 'Exposure',
		categories: ['film'],
		description: 'Exposure control'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.fader.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('fader', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec4 color;\n' +
				'uniform float amount;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = mix(gl_FragColor, color, amount);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			color: {
				type: 'color',
				uniform: 'color',
				defaultValue: [0, 0, 0, 1]
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 0.5,
				min: 0,
				max: 1
			}
		},
		title: 'Fader',
		description: 'Fade image to a color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.falsecolor.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('falsecolor', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float amount;\n' +
				'uniform vec4 dark;\n' +
				'uniform vec4 light;\n' +
				'const vec3 luma = vec3(0.2125, 0.7154, 0.0721);\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float luminance = dot(pixel.rgb, luma);\n' +
				'	gl_FragColor = vec4( mix(dark.rgb, light.rgb, luminance), pixel.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			dark: {
				type: 'color',
				uniform: 'dark',
				defaultValue: [0, 0, 0.5, 1]
			},
			light: {
				type: 'color',
				uniform: 'light',
				defaultValue: [1, 0, 0, 1]
			}
		},
		title: 'False Color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.filmgrain.js", function(exports, require, module){
/* global define, require */
/*
Film Grain

Shader:
* Copyright Martins Upitis (martinsh) devlog-martinsh.blogspot.com
* Creative Commons Attribution 3.0 Unported License
http://devlog-martinsh.blogspot.com/2013/05/image-imperfections-and-film-grain-post.html

Modified to preserve alpha

*/
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('filmgrain', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec2 resolution;',
				'uniform float time;',
				'uniform float amount;',
				'uniform bool colored;',

				'float timer;',

				// Perm texture texel-size
				'const float permTexUnit = 1.0/256.0;',

				// Half perm texture texel-size
				'const float permTexUnitHalf = 0.5/256.0;',

				'vec4 rnm(in vec2 tc) {',
				'	float noise = sin(dot(tc + vec2(timer,timer),vec2(12.9898,78.233))) * 43758.5453;',

				'	float noiseR = fract(noise)*2.0-1.0;',
				'	float noiseG = fract(noise*1.2154)*2.0-1.0; ',
				'	float noiseB = fract(noise*1.3453)*2.0-1.0;',
				'	float noiseA = fract(noise*1.3647)*2.0-1.0;',
				'	',
				'	return vec4(noiseR,noiseG,noiseB,noiseA);',
				'}',

				'float fade(in float t) {',
				'	return t*t*t*(t*(t*6.0-15.0)+10.0);',
				'}',

				'float pnoise3D(in vec3 p) {',
					// Integer part, scaled so +1 moves permTexUnit texel
				'	vec3 pi = permTexUnit*floor(p)+permTexUnitHalf;',

				// and offset 1/2 texel to sample texel centers
				// Fractional part for interpolation'
				'	vec3 pf = fract(p);',

				// Noise contributions from (x=0, y=0), z=0 and z=1
				'	float perm00 = rnm(pi.xy).a ;',
				'	vec3 grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0 - 1.0;',
				'	float n000 = dot(grad000, pf);',
				'	vec3 grad001 = rnm(vec2(perm00, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));',

				// Noise contributions from (x=0, y=1), z=0 and z=1
				'	float perm01 = rnm(pi.xy + vec2(0.0, permTexUnit)).a ;',
				'	vec3 grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0 - 1.0;',
				'	float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));',
				'	vec3 grad011 = rnm(vec2(perm01, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));',

				// Noise contributions from (x=1, y=0), z=0 and z=1
				'	float perm10 = rnm(pi.xy + vec2(permTexUnit, 0.0)).a ;',
				'	vec3 grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0 - 1.0;',
				'	float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));',
				'	vec3 grad101 = rnm(vec2(perm10, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));',

				// Noise contributions from (x=1, y=1), z=0 and z=1
				'	float perm11 = rnm(pi.xy + vec2(permTexUnit, permTexUnit)).a ;',
				'	vec3 grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0 - 1.0;',
				'	float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));',
				'	vec3 grad111 = rnm(vec2(perm11, pi.z + permTexUnit)).rgb * 4.0 - 1.0;',
				'	float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));',

				// Blend contributions along x
				'	vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));',

				// Blend contributions along y
				'	vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));',

				//Blend contributions along z
				'	float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));',

				'	return n_xyz;',
				'}',

				'void main(void) {',
				'	timer = mod(time, 10000.0) / 10000.0;',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	vec3 noise = vec3(pnoise3D(vec3(vTexCoord * resolution, timer + 0.0)));',
				'	if (colored) {',
				'		noise.g = pnoise3D(vec3(vTexCoord * resolution, timer + 1.0));',
				'		noise.b = pnoise3D(vec3(vTexCoord * resolution, timer + 2.0));',
				'	}',
				'	gl_FragColor = vec4(pixel.rgb + noise * amount, pixel.a);',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			time: {
				type: 'number',
				uniform: 'time'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				min: 0,
				max: 1,
				defaultValue: 0.03
			},
			colored: {
				type: 'boolean',
				uniform: 'colored',
				defaultValue: false
			}
		},
		title: 'Film Grain',
		description: 'Don\'t over-do it.'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.hex.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*

	Shader adapted from glfx.js by Evan Wallace
	License: https://github.com/evanw/glfx.js/blob/master/LICENSE
	*/

	Seriously.plugin('hex', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec2 resolution;\n' +
				'uniform vec2 center;\n' +
				'uniform float size;\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec2 aspect = normalize(resolution);\n' +
				'	vec2 tex = (vTexCoord * aspect - center) / size;\n' +
				'	tex.y /= 0.866025404;\n' +
				'	tex.x -= tex.y * 0.5;\n' +
				'	vec2 a;\n' +
				'	if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n' +
				'		a = vec2(floor(tex.x), floor(tex.y));\n' +
				'	} else {\n' +
				'		a = vec2(ceil(tex.x), ceil(tex.y));\n' +
				'	}\n' +
				'	vec2 b = vec2(ceil(tex.x), floor(tex.y));\n' +
				'	vec2 c = vec2(floor(tex.x), ceil(tex.y));\n' +
				'	vec3 tex3 = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n' +
				'	vec3 a3 = vec3(a.x, a.y, 1.0 - a.x - a.y);\n' +
				'	vec3 b3 = vec3(b.x, b.y, 1.0 - b.x - b.y);\n' +
				'	vec3 c3 = vec3(c.x, c.y, 1.0 - c.x - c.y);\n' +
				'	float alen =length(tex3 - a3);\n' +
				'	float blen =length(tex3 - b3);\n' +
				'	float clen =length(tex3 - c3);\n' +
				'	vec2 choice;\n' +
				'	if (alen < blen) {\n' +
				'		if (alen < clen) {\n' +
				'			choice = a;\n' +
				'		} else {\n' +
				'			choice = c;\n' +
				'		}\n' +
				'	} else {\n' +
				'		if (blen < clen) {\n' +
				'			choice = b;\n' +
				'		} else {\n' +
				'			choice = c;\n' +
				'		}\n' +
				'	}\n' +
				'	choice.x += choice.y * 0.5;\n' +
				'	choice.y *= 0.866025404;\n' +
				'	choice *= size / aspect;\n' +
				'	gl_FragColor = texture2D(source, choice + center / aspect);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			size: {
				type: 'number',
				uniform: 'size',
				min: 0,
				max: 0.4,
				defaultValue: 0.01
			},
			center: {
				type: 'vector',
				uniform: 'center',
				dimensions: 2,
				defaultValue: [0, 0]
			}
		},
		title: 'Hex',
		description: 'Hexagonal Pixelate'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.highlights-shadows.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('highlights-shadows', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float shadows;\n' +
				'uniform float highlights;\n' +
				'const vec3 luma = vec3(0.2125, 0.7154, 0.0721);\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float luminance = dot(pixel.rgb, luma);\n' +
				'	float shadow = clamp((pow(luminance, 1.0 / (shadows + 1.0)) + (-0.76) * pow(luminance, 2.0 / (shadows + 1.0))) - luminance, 0.0, 1.0);\n' +
				'	float highlight = clamp((1.0 - (pow(1.0 - luminance, 1.0 / (2.0 - highlights)) + (-0.8) * pow(1.0 - luminance, 2.0 / (2.0 - highlights)))) - luminance, -1.0, 0.0);\n' +
				'	vec3 rgb = (luminance + shadow + highlight) * (pixel.rgb / vec3(luminance));\n' +
				//'	vec3 rgb = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((pixel.rgb - vec3(0.0, 0.0, 0.0))/(luminance - 0.0));\n' +
				'	gl_FragColor = vec4(rgb, pixel.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			highlights: {
				type: 'number',
				uniform: 'highlights',
				min: 0,
				max: 1,
				defaultValue: 1
			},
			shadows: {
				type: 'number',
				uniform: 'shadows',
				min: 0,
				max: 1,
				defaultValue: 0
			}
		},
		title: 'Highlights/Shadows',
		description: 'Darken highlights, lighten shadows'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.hue-saturation.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//inspired by Evan Wallace (https://github.com/evanw/glfx.js)

	Seriously.plugin('hue-saturation', {
		shader: function (inputs, shaderSource) {
			shaderSource.vertex = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif ',

				'attribute vec4 position;',
				'attribute vec2 texCoord;',

				'uniform vec2 resolution;',
				'uniform mat4 projection;',
				'uniform mat4 transform;',

				'uniform float hue;',
				'uniform float saturation;',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'varying vec3 weights;',

				'void main(void) {',
				'	float angle = hue * 3.14159265358979323846264;',
				'	float s = sin(angle);',
				'	float c = cos(angle);',
				'	weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;',

				// first convert to screen space
				'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
				'	screenPosition = transform * screenPosition;',

				// convert back to OpenGL coords
				'	gl_Position = screenPosition;',
				'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
				'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
				'	vTexCoord = texCoord;',
				'	vPosition = gl_Position;',
				'}'
			].join('\n');
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'varying vec3 weights;',

				'uniform sampler2D source;',
				'uniform float hue;',
				'uniform float saturation;',

				'void main(void) {',
				'	vec4 color = texture2D(source, vTexCoord);',

				//adjust hue
				'	float len = length(color.rgb);',
				'	color.rgb = vec3(' +
						'dot(color.rgb, weights.xyz), ' +
						'dot(color.rgb, weights.zxy), ' +
						'dot(color.rgb, weights.yzx) ' +
				');',

				//adjust saturation
				'	vec3 adjustment = (color.r + color.g + color.b) / 3.0 - color.rgb;',
				'	if (saturation > 0.0) {',
				'		adjustment *= (1.0 - 1.0 / (1.0 - saturation));',
				'	} else {',
				'		adjustment *= (-saturation);',
				'	}',
				'	color.rgb += adjustment;',

				'	gl_FragColor = color;',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			hue: {
				type: 'number',
				uniform: 'hue',
				defaultValue: 0.4,
				min: -1,
				max: 1
			},
			saturation: {
				type: 'number',
				uniform: 'saturation',
				defaultValue: 0,
				min: -1,
				max: 1
			}
		},
		title: 'Hue/Saturation',
		description: 'Rotate hue and multiply saturation.'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.invert.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('invert', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = vec4(1.0 - gl_FragColor.rgb, gl_FragColor.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			}
		},
		title: 'Invert',
		description: 'Invert image color'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.kaleidoscope.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('kaleidoscope', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES',
				'precision mediump float;',
				'#endif',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform float segments;',
				'uniform float offset;',

				'const float PI = ' + Math.PI + ';',
				'const float TAU = 2.0 * PI;',

				'void main(void) {',
				'	if (segments == 0.0) {',
				'		gl_FragColor = texture2D(source, vTexCoord);',
				'	} else {',
				'		vec2 centered = vTexCoord - 0.5;',
				//to polar
				'		float r = length(centered);',
				'		float theta = atan(centered.y, centered.x);',
				'		theta = mod(theta, TAU / segments);',
				'		theta = abs(theta - PI / segments);',
				//back to cartesian
				'		vec2 newCoords = r * vec2(cos(theta), sin(theta)) + 0.5;',
				'		gl_FragColor = texture2D(source, mod(newCoords - offset, 1.0));',
				'	}',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			segments: {
				type: 'number',
				uniform: 'segments',
				defaultValue: 6
			},
			offset: {
				type: 'number',
				uniform: 'offset',
				defaultValue: 0
			}
		},
		title: 'Kaleidoscope'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.layers.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]),
		intRegex = /\d+/;

	Seriously.plugin('layers', function (options) {
		var count,
			me = this,
			topOpts = {
				clear: false
			},
			i,
			inputs;

		function update() {
			me.resize();
		}

		if (typeof options === 'number' && options >= 2) {
			count = options;
		} else {
			count = options && options.count || 4;
			count = Math.max(2, count);
		}

		inputs = {
			sizeMode: {
				type: 'enum',
				defaultValue: '0',
				options: [
					'union',
					'intersection'
				],
				update: function () {
					this.resize();
				}
			}
		};

		for (i = 0; i < count; i++) {
			inputs.sizeMode.options.push(i.toString());
			inputs.sizeMode.options.push('source' + i);

			//source
			inputs['source' + i] = {
				type: 'image',
				update: update
			};

			//opacity
			inputs['opacity' + i] = {
				type: 'number',
				defaultValue: 1,
				min: 0,
				max: 1,
			};
		}

		this.uniforms.layerResolution = [1, 1];

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				i,
				n,
				source,
				a;

			if (mode === 'union') {
				width = 0;
				height = 0;
				for (i = 0; i < count; i++) {
					source = this.inputs['source' + i];
					if (source) {
						width = Math.max(width, source.width);
						height = Math.max(height, source.height);
					}
				}
			} else if (mode === 'intersection') {
				width = Infinity;
				height = Infinity;
				for (i = 0; i < count; i++) {
					source = this.inputs['source' + i];
					if (source) {
						width = Math.min(width, source.width);
						height = Math.min(height, source.height);
					}
				}
			} else {
				width = 1;
				height = 1;
				n = count - 1;
				a = intRegex.exec(this.inputs.sizeMode);
				if (a) {
					n = Math.min(parseInt(a[0], 10), n);
				}

				for (i = 0; i <= n; i++) {
					source = this.inputs['source' + i];
					if (source) {
						width = source.width;
						height = source.height;
						break;
					}
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			shader: function (inputs, shaderSource) {
				shaderSource.vertex = [
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform vec2 layerResolution;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * layerResolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position.xy = screenPosition.xy * 2.0 / layerResolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (layerResolution.x / layerResolution.y);',
					'	gl_Position.xy *= layerResolution / resolution;',
					'	gl_Position.w = screenPosition.w;',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',
					'}\n'
				].join('\n');

				shaderSource.fragment = [
					'precision mediump float;',
					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',
					'uniform sampler2D source;',
					'uniform float opacity;',
					'void main(void) {',
					'	if (any(lessThan(vTexCoord, vec2(0.0))) || any(greaterThanEqual(vTexCoord, vec2(1.0)))) {',
					'		gl_FragColor = vec4(0.0);',
					'	} else {',
					'		gl_FragColor = texture2D(source, vTexCoord);',
					'		gl_FragColor.a *= opacity;',
					'	}',
					'}'
				].join('\n');

				return shaderSource;
			},
			requires: function (sourceName, inputs) {
				var a, index = count;

				a = intRegex.exec(this.inputs.sizeMode);
				if (a) {
					index = parseInt(a[0], 10);
				}
				if (index >= count) {
					return false;
				}

				return !!(inputs[sourceName] && inputs['opacity' + index]);
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					opacity,
					source,
					gl = this.gl;

				//clear in case we have no layers to draw
				gl.viewport(0, 0, this.width, this.height);
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				for (i = 0; i < count; i++) {
					source = this.inputs['source' + i];
					opacity = this.inputs['opacity' + i];

					//don't draw if layer is disconnected or opacity is 0
					if (source && opacity) {
						uniforms.opacity = opacity;
						uniforms.layerResolution[0] = source.width;
						uniforms.layerResolution[1] = source.height;
						uniforms.source = source;
						uniforms.transform = source.cumulativeMatrix || identity;

						draw(shader, model, uniforms, frameBuffer, null, topOpts);
					}
				}
			},
			inputs: inputs
		};
	},
	{
		inPlace: true,
		description: 'Multiple layers',
		title: 'Layers'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.linear-transfer.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('linear-transfer', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = [
				'#ifdef GL_ES\n',
				'precision mediump float;\n',
				'#endif\n',

				'varying vec2 vTexCoord;',
				'varying vec4 vPosition;',

				'uniform sampler2D source;',
				'uniform vec4 slope;',
				'uniform vec4 intercept;',

				'const vec3 half3 = vec3(0.5);',

				'void main(void) {',
				'	vec4 pixel = texture2D(source, vTexCoord);',
				'	gl_FragColor = pixel * slope + intercept;',
				'}'
			].join('\n');
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			slope: {
				type: 'vector',
				dimensions: 4,
				uniform: 'slope',
				defaultValue: [1, 1, 1, 1]
			},
			intercept: {
				type: 'vector',
				uniform: 'intercept',
				dimensions: 4,
				defaultValue: [0, 0, 0, 0]
			}
		},
		title: 'Linear Transfer',
		description: 'For each color channel: [slope] * [value] + [intercept]'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.lumakey.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('lumakey', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform float threshold;\n' +
				'uniform float clipBlack;\n' +
				'uniform float clipWhite;\n' +
				'uniform bool invert;\n' +
				'\n' +
				'const vec3 lumcoeff = vec3(0.2125,0.7154,0.0721);\n' +
				'\n' +
				'void main (void)  {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float luma = dot(pixel.rgb,lumcoeff);\n' +
				'	float alpha = 1.0 - smoothstep(clipBlack, clipWhite, luma);\n' +
				'	if (invert) alpha = 1.0 - alpha;\n' +
				'	gl_FragColor = vec4(pixel.rgb, min(pixel.a, alpha) );\n' +
				'\n' +
				'} \n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			clipBlack: {
				type: 'number',
				uniform: 'clipBlack',
				defaultValue: 0.9,
				min: 0,
				max: 1
			},
			clipWhite: {
				type: 'number',
				uniform: 'clipWhite',
				defaultValue: 1,
				min: 0,
				max: 1
			},
			invert: {
				type: 'boolean',
				uniform: 'invert',
				defaultValue: false
			}
		},
		title: 'Luma Key',
		categories: ['key'],
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.nightvision.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//based on tutorial: http://www.geeks3d.com/20091009/shader-library-night-vision-post-processing-filter-glsl/
	//todo: make noise better?

	Seriously.plugin('nightvision', {
		shader: function (inputs, shaderSource, utilities) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform float timer;\n' +
					'uniform float luminanceThreshold;\n' +
					'uniform float amplification;\n' +
					'uniform vec3 nightVisionColor;\n' +
					'\n' +
					utilities.shader.makeNoise +
					'\n' +
					'void main(void) {\n' +
					'	vec3 noise = vec3(' +
							'makeNoise(vTexCoord.x, vTexCoord.y, timer), ' +
							'makeNoise(vTexCoord.x, vTexCoord.y, timer * 200.0 + 1.0), ' +
							'makeNoise(vTexCoord.x, vTexCoord.y, timer * 100.0 + 3.0)' +
						');\n' +
					'	vec4 pixel = texture2D(source, vTexCoord + noise.xy * 0.0025);\n' +
					'	float luminance = dot(vec3(0.299, 0.587, 0.114), pixel.rgb);\n' +
					'	pixel.rgb *= step(luminanceThreshold, luminance) * amplification;\n' +
					'	gl_FragColor = vec4( (pixel.rgb + noise * 0.1) * nightVisionColor, pixel.a);\n' +
					'}\n';
			return shaderSource;
		},
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			timer: {
				type: 'number',
				uniform: 'timer',
				defaultValue: 0
			},
			luminanceThreshold: {
				type: 'number',
				uniform: 'luminanceThreshold',
				defaultValue: 0.1,
				min: 0,
				max: 1
			},
			amplification: {
				type: 'number',
				uniform: 'amplification',
				defaultValue: 1.4,
				min: 0
			},
			color: {
				type: 'color',
				uniform: 'nightVisionColor',
				defaultValue: [0.1, 0.95, 0.2]
			}
		},
		title: 'Night Vision',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.noise.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('noise', {
		shader: function (inputs, shaderSource, utilities) {
			var frag = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'#define Blend(base, blend, funcf)		vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))\n' +
				'#define BlendOverlayf(base, blend) (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\n' +
				'#define BlendOverlay(base, blend)		Blend(base, blend, BlendOverlayf)\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'\n' +
				'uniform vec2 resolution;\n' +
				'uniform float amount;\n' +
				'uniform float timer;\n' +

				utilities.shader.noiseHelpers +
				utilities.shader.snoise3d +
				utilities.shader.random +

				'void main(void) {\n' +
				'	vec4 pixel = texture2D(source, vTexCoord);\n' +
				'	float r = random(vec2(timer * vTexCoord.xy));\n' +
				'	float noise = snoise(vec3(vTexCoord * (1024.4 + r * 512.0), timer)) * 0.5;';

			if (inputs.overlay) {
				frag += '	vec3 overlay = BlendOverlay(pixel.rgb, vec3(noise));\n' +
						'	pixel.rgb = mix(pixel.rgb, overlay, amount);\n';
			} else {
				frag += '	pixel.rgb += noise * amount;\n';
			}
			frag += '	gl_FragColor = pixel;\n}';

			shaderSource.fragment = frag;
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			overlay: {
				type: 'boolean',
				shaderDirty: true,
				defaultValue: true
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				min: 0,
				max: 1,
				defaultValue: 1
			},
			timer: {
				type: 'number',
				uniform: 'timer',
				defaultValue: 0,
				step: 1
			}
		},
		title: 'Noise',
		description: 'Add noise'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.repeat.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var identity = new Float32Array([
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
		]),
		mat4 = Seriously.util.mat4;

	Seriously.plugin('repeat', function () {
		var drawOpts = {
				clear: false
			},
			transform = new Float32Array(16),
			me = this;

		function resize() {
			me.resize();
		}

		// custom resize method
		this.resize = function () {
			var width = this.width,
				height = this.height,
				source = me.inputs.source,
				i;

			if (this.source) {
				width = this.source.width;
				height = this.source.height;
			} else if (this.sources && this.sources.source) {
				width = this.sources.source.width;
				height = this.sources.source.height;
			} else {
				width = 1;
				height = 1;
			}

			if (me.inputs.width) {
				width = me.inputs.width;
				if (me.inputs.height) {
					height = me.inputs.height;
				} else if (source) {
					//match source aspect ratio
					height = width * source.height / source.width;
				}
			} else if (me.inputs.height) {
				height = me.inputs.height;
				if (source) {
					//match source aspect ratio
					width = height * source.width / source.height;
				}
			}

			if (source) {
				this.uniforms.resolution[0] = source.width;
				this.uniforms.resolution[1] = source.height;
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.targetRes[0] = this.width;
				this.uniforms.targetRes[1] = this.height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(this.width, this.height);
				}

				this.setDirty();
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		this.uniforms.targetRes = [1, 1];

		return {
			initialize: function (initialize) {
				initialize();
				this.uniforms.transform = transform;
			},
			shader: function (inputs, shaderSource) {
				shaderSource.vertex = [
					'precision mediump float;',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform vec2 targetRes;',
					'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'void main(void) {',
					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position = screenPosition;',
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	gl_Position.xy *= resolution / targetRes;',
					'	vTexCoord = texCoord;',
					'	vPosition = gl_Position;',
					'}\n'
				].join('\n');
				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					source = this.inputs.source,
					transform = this.inputs.transform,
					transformMatrix = transform && transform.cumulativeMatrix,
					repeat = this.inputs.repeat,
					gl = this.gl;

				if (transformMatrix && transform.transformed) {
					mat4.copy(uniforms.transform, source && source.cumulativeMatrix || identity);
				} else {
					repeat = Math.min(repeat, 1);
				}

				// first, clear
				gl.viewport(0, 0, this.width, this.height);
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				for (i = repeat - 1; i >= 0; i--) {
					draw(shader, model, uniforms, frameBuffer, null, drawOpts);
					if (i) {
						mat4.multiply(uniforms.transform, transformMatrix, uniforms.transform);
					}
				}
			},
			inputs: {
				source: {
					type: 'image',
					uniform: 'source',
					update: function () {
						resize();
						this.uniforms.transform = transform;
					}
				},
				transform: {
					type: 'image'
				},
				repeat: {
					type: 'number',
					step: 1,
					min: 0,
					defaultValue: 8
				},
				width: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				},
				height: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				}
			}
		};
	},
	{
		inPlace: true,
		description: 'Draw image multiple times, transforming each time',
		title: 'Repeat'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.ripple.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//http://msdn.microsoft.com/en-us/library/bb313868(v=xnagamestudio.10).aspx
	Seriously.plugin('ripple', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform float wave;\n' +
				'uniform float distortion;\n' +
				'uniform vec2 center;\n' +
				'\n' +
				'void main(void) {\n' +
				//todo: can at least move scalar into vertex shader
				'	float scalar = abs(1.0 - abs(distance(vTexCoord, center)));\n' +
				'	float sinOffset = sin(wave / scalar);\n' +
				'	sinOffset = clamp(sinOffset, 0.0, 1.0);\n' +
				'	float sinSign = cos(wave / scalar);\n' +
				'	sinOffset = sinOffset * distortion / 32.0;\n' +
				'	gl_FragColor = texture2D(source, vTexCoord + sinOffset * sinSign);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			wave: {
				type: 'number',
				uniform: 'wave',
				defaultValue: Math.PI / 0.75
			},
			distortion: {
				type: 'number',
				uniform: 'distortion',
				defaultValue: 1
			},
			center: {
				type: 'vector',
				uniform: 'center',
				dimensions: 2,
				defaultValue: [0.5, 0.5]
			}
		},
		title: 'Ripple Distortion',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.scanlines.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('scanlines', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform float lines;\n' +
					'uniform float width;\n' +
					'uniform float intensity;\n' +
					//todo: add vertical offset for animating
					'\n' +
					'void main(void) {\n' +
					'	vec4 pixel = texture2D(source, vTexCoord);\n' +
					'	float darken = 2.0 * abs( fract(vPosition.y * lines / 2.0) - 0.5);\n' +
					'	darken = clamp(darken - width + 0.5, 0.0, 1.0);\n' +
					'	darken = 1.0 - ((1.0 - darken) * intensity);\n' +
					'	gl_FragColor = vec4(pixel.rgb * darken, 1.0);\n' +
					'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			lines: {
				type: 'number',
				uniform: 'lines',
				defaultValue: 60
			},
			size: {
				type: 'number',
				uniform: 'size',
				defaultValue: 0.2,
				min: 0,
				max: 1
			},
			intensity: {
				type: 'number',
				uniform: 'intensity',
				defaultValue: 0.1,
				min: 0,
				max: 1
			}
		},
		title: 'Scan Lines',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.sepia.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	// sepia coefficients borrowed from:
	// http://www.techrepublic.com/blog/howdoi/how-do-i-convert-images-to-grayscale-and-sepia-tone-using-c/120

	Seriously.plugin('sepia', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec4 light;\n' +
				'uniform vec4 dark;\n' +
				'uniform float desat;\n' +
				'uniform float toned;\n' +
				'\n' +
				'const mat4 coeff = mat4(' +
					'0.393, 0.349, 0.272, 1.0,' +
					'0.796, 0.686, 0.534, 1.0, ' +
					'0.189, 0.168, 0.131, 1.0, ' +
					'0.0, 0.0, 0.0, 1.0 ' +
				');\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 sourcePixel = texture2D(source, vTexCoord);\n' +
				'	gl_FragColor = coeff * sourcePixel;\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			}
		},
		title: 'Sepia',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.simplex.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('simplex', function () {
		var me = this;

		function resize() {
			me.resize();
		}

		return {
			shader: function (inputs, shaderSource, utilities) {
				var frequency = 1,
					amplitude = 1,
					i,
					adjust = 0;

				function fmtFloat(n) {
					if (n - Math.floor(n) === 0) {
						return n + '.0';
					}
					return n;
				}

				shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'\n' +
					'uniform float amount;\n' +
					'uniform vec2 noiseScale;\n' +
					'uniform vec2 noiseOffset;\n' +
					'uniform float time;\n' +

					utilities.shader.noiseHelpers +
					utilities.shader.snoise3d +
					//utilities.shader.random +

					'void main(void) {\n' +
					'	float total = 0.0;\n' +
					'	vec3 pos = vec3(vTexCoord.xy * noiseScale + noiseOffset, time);\n';

				for (i = 0; i < inputs.octaves; i++) {
					frequency = Math.pow(2, i);
					amplitude = Math.pow(inputs.persistence, i);
					adjust += amplitude;
					shaderSource.fragment += '\ttotal += snoise(pos * ' + fmtFloat(frequency) + ') * ' + fmtFloat(amplitude) + ';\n';
				}
				shaderSource.fragment += '\ttotal *= amount / ' + fmtFloat(adjust) + ';\n' +
				'	total = (total + 1.0)/ 2.0;\n' +
				'	gl_FragColor = vec4(total, total, total, 1.0);\n' +
				'}';

				return shaderSource;
			},
			inputs: {
				source: {
					type: 'image',
					uniform: 'source'
				},
				noiseScale: {
					type: 'vector',
					dimensions: 2,
					uniform: 'noiseScale',
					defaultValue: [1, 1]
				},
				noiseOffset: {
					type: 'vector',
					dimensions: 2,
					uniform: 'noiseOffset',
					defaultValue: [0, 0]
				},
				octaves: {
					type: 'number',
					shaderDirty: true,
					min: 1,
					max: 8,
					step: 1,
					defaultValue: 1
				},
				persistence: {
					type: 'number',
					defaultValue: 0.5,
					min: 0,
					max: 0.5
				},
				amount: {
					type: 'number',
					uniform: 'amount',
					min: 0,
					defaultValue: 1
				},
				time: {
					type: 'number',
					uniform: 'time',
					defaultValue: 0
				},
				width: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				},
				height: {
					type: 'number',
					min: 0,
					step: 1,
					update: resize,
					defaultValue: 0
				}
			}
		};
	}, {
		title: 'Simplex Noise',
		description: 'Generate Simplex Noise'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.sketch.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/* inspired by http://lab.adjazent.com/2009/01/09/more-pixel-bender/ */

	Seriously.plugin('sketch', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				//todo: make adjust adjustable
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec2 resolution;\n' +
				'\n' +
				'float res = resolution.x;\n' +
				'float n0 = 97.0 / res;\n' +
				'float n1 = 15.0 / res;\n' +
				'float n2 = 97.0 / res;\n' +
				'float n3 = 9.7 / res;\n' +
				'float total = n2 + ( 4.0 * n0 ) + ( 4.0 * n1 );\n' +
				'const vec3 div3 = vec3(1.0 / 3.0);\n' +
				'\n' +
				'void main(void) {\n' +
				'	float offset, temp1, temp2;\n' +
				'	vec4 m, p0, p1, p2, p3, p4, p5, p6, p7, p8;\n' +
				'	offset = n3;\n' +

				'	p0=texture2D(source,vTexCoord);\n' +
				'	p1=texture2D(source,vTexCoord+vec2(-offset,-offset));\n' +
				'	p2=texture2D(source,vTexCoord+vec2( offset,-offset));\n' +
				'	p3=texture2D(source,vTexCoord+vec2( offset, offset));\n' +
				'	p4=texture2D(source,vTexCoord+vec2(-offset, offset));\n' +

				'	offset=n3*2.0;\n' +

				'	p5=texture2D(source,vTexCoord+vec2(-offset,-offset));\n' +
				'	p6=texture2D(source,vTexCoord+vec2( offset,-offset));\n' +
				'	p7=texture2D(source,vTexCoord+vec2( offset, offset));\n' +
				'	p8=texture2D(source,vTexCoord+vec2(-offset, offset));\n' +
				'	m = (p0 * n2 + (p1 + p2 + p3 + p4) * n0 + (p5 + p6 + p7 + p8) * n1) / total;\n' +

					//convert to b/w
				'	temp1 = dot(p0.rgb, div3);\n' +
				'	temp2 = dot(m.rgb, div3);\n' +

					//color dodge blend mode
				'	if (temp2 <= 0.0005) {\n' +
				'		gl_FragColor = vec4( 1.0, 1.0, 1.0, p0.a);\n' +
				'	} else {\n' +
				'		gl_FragColor = vec4( vec3(min(temp1 / temp2, 1.0)), p0.a);\n' +
				'	}\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			}
		},
		title: 'Sketch',
		description: 'Pencil/charcoal sketch'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.split.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('split', function () {
		var baseShader,
			resolutionA = [1, 1],
			resolutionB = [1, 1];

		// custom resize method
		this.resize = function () {
			var width,
				height,
				mode = this.inputs.sizeMode,
				node,
				fn,
				i,
				sourceA = this.inputs.sourceA,
				sourceB = this.inputs.sourceB;

			if (mode === 'a' || mode === 'b') {
				node = mode === 'a' ? sourceA : sourceB;
				if (node) {
					width = node.width;
					height = node.height;
				} else {
					width = 1;
					height = 1;
				}
			} else {
				if (sourceA) {
					if (sourceB) {
						fn = (mode === 'union' ? Math.max : Math.min);
						width = fn(sourceA.width, sourceB.width);
						height = fn(sourceA.height, sourceB.height);
					} else {
						width = sourceA.width;
						height = sourceA.height;
					}
				} else if (sourceB) {
					width = sourceB.width;
					height = sourceB.height;
				} else {
					width = 1;
					height = 1;
				}
			}

			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.uniforms.resolution[0] = width;
				this.uniforms.resolution[1] = height;

				if (this.frameBuffer) {
					this.frameBuffer.resize(width, height);
				}

				this.setDirty();
			}

			if (sourceA) {
				resolutionA[0] = sourceA.width;
				resolutionA[1] = sourceA.height;
			}
			if (sourceB) {
				resolutionB[0] = sourceB.width;
				resolutionB[1] = sourceB.height;
			}

			for (i = 0; i < this.targets.length; i++) {
				this.targets[i].resize();
			}
		};

		return {
			initialize: function (initialize) {
				initialize();
				this.uniforms.resolutionA = resolutionA;
				this.uniforms.resolutionB = resolutionB;
			},
			shader: function (inputs, shaderSource) {
				baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.vertex = [
					'#ifdef GL_ES',
					'precision mediump float;',
					'#endif ',

					'attribute vec4 position;',
					'attribute vec2 texCoord;',

					'uniform vec2 resolution;',
					'uniform vec2 resolutionA;',
					'uniform vec2 resolutionB;',
					'uniform mat4 projection;',
					//'uniform mat4 transform;',

					'varying vec2 vTexCoord;',
					'varying vec2 vTexCoordA;',
					'varying vec2 vTexCoordB;',
					'varying vec4 vPosition;',

					'uniform float angle;',
					'varying float c;',
					'varying float s;',
					'varying float t;',

					'void main(void) {',
					'   c = cos(angle);',
					'   s = sin(angle);',
					'	t = abs(c + s);',

					// first convert to screen space
					'	vec4 screenPosition = vec4(position.xy * resolution / 2.0, position.z, position.w);',
					//'	screenPosition = transform * screenPosition;',

					// convert back to OpenGL coords
					'	gl_Position.xy = screenPosition.xy * 2.0 / resolution;',
					'	gl_Position.z = screenPosition.z * 2.0 / (resolution.x / resolution.y);',
					'	gl_Position.w = screenPosition.w;',

					'	vec2 adjustedTexCoord = (texCoord - 0.5) * resolution;',
					'	vTexCoordA = adjustedTexCoord / resolutionA + 0.5;',
					'	vTexCoordB = adjustedTexCoord / resolutionB + 0.5;',
					'	vTexCoord = texCoord;',

					'	vPosition = gl_Position;',
					'}'
				].join('\n');
				shaderSource.fragment = [
					'#ifdef GL_ES\n',
					'precision mediump float;\n',
					'#endif\n',

					'varying vec2 vTexCoord;',
					'varying vec2 vTexCoordA;',
					'varying vec2 vTexCoordB;',
					'varying vec4 vPosition;',

					'varying float c;',
					'varying float s;',
					'varying float t;',

					'uniform sampler2D sourceA;',
					'uniform sampler2D sourceB;',
					'uniform float split;',
					'uniform float angle;',
					'uniform float fuzzy;',

					'vec4 textureLookup(sampler2D tex, vec2 texCoord) {',
					'	if (any(lessThan(texCoord, vec2(0.0))) || any(greaterThan(texCoord, vec2(1.0)))) {',
					'		return vec4(0.0);',
					'	} else {',
					'		return texture2D(tex, texCoord);',
					'	}',
					'}',

					'void main(void) {',
					'	float mn = (split - fuzzy * (1.0 - split));',
					'	float mx = (split + fuzzy * split);;',
					'	vec2 coords = vTexCoord - vec2(0.5);',
					'	coords = vec2(coords.x * c - coords.y * s, coords.x * s + coords.y * c);',
					'	float scale = max(abs(c - s), abs(s + c));',
					'	coords /= scale;',
					'	coords += vec2(0.5);',
					'	float x = coords.x;;',
					'	if (x <= mn) {',
					'		gl_FragColor = textureLookup(sourceB, vTexCoordB);',
					'		return;',
					'	}',
					'	if (x >= mx) {',
					'		gl_FragColor = textureLookup(sourceA, vTexCoordA);',
					'		return;',
					'	}',
					'	vec4 pixel1 = textureLookup(sourceA, vTexCoordA);',
					'	vec4 pixel2 = textureLookup(sourceB, vTexCoordB);',
					'	gl_FragColor = mix(pixel2, pixel1, smoothstep(mn, mx, x));',
					'}'
				].join('\n');

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				if (uniforms.split >= 1) {
					uniforms.source = uniforms.sourceB;
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				if (uniforms.split <= 0) {
					uniforms.source = uniforms.sourceA;
					parent(baseShader, model, uniforms, frameBuffer);
					return;
				}

				parent(shader, model, uniforms, frameBuffer);
			},
			inPlace: false,
			requires: function (sourceName, inputs) {
				if (sourceName === 'sourceA' && inputs.split >= 1) {
					return false;
				}

				if (sourceName === 'sourceB' && inputs.split <= 0) {
					return false;
				}

				return true;
			}
		};
	},
	{
		inputs: {
			sourceA: {
				type: 'image',
				uniform: 'sourceA',
				shaderDirty: false,
				update: function () {
					this.resize();
				}
			},
			sourceB: {
				type: 'image',
				uniform: 'sourceB',
				shaderDirty: false,
				update: function () {
					this.resize();
				}
			},
			sizeMode: {
				type: 'enum',
				defaultValue: 'a',
				options: [
					'a',
					'b',
					'union',
					'intersection'
				],
				update: function () {
					this.resize();
				}
			},
			split: {
				type: 'number',
				uniform: 'split',
				defaultValue: 0.5,
				min: 0,
				max: 1
			},
			angle: {
				type: 'number',
				uniform: 'angle',
				defaultValue: 0
			},
			fuzzy: {
				type: 'number',
				uniform: 'fuzzy',
				defaultValue: 0,
				min: 0,
				max: 1
			}
		},
		description: 'Split screen or wipe',
		title: 'Split'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.tone.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('tone', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying vec2 vTexCoord;\n' +
				'varying vec4 vPosition;\n' +
				'\n' +
				'uniform sampler2D source;\n' +
				'uniform vec4 light;\n' +
				'uniform vec4 dark;\n' +
				'uniform float desat;\n' +
				'uniform float toned;\n' +
				'\n' +
				'const vec3 lumcoeff = vec3(0.2125,0.7154,0.0721);\n' +
				'\n' +
				'void main(void) {\n' +
				'	vec4 sourcePixel = texture2D(source, vTexCoord);\n' +
				'	vec3 sceneColor = light.rgb * sourcePixel.rgb;\n' +
				'	vec3 gray = vec3(dot(lumcoeff, sceneColor));\n' +
				'	vec3 muted = mix(sceneColor, gray, desat);\n' +
				'	vec3 tonedColor = mix(dark.rgb, light.rgb, gray);\n' +
				'	gl_FragColor = vec4(mix(muted, tonedColor, toned), sourcePixel.a);\n' +
				'}\n';
			return shaderSource;
		},
		inPlace: true,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			light: {
				type: 'color',
				uniform: 'light',
				defaultValue: [1, 0.9, 0.5, 1]
			},
			dark: {
				type: 'color',
				uniform: 'dark',
				defaultValue: [0.2, 0.05, 0, 1]
			},
			toned: {
				type: 'number',
				uniform: 'toned',
				defaultValue: 1,
				minimumRange: 0,
				maximumRange: 1
			},
			desat: {
				type: 'number',
				uniform: 'desat',
				defaultValue: 0.5,
				minimumRange: 0,
				maximumRange: 1
			}
		},
		title: 'Tone',
		description: ''
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.tvglitch.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	//particle parameters
	var minVelocity = 0.2,
		maxVelocity = 0.8,
		minSize = 0.02,
		maxSize = 0.3,
		particleCount = 20;

	Seriously.plugin('tvglitch', function () {
		var lastHeight,
			lastTime,
			particleBuffer,
			particleShader,
			particleFrameBuffer,
			gl;

		return {
			initialize: function (parent) {
				var i,
					sizeRange,
					velocityRange,
					particleVertex,
					particleFragment,
					particles;

				gl = this.gl;

				lastHeight = this.height;

				//initialize particles
				particles = [];
				sizeRange = maxSize - minSize;
				velocityRange = maxVelocity - minVelocity;
				for (i = 0; i < particleCount; i++) {
					particles.push(Math.random() * 2 - 1); //position
					particles.push(Math.random() * velocityRange + minVelocity); //velocity
					particles.push(Math.random() * sizeRange + minSize); //size
					particles.push(Math.random() * 0.2); //intensity
				}

				particleBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(particles), gl.STATIC_DRAW);
				particleBuffer.itemSize = 4;
				particleBuffer.numItems = particleCount;

				particleVertex = '#ifdef GL_ES\n' +
				'precision mediump float;\n' +
				'#endif \n' +
				'\n' +
				'attribute vec4 particle;\n' +
				'\n' +
				'uniform float time;\n' +
				'uniform float height;\n' +
				'\n' +
				'varying float intensity;\n' +
				'\n' +
				'void main(void) {\n' +
				'	float y = particle.x + time * particle.y;\n' +
				'	y = fract((y + 1.0) / 2.0) * 4.0 - 2.0;\n' +
				'	intensity = particle.w;\n' +
				'	gl_Position = vec4(0.0, -y , 1.0, 2.0);\n' +
				//'	gl_Position = vec4(0.0, 1.0 , 1.0, 1.0);\n' +
				'	gl_PointSize = height * particle.z;\n' +
				'}\n';

				particleFragment = '#ifdef GL_ES\n\n' +
				'precision mediump float;\n\n' +
				'#endif\n\n' +
				'\n' +
				'varying float intensity;\n' +
				'\n' +
				'void main(void) {\n' +
				'	gl_FragColor = vec4(1.0);\n' +
				'	gl_FragColor.a = 2.0 * intensity * (1.0 - abs(gl_PointCoord.y - 0.5));\n' +
				'}\n';

				particleShader = new Seriously.util.ShaderProgram(gl, particleVertex, particleFragment);

				particleFrameBuffer = new Seriously.util.FrameBuffer(gl, 1, this.height / 2);
				parent();
			},
			shader: function (inputs, shaderSource) {
				//baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);

				shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					//'#define HardLight(top, bottom) (top < 0.5 ? (2.0 * top * bottom) : (1.0 - 2.0 * (1.0 - top) * (1.0 - bottom)))\n' +
					'#define HardLight(top, bottom)  (1.0 - 2.0 * (1.0 - top) * (1.0 - bottom))\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform sampler2D particles;\n' +
					'uniform float time;\n' +
					'uniform float scanlines;\n' +
					'uniform float lineSync;\n' +
					'uniform float lineHeight;\n' + //for scanlines and distortion
					'uniform float distortion;\n' +
					'uniform float vsync;\n' +
					'uniform float bars;\n' +
					'uniform float frameSharpness;\n' +
					'uniform float frameShape;\n' +
					'uniform float frameLimit;\n' +
					'uniform vec4 frameColor;\n' +
					'\n' +
					//todo: need much better pseudo-random number generator
					Seriously.util.shader.noiseHelpers +
					Seriously.util.shader.snoise2d +
					'\n' +
					'void main(void) {\n' +
					'	vec2 texCoord = vTexCoord;\n' +

						//distortion
					'	float drandom = snoise(vec2(time * 50.0, texCoord.y /lineHeight));\n' +
					'	float distortAmount = distortion * (drandom - 0.25) * 0.5;\n' +
						//line sync
					'	vec4 particleOffset = texture2D(particles, vec2(0.0, texCoord.y));\n' +
					'	distortAmount -= lineSync * (2.0 * particleOffset.a - 0.5);\n' +

					'	texCoord.x -= distortAmount;\n' +
					//'	texCoord.x = max(0.0, texCoord.x);\n' +
					//'	texCoord.x = min(1.0, texCoord.x);\n' +
					'	texCoord.x = mod(texCoord.x, 1.0);\n' +

						//vertical sync
					'	float roll;\n' +
					'	if (vsync != 0.0) {\n' +
					'		roll = fract(time / vsync);\n' +
					'		texCoord.y = mod(texCoord.y - roll, 1.0);\n' +
					'	}\n' +

					'	vec4 pixel = texture2D(source, texCoord);\n' +

						//horizontal bars
					'	float barsAmount = particleOffset.r;\n' +
					'	if (barsAmount > 0.0) {\n' +
					/*
					'		pixel = vec4(HardLight(pixel.r * bars, barsAmount),' +
								'HardLight(pixel.g * bars, barsAmount),' +
								'HardLight(pixel.b * bars, barsAmount),' +
								'pixel.a);\n' +
					*/
					'		pixel = vec4(pixel.r + bars * barsAmount,' +
								'pixel.g + bars * barsAmount,' +
								'pixel.b + bars * barsAmount,' +
								'pixel.a);\n' +
					'	}\n' +

					'	if (mod(texCoord.y / lineHeight, 2.0) < 1.0 ) {\n' +
					'		pixel.rgb *= (1.0 - scanlines);\n' +
					'	}\n' +

					'	float f = (1.0 - vPosition.x * vPosition.x) * (1.0 - vPosition.y * vPosition.y);\n' +
					'	float frame = clamp( frameSharpness * (pow(f, frameShape) - frameLimit), 0.0, 1.0);\n' +

					//'	gl_FragColor.r = vec4(1.0);\n' +

					'	gl_FragColor = mix(frameColor, pixel, frame); //vec4(vec3(particleOffset), 1.0);\n' +
					//'	gl_FragColor = vec4(particleOffset);\n' +
					//'	gl_FragColor.a = 1.0;\n' +
					'}\n';

				return shaderSource;
			},
			draw: function (shader, model, uniforms, frameBuffer, parent) {
				var doParticles = (lastTime !== this.inputs.time),
					vsyncPeriod;

				if (lastHeight !== this.height) {
					lastHeight = this.height;
					//todo: adjust framebuffer height?
					doParticles = true;
				}

				//todo: make this configurable?
				uniforms.lineHeight = 1 / this.height;

				if (this.inputs.verticalSync) {
					vsyncPeriod = 0.2 / this.inputs.verticalSync;
					uniforms.vsync = vsyncPeriod;
				} else {
					vsyncPeriod = 1;
					uniforms.vsync = 0;
				}
				uniforms.time = (this.inputs.time % (10000 * vsyncPeriod)) / 1000;
				uniforms.distortion = Math.random() * this.inputs.distortion;

				//render particle canvas and attach uniform
				//todo: this is a good spot for parallel processing. ParallelArray maybe?
				if (doParticles && (this.inputs.lineSync || this.inputs.bars)) {
					particleShader.use();
					gl.viewport(0, 0, 1, this.height / 2);
					gl.bindFramebuffer(gl.FRAMEBUFFER, particleFrameBuffer.frameBuffer);
					gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
					gl.enableVertexAttribArray(particleShader.location.particle);
					gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);
					gl.vertexAttribPointer(particleShader.location.particle, particleBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.enable(gl.BLEND);
					gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
					particleShader.time.set(uniforms.time);
					particleShader.height.set(this.height);
					gl.drawArrays(gl.POINTS, 0, particleCount);

					lastTime = this.inputs.time;
				}
				uniforms.particles = particleFrameBuffer.texture;

				parent(shader, model, uniforms, frameBuffer);
			},
			destroy: function () {
				particleBuffer = null;
				if (particleFrameBuffer) {
					particleFrameBuffer.destroy();
					particleFrameBuffer = null;
				}
			}
		};
	},
	{
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source',
				shaderDirty: false
			},
			time: {
				type: 'number',
				defaultValue: 0
			},
			distortion: {
				type: 'number',
				defaultValue: 0.1,
				min: 0,
				max: 1
			},
			verticalSync: {
				type: 'number',
				defaultValue: 0.1,
				min: 0,
				max: 1
			},
			lineSync: {
				type: 'number',
				uniform: 'lineSync',
				defaultValue: 0.2,
				min: 0,
				max: 1
			},
			scanlines: {
				type: 'number',
				uniform: 'scanlines',
				defaultValue: 0.3,
				min: 0,
				max: 1
			},
			bars: {
				type: 'number',
				uniform: 'bars',
				defaultValue: 0,
				min: 0,
				max: 1
			},
			frameShape: {
				type: 'number',
				uniform: 'frameShape',
				min: 0,
				max: 2,
				defaultValue: 0.27
			},
			frameLimit: {
				type: 'number',
				uniform: 'frameLimit',
				min: -1,
				max: 1,
				defaultValue: 0.34
			},
			frameSharpness: {
				type: 'number',
				uniform: 'frameSharpness',
				min: 0,
				max: 40,
				defaultValue: 8.4
			},
			frameColor: {
				type: 'color',
				uniform: 'frameColor',
				defaultValue: [0, 0, 0, 1]
			}
		},
		title: 'TV Glitch'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.vignette.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	Seriously.plugin('vignette', {
		shader: function (inputs, shaderSource) {
			shaderSource.fragment = '#ifdef GL_ES\n\n' +
					'precision mediump float;\n\n' +
					'#endif\n\n' +
					'\n' +
					'varying vec2 vTexCoord;\n' +
					'varying vec4 vPosition;\n' +
					'\n' +
					'uniform sampler2D source;\n' +
					'uniform float amount;\n' +
					'\n' +
					'void main(void) {\n' +
					'	vec4 pixel = texture2D(source, vTexCoord);\n' +
					'	vec2 pos = vTexCoord.xy - 0.5;\n' +
					'	float vignette = 1.0 - (dot(pos, pos) * amount);\n' +
					'	gl_FragColor = vec4(pixel.rgb * vignette, pixel.a);\n' +
					'}\n';
			return shaderSource;
		},
		inPlace: false,
		inputs: {
			source: {
				type: 'image',
				uniform: 'source'
			},
			amount: {
				type: 'number',
				uniform: 'amount',
				defaultValue: 1,
				min: 0
			}
		},
		title: 'Vignette',
		description: 'Vignette'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/effects/seriously.whitebalance.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*

	Math references:
	en.wikipedia.org/wiki/Color_balance
	http://scien.stanford.edu/pages/labsite/2010/psych221/projects/2010/JasonSu/adaptation.html
	https://github.com/ikaros-project/ikaros/blob/master/Source/Modules/VisionModules/WhiteBalance/WhiteBalance.cc

	*/

	var identity = new Float32Array([
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	]);

	Seriously.plugin('whitebalance', function () {
		var pyramidShader,
			pyramidBuffers = [],
			width,
			height,
			pyramidSize,
			log2 = Math.log(2),
			me = this,
			//baseShader, //todo: share one with main object
			gl,

			MAX_TEXTURE_SIZE;

		/*
		todo: handle special case where node is square and power of two. save on one pyramid iteration
		*/

		function updateSize(w, h) {
			var size, numLevels, n,
				i;

			if (width === w && height === h) {
				return;
			}

			width = w;
			height = h;

			numLevels = Math.ceil(Math.log(Math.max(h, w)) / log2);
			size = Math.pow(2, numLevels);

			if (size > MAX_TEXTURE_SIZE) {
				numLevels = Math.ceil(Math.log(MAX_TEXTURE_SIZE) / log2);
				size = MAX_TEXTURE_SIZE;
			}

			numLevels++;
			if (pyramidSize === size) {
				return;
			}

			pyramidSize = size;

			while (pyramidBuffers.length > numLevels) {
				(pyramidBuffers.pop()).fb.destroy();
			}

			while (pyramidBuffers.length < numLevels) {
				i = pyramidBuffers.length;
				n = Math.pow(2, i);
				pyramidBuffers.push({
					fb: new Seriously.util.FrameBuffer(me.gl, n, n),//, true),
					opts: {
						width: n,
						height: n
					},
					uniforms: {
						level: pyramidBuffers.length,
						offset: 0.25 / n,
						transform: identity,
						projection: identity,
						resolution: [n, n]
					}
				});

				if (i) {
					pyramidBuffers[i - 1].uniforms.source = pyramidBuffers[i].fb.texture;
				}
			}
		}


		return {
			initialize: function (initialize) {
				gl = this.gl;

				MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);

				if (this.inputs.auto) {
					updateSize(this.width, this.height);
				}

				initialize();
			},
			shader: function (inputs, shaderSource) {
				var auto = inputs.auto;
				//baseShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, shaderSource.fragment);
				//todo: gl.getExtension('OES_texture_float_linear')

				if (auto && !pyramidShader) {
					pyramidShader = new Seriously.util.ShaderProgram(this.gl, shaderSource.vertex, [
						'precision mediump float;',

						'varying vec2 vTexCoord;',
						'varying vec4 vPosition;',

						'uniform sampler2D source;',
						'uniform float offset;',
						'uniform int level;',

						'void main(void) {',
						//gl.getExtension("OES_texture_float"), gl.getExtension("OES_texture_float_linear")
						//'	vec4 pixel = texture2D(source, vTexCoord);',

						'	vec4 pixel = texture2D(source, vTexCoord - vec2(offset)) +',
						'		texture2D(source, vTexCoord + vec2(offset, -offset)) +',
						'		texture2D(source, vTexCoord + vec2(offset)) +',
						'		texture2D(source, vTexCoord + vec2(-offset, offset));',
						'	pixel /= 4.0;',
						'	gl_FragColor = pixel;',
						'}'
					].join('\n'));
				}

				shaderSource.fragment = [
					auto ? '#define AUTO' : '',
					'precision mediump float;',

					'varying vec2 vTexCoord;',
					'varying vec4 vPosition;',

					'uniform sampler2D source;',
					'#ifdef AUTO',
					'uniform sampler2D whiteSource;',
					'#else',
					'uniform vec4 white;',
					'#endif',

					// matrices from: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
					/*
					raw RGB just seems to work better so let's use that until we figure Bradford out
					'const mat3 rgbToBradford = mat3(',
					'	0.4360747, 0.2225045, 0.0139322,',
					'	0.3850649, 0.7168786, 0.0971045,',
					'	0.1430804, 0.0606169, 0.7141733',
					');',

					'const mat3 bradfordToRgb = mat3(',
					'	3.1338561, -0.9787684, 0.0719453,',
					'	-1.6168667, 1.9161415, -0.2289914,',
					'	-0.4906146, 0.033454, 1.4052427',
					');',
					*/

					'const vec3 luma = vec3(0.2125, 0.7154, 0.0721);',

					'void main(void) {',
					'	vec4 pixel = texture2D(source, vTexCoord);',
					'#ifdef AUTO',
					'	vec4 white = texture2D(whiteSource, vTexCoord);',
					'#endif',
					/*
					'	vec3 whiteBradford = rgbToBradford * white.rgb;',
					'	vec3 targetBradford = rgbToBradford * vec3(dot(white.rgb, luma));',
					'	vec3 colorBradford = rgbToBradford * pixel.rgb;',
					'	pixel.rgb = clamp(bradfordToRgb * (colorBradford * targetBradford / whiteBradford), 0.0, 1.0);',
					*/
					'	vec3 target = vec3(dot(white.rgb, luma));',
					'	pixel.rgb = pixel.rgb * target / white.rgb;',
					'	gl_FragColor = pixel;',
					'}'
				].join('\n');

				return shaderSource;
			},
			resize: function () {
				if (this.gl && this.inputs.auto) {
					updateSize(this.width, this.height);
				}
			},
			draw: function (shader, model, uniforms, frameBuffer, draw) {
				var i,
					buf;

				if (this.inputs.auto) {
					i = pyramidBuffers.length - 1;
					pyramidBuffers[i].uniforms.source = uniforms.source;
					while (i >= 0) {
						buf = pyramidBuffers[i];
						draw(pyramidShader, model, buf.uniforms, buf.fb.frameBuffer, null, buf.opts);
						i--;
					}

					uniforms.whiteSource = pyramidBuffers[0].fb.texture;
				}

				draw(shader, model, uniforms, frameBuffer);
			},
			destroy: function () {
				while (pyramidBuffers.length) {
					pyramidBuffers.pop().destroy();
				}
			},
			inPlace: false,
			inputs: {
				source: {
					type: 'image',
					uniform: 'source',
					shaderDirty: false
				},
				white: {
					type: 'color',
					uniform: 'white',
					defaultValue: [1, 1, 1]
				},
				auto: {
					type: 'boolean',
					shaderDirty: true,
					defaultValue: true
				}
			}
		};
	},
	{
		title: 'White Balance'
	});
}));

});
require.register("forresto-noflo-seriously/vendor/transforms/seriously.camerashake.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	/*
	Camera Shake
	- amplitude (x/y)
	- center (x/y)
	- rotation (degrees)
	- frequency
	- octaves
	- autoScale (true/false)
	*/


	/*
	Simplex Noise
	adapted from https://github.com/jwagner/simplex-noise.js
	*/

	var mat4 = Seriously.util.mat4,

		f2 = 0.5 * (Math.sqrt(3.0) - 1.0),
		g2 = (3.0 - Math.sqrt(3.0)) / 6.0,

		random = Math.random,
		p,
		perm,
		permMod12,
		grad3,
		initialized = false;

	function initializeSimplex() {
		//initialize simplex lookup tables
		var i;
		if (!initialized) {
			p = new Uint8Array(256);
			perm = new Uint8Array(512);
			permMod12  = new Uint8Array(512);
			grad3 = new Float32Array([
				1, 1, 0,
				- 1, 1, 0,
				1, - 1, 0,

				- 1, - 1, 0,
				1, 0, 1,
				- 1, 0, 1,

				1, 0, - 1,
				- 1, 0, - 1,
				0, 1, 1,

				0, - 1, 1,
				0, 1, - 1,
				0, - 1, - 1
			]);

			for (i = 0; i < 256; i++) {
				p[i] = random() * 256;
			}
			for (i = 0; i < 512; i++) {
				perm[i] = p[i & 255];
				permMod12[i] = perm[i] % 12;
			}
			initialized = true;
		}
	}

	function noise2D(xin, yin) {
		var n0 = 0, // Noise contributions from the three corners
			n1 = 0, // Skew the input space to determine which simplex cell we're in
			n2 = 0,

			s = (xin + yin) * f2, // Hairy factor for 2D
			i = Math.floor(xin + s),
			j = Math.floor(yin + s),
			t = (i + j) * g2,

			xx0 = i - t, // Unskew the cell origin back to (x,y) space
			yy0 = j - t,

			x0 = xin - xx0,
			y0 = yin - yy0,

			/*
			For the 2D case, the simplex shape is an equilateral triangle.
			Determine which simplex we are in.

			Offsets for second (middle) corner of simplex in (i,j) coords
			*/
			i1 = x0 > y0 ? 1 : 0,
			j1 = (i1 + 1) % 2, //opposite of i1

			x1 = x0 - i1 + g2,
			y1 = y0 - j1 + g2,
			x2 = x0 - 1 + 2 * g2,
			y2 = y0 - 1 + 2 * g2,

			ii = i & 255,
			jj = j & 255,

			t0 = 0.5 - x0 * x0 - y0 * y0,

			t1,
			t2,

			gi;

		if (t0 >= 0) {
            gi = permMod12[ii + perm[jj]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi] * x0 + grad3[gi + 1] * y0); // (x,y) of grad3 used for 2D gradient
        }

        t1 = 0.5 - x1 * x1 - y1 * y1;
		if (t1 >= 0) {
			gi = permMod12[ii + i1 + perm[jj + j1]] * 3;
			t1 *= t1;
			n1 = t1 * t1 * (grad3[gi] * x1 + grad3[gi + 1] * y1);
		}

		t2 = 0.5 - x2 * x2 - y2 * y2;
		if (t2 >= 0) {
			gi = permMod12[ii + 1 + perm[jj + 1]] * 3;
			t2 *= t2;
			n2 = t2 * t2 * (grad3[gi] * x2 + grad3[gi + 1] * y2);
		}

		return 70.0 * (n0 + n1 + n2);
	}

	Seriously.transform('camerashake', function () {
		var me = this,
			octaves = 1,
			time = 0,
			amplitudeX = 0,
			amplitudeY = 0,
			centerX = 0,
			centerY = 0,
			frequency = 1,
			rotation = 0;

		function recompute() {
			var matrix = me.matrix,
				s, c,
				t,
				freq,
				amp,
				adjust = 0,
				i,
				translateX = 0,
				translateY = 0,
				rotationZ = 0,
				m00,
				m01,
				m02,
				m03,
				m10,
				m11,
				m12,
				m13;

			function translate(x, y) {
				matrix[12] = matrix[0] * x + matrix[4] * y + matrix[12];
				matrix[13] = matrix[1] * x + matrix[5] * y + matrix[13];
				matrix[14] = matrix[2] * x + matrix[6] * y + matrix[14];
				matrix[15] = matrix[3] * x + matrix[7] * y + matrix[15];
			}

			function rotateZ() {
				var angle;

				if (!rotationZ) {
					return;
				}

				angle = rotationZ * Math.PI / 180;

				s = Math.sin(angle);
				c = Math.cos(angle);

				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];

				matrix[0] = m00 * c + m10 * s;
				matrix[1] = m01 * c + m11 * s;
				matrix[2] = m02 * c + m12 * s;
				matrix[3] = m03 * c + m13 * s;
				matrix[4] = m10 * c - m00 * s;
				matrix[5] = m11 * c - m01 * s;
				matrix[6] = m12 * c - m02 * s;
				matrix[7] = m13 * c - m03 * s;
			}

			if (!amplitudeX &&
					!amplitudeY &&
					!rotation
					) {
				me.transformed = false;
				return;
			}

			t = time * frequency;

			for (i = 0; i < octaves; i++) {
				freq = Math.pow(2, i);
				amp = Math.pow(0.5, i);
				adjust += amp;
				if (rotation) {
					rotationZ += noise2D(t * freq, 7 * freq) * amp;
				}
				if (amplitudeX) {
					translateX += noise2D(t * freq, 11 * freq) * amp;
				}
				if (amplitudeY) {
					translateY += noise2D(t * freq, 13 * freq) * amp;
				}
			}
			rotationZ *= rotation / adjust;
			translateX *= amplitudeX / adjust;
			translateY *= amplitudeY / adjust;

			//calculate transformation matrix
			mat4.identity(matrix);

			translate(translateX + centerX, translateY + centerY);

			rotateZ();

			/*
			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}
			*/

			translate(-centerX, -centerY);

			me.transformed = true;
		}

		initializeSimplex();

		return {
			inputs: {
				time: {
					get: function () {
						return time;
					},
					set: function (t) {
						if (t === time) {
							return false;
						}

						time = t;

						recompute();
						return true;
					},
					type: 'number'
				},
				frequency: {
					get: function () {
						return frequency;
					},
					set: function (f) {
						if (f === frequency) {
							return false;
						}

						frequency = f;

						recompute();
						return true;
					},
					type: 'number'
				},
				octaves: {
					get: function () {
						return octaves;
					},
					set: function (o) {
						o = Math.max(1, o);
						if (o === octaves) {
							return false;
						}

						octaves = o;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotation: {
					get: function () {
						return rotation;
					},
					set: function (r) {
						if (r === rotation) {
							return false;
						}

						rotation = r;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerX: {
					get: function () {
						return centerX;
					},
					set: function (x) {
						if (x === centerX) {
							return false;
						}

						centerX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerY: {
					get: function () {
						return centerY;
					},
					set: function (y) {
						if (y === centerY) {
							return false;
						}

						centerY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				amplitudeX: {
					get: function () {
						return amplitudeX;
					},
					set: function (x) {
						x = Math.max(0, x);
						if (x === amplitudeX) {
							return false;
						}

						amplitudeX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				amplitudeY: {
					get: function () {
						return amplitudeY;
					},
					set: function (y) {
						y = Math.max(0, y);
						if (y === amplitudeY) {
							return false;
						}

						amplitudeY = y;

						recompute();
						return true;
					},
					type: 'number'
				}
			}
		};
	}, {
		title: 'Camera Shake'
	});
}));
});
require.register("forresto-noflo-seriously/vendor/transforms/seriously.transform3d.js", function(exports, require, module){
/* global define, require */
(function (root, factory) {
	'use strict';

	if (typeof exports === 'object') {
		// Node/CommonJS
		factory(require('../seriously.js'));
	} else if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['seriously'], factory);
	} else {
		if (!root.Seriously) {
			root.Seriously = { plugin: function (name, opt) { this[name] = opt; } };
		}
		factory(root.Seriously);
	}
}(this, function (Seriously, undefined) {
	'use strict';

	var mat4 = Seriously.util.mat4;

	/*
	3D transform
	- translate
	- rotate (degrees)
	- scale
	*/
	Seriously.transform('3d', function (options) {
		var me = this,
			degrees = !(options && options.radians),
			centerX = 0,
			centerY = 0,
			centerZ = 0,
			scaleX = 1,
			scaleY = 1,
			scaleZ = 1,
			translateX = 0,
			translateY = 0,
			translateZ = 0,
			rotationX = 0,
			rotationY = 0,
			rotationZ = 0,
			rotationOrder = 'XYZ';

		function recompute() {
			var matrix = me.matrix,
				s, c,
				m00,
				m01,
				m02,
				m03,
				m10,
				m11,
				m12,
				m13,
				m20,
				m21,
				m22,
				m23;

			function translate(x, y, z) {
				matrix[12] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12];
				matrix[13] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13];
				matrix[14] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14];
				matrix[15] = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
			}

			function rotateX() {
				var angle;

				if (!rotationX) {
					return;
				}

				angle = -(degrees ? rotationX * Math.PI / 180 : rotationX);

				s = Math.sin(angle);
				c = Math.cos(angle);

				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];
				m20 = matrix[8];
				m21 = matrix[9];
				m22 = matrix[10];
				m23 = matrix[11];

				matrix[4] = m10 * c + m20 * s;
				matrix[5] = m11 * c + m21 * s;
				matrix[6] = m12 * c + m22 * s;
				matrix[7] = m13 * c + m23 * s;
				matrix[8] = m20 * c - m10 * s;
				matrix[9] = m21 * c - m11 * s;
				matrix[10] = m22 * c - m12 * s;
				matrix[11] = m23 * c - m13 * s;
			}

			function rotateY() {
				var angle;

				if (!rotationY) {
					return;
				}

				angle = -(degrees ? rotationY * Math.PI / 180 : rotationY);

				s = Math.sin(angle);
				c = Math.cos(angle);

				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m20 = matrix[8];
				m21 = matrix[9];
				m22 = matrix[10];
				m23 = matrix[11];

				matrix[0] = m00 * c - m20 * s;
				matrix[1] = m01 * c - m21 * s;
				matrix[2] = m02 * c - m22 * s;
				matrix[3] = m03 * c - m23 * s;
				matrix[8] = m00 * s + m20 * c;
				matrix[9] = m01 * s + m21 * c;
				matrix[10] = m02 * s + m22 * c;
				matrix[11] = m03 * s + m23 * c;
			}

			function rotateZ() {
				var angle;

				if (!rotationZ) {
					return;
				}

				angle = -(degrees ? rotationZ * Math.PI / 180 : rotationZ);

				s = Math.sin(angle);
				c = Math.cos(angle);

				m00 = matrix[0];
				m01 = matrix[1];
				m02 = matrix[2];
				m03 = matrix[3];
				m10 = matrix[4];
				m11 = matrix[5];
				m12 = matrix[6];
				m13 = matrix[7];

				matrix[0] = m00 * c + m10 * s;
				matrix[1] = m01 * c + m11 * s;
				matrix[2] = m02 * c + m12 * s;
				matrix[3] = m03 * c + m13 * s;
				matrix[4] = m10 * c - m00 * s;
				matrix[5] = m11 * c - m01 * s;
				matrix[6] = m12 * c - m02 * s;
				matrix[7] = m13 * c - m03 * s;
			}

			if (!translateX &&
					!translateY &&
					!translateZ &&
					!rotationX &&
					!rotationY &&
					!rotationZ &&
					scaleX === 1 &&
					scaleY === 1 &&
					scaleZ === 1
					) {
				me.transformed = false;
				return;
			}

			//calculate transformation matrix
			mat4.identity(matrix);

			translate(translateX + centerX, translateY + centerY, translateZ + centerZ);

			if (rotationOrder === 'XYZ') {
				rotateX();
				rotateY();
				rotateZ();
			} else if (rotationOrder === 'XZY') {
				rotateX();
				rotateZ();
				rotateY();
			} else if (rotationOrder === 'YXZ') {
				rotateY();
				rotateX();
				rotateZ();
			} else if (rotationOrder === 'YZX') {
				rotateY();
				rotateZ();
				rotateX();
			} else if (rotationOrder === 'ZXY') {
				rotateZ();
				rotateX();
				rotateY();
			} else { //ZYX
				rotateZ();
				rotateY();
				rotateX();
			}

			//scale
			if (scaleX !== 1) {
				matrix[0] *= scaleX;
				matrix[1] *= scaleX;
				matrix[2] *= scaleX;
				matrix[3] *= scaleX;
			}
			if (scaleY !== 1) {
				matrix[4] *= scaleY;
				matrix[5] *= scaleY;
				matrix[6] *= scaleY;
				matrix[7] *= scaleY;
			}
			if (scaleZ !== 1) {
				matrix[8] *= scaleZ;
				matrix[9] *= scaleZ;
				matrix[10] *= scaleZ;
				matrix[11] *= scaleZ;
			}

			translate(-centerX, -centerY, -centerZ);

			me.transformed = true;
		}

		return {
			inputs: {
				reset: {
					method: function () {
						centerX = 0;
						centerY = 0;
						centerZ = 0;
						scaleX = 1;
						scaleY = 1;
						scaleZ = 1;
						translateX = 0;
						translateY = 0;
						translateZ = 0;
						rotationX = 0;
						rotationY = 0;
						rotationZ = 0;

						if (me.transformed) {
							me.transformed = false;
							return true;
						}

						return false;
					}
				},
				translate: {
					method: function (x, y, z) {
						if (isNaN(x)) {
							x = translateX;
						}

						if (isNaN(y)) {
							y = translateY;
						}

						if (isNaN(z)) {
							z = translateZ;
						}

						if (x === translateX && y === translateY && z === translateZ) {
							return false;
						}

						translateX = x;
						translateY = y;
						translateZ = z;

						recompute();
						return true;
					},
					type: [
						'number',
						'number',
						'number'
					]
				},
				translateX: {
					get: function () {
						return translateX;
					},
					set: function (x) {
						if (x === translateX) {
							return false;
						}

						translateX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				translateY: {
					get: function () {
						return translateY;
					},
					set: function (y) {
						if (y === translateY) {
							return false;
						}

						translateY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				translateZ: {
					get: function () {
						return translateZ;
					},
					set: function (z) {
						if (z === translateZ) {
							return false;
						}

						translateZ = z;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationOrder: {
					get: function () {
						return rotationOrder;
					},
					set: function (order) {
						if (order === rotationOrder) {
							return false;
						}

						rotationOrder = order;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationX: {
					get: function () {
						return rotationX;
					},
					set: function (angle) {
						if (angle === rotationX) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotationX = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationY: {
					get: function () {
						return rotationY;
					},
					set: function (angle) {
						if (angle === rotationY) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotationY = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				rotationZ: {
					get: function () {
						return rotationZ;
					},
					set: function (angle) {
						if (angle === rotationZ) {
							return false;
						}

						//todo: fmod 360deg or Math.PI * 2 radians
						rotationZ = angle;

						recompute();
						return true;
					},
					type: 'number'
				},
				center: {
					method: function (x, y, z) {
						if (isNaN(x)) {
							x = centerX;
						}

						if (isNaN(y)) {
							y = centerY;
						}

						if (isNaN(z)) {
							z = centerZ;
						}

						if (x === centerX && y === centerY && z === centerZ) {
							return false;
						}

						centerX = x;
						centerY = y;
						centerZ = z;

						recompute();
						return true;
					},
					type: [
						'number',
						'number',
						'number'
					]
				},
				centerX: {
					get: function () {
						return centerX;
					},
					set: function (x) {
						if (x === centerX) {
							return false;
						}

						centerX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerY: {
					get: function () {
						return centerY;
					},
					set: function (y) {
						if (y === centerY) {
							return false;
						}

						centerY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				centerZ: {
					get: function () {
						return centerZ;
					},
					set: function (z) {
						if (z === centerZ) {
							return false;
						}

						centerZ = z;

						recompute();
						return true;
					},
					type: 'number'
				},
				scale: {
					method: function (x, y, z) {
						var newX, newY, newZ;

						if (isNaN(x)) {
							newX = scaleX;
						} else {
							newX = x;
						}

						/*
						if only one value is specified, set all to the same scale
						*/
						if (isNaN(y)) {
							if (!isNaN(x) && isNaN(z)) {
								newY = newX;
								newZ = newX;
							} else {
								newY = scaleY;
							}
						} else {
							newY = y;
						}

						if (isNaN(z)) {
							if (newZ === undefined) {
								newZ = scaleZ;
							}
						} else {
							newZ = z;
						}

						if (newX === scaleX && newY === scaleY && newZ === scaleZ) {
							return false;
						}

						scaleX = newX;
						scaleY = newY;
						scaleZ = newZ;

						recompute();
						return true;
					},
					type: [
						'number',
						'number',
						'number'
					]
				},
				scaleX: {
					get: function () {
						return scaleX;
					},
					set: function (x) {
						if (x === scaleX) {
							return false;
						}

						scaleX = x;

						recompute();
						return true;
					},
					type: 'number'
				},
				scaleY: {
					get: function () {
						return scaleY;
					},
					set: function (y) {
						if (y === scaleY) {
							return false;
						}

						scaleY = y;

						recompute();
						return true;
					},
					type: 'number'
				},
				scaleZ: {
					get: function () {
						return scaleZ;
					},
					set: function (z) {
						if (z === scaleZ) {
							return false;
						}

						scaleZ = z;

						recompute();
						return true;
					},
					type: 'number'
				}
			}
		};
	}, {
		title: '3D Transform',
		description: 'Translate, Rotate, Scale'
	});
}));
});
require.register("forresto-noflo-seriously/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-seriously","description":"Seriously.js WebGL shader image effects for NoFlo.","author":"Forrest Oliphant and Brian Chirls <forrest@sembiki.com>","repo":"forresto/noflo-seriously","version":"0.1.0","keywords":[],"dependencies":{"noflo/noflo":"*"},"scripts":["index.js","vendor/seriously.js","vendor/effects/seriously.ascii.js","vendor/effects/seriously.bleach-bypass.js","vendor/effects/seriously.blend.js","vendor/effects/seriously.blur.js","vendor/effects/seriously.brightness-contrast.js","vendor/effects/seriously.channels.js","vendor/effects/seriously.chroma.js","vendor/effects/seriously.color.js","vendor/effects/seriously.colorcomplements.js","vendor/effects/seriously.colorcube.js","vendor/effects/seriously.daltonize.js","vendor/effects/seriously.directionblur.js","vendor/effects/seriously.dither.js","vendor/effects/seriously.edge.js","vendor/effects/seriously.emboss.js","vendor/effects/seriously.exposure.js","vendor/effects/seriously.fader.js","vendor/effects/seriously.falsecolor.js","vendor/effects/seriously.filmgrain.js","vendor/effects/seriously.hex.js","vendor/effects/seriously.highlights-shadows.js","vendor/effects/seriously.hue-saturation.js","vendor/effects/seriously.invert.js","vendor/effects/seriously.kaleidoscope.js","vendor/effects/seriously.layers.js","vendor/effects/seriously.linear-transfer.js","vendor/effects/seriously.lumakey.js","vendor/effects/seriously.nightvision.js","vendor/effects/seriously.noise.js","vendor/effects/seriously.repeat.js","vendor/effects/seriously.ripple.js","vendor/effects/seriously.scanlines.js","vendor/effects/seriously.sepia.js","vendor/effects/seriously.simplex.js","vendor/effects/seriously.sketch.js","vendor/effects/seriously.split.js","vendor/effects/seriously.tone.js","vendor/effects/seriously.tvglitch.js","vendor/effects/seriously.vignette.js","vendor/effects/seriously.whitebalance.js","vendor/transforms/seriously.camerashake.js","vendor/transforms/seriously.transform3d.js","components/SetFilterSource.coffee","components/SetFilterTarget.coffee","lib/SeriouslyEffect.coffee","components/FilterAscii.coffee","components/FilterBleachBypass.coffee","components/FilterBlend.coffee","components/FilterChannels.coffee","components/FilterChroma.coffee","components/FilterColor.coffee","components/FilterColorCube.coffee","components/FilterDaltonize.coffee","components/FilterEdge.coffee","components/FilterEmboss.coffee","components/FilterExposure.coffee","components/FilterFader.coffee","components/FilterHex.coffee","components/FilterHueSaturation.coffee","components/FilterInvert.coffee","components/FilterLumakey.coffee","components/FilterNightVision.coffee","components/FilterNoise.coffee","components/FilterRipple.coffee","components/FilterScanLines.coffee","components/FilterSepia.coffee","components/FilterSketch.coffee","components/FilterSplit.coffee","components/FilterTone.coffee","components/FilterTVGlitch.coffee","components/FilterVignette.coffee"],"json":["component.json"],"noflo":{"icon":"film","components":{"SetSource":"components/SetFilterSource.coffee","SetTarget":"components/SetFilterTarget.coffee","Ascii":"components/FilterAscii.coffee","BleachBypass":"components/FilterBleachBypass.coffee","Blend":"components/FilterBlend.coffee","Channels":"components/FilterChannels.coffee","Chroma":"components/FilterChroma.coffee","Color":"components/FilterColor.coffee","ColorCube":"components/FilterColorCube.coffee","Daltonize":"components/FilterDaltonize.coffee","Edge":"components/FilterEdge.coffee","Emboss":"components/FilterEmboss.coffee","Exposure":"components/FilterExposure.coffee","Fader":"components/FilterFader.coffee","Hex":"components/FilterHex.coffee","HueSaturation":"components/FilterHueSaturation.coffee","Invert":"components/FilterInvert.coffee","Lumakey":"components/FilterLumakey.coffee","NightVision":"components/FilterNightVision.coffee","Noise":"components/FilterNoise.coffee","Ripple":"components/FilterRipple.coffee","ScanLines":"components/FilterScanLines.coffee","Sepia":"components/FilterSepia.coffee","Sketch":"components/FilterSketch.coffee","Split":"components/FilterSplit.coffee","Tone":"components/FilterTone.coffee","TVGlitch":"components/FilterTVGlitch.coffee","Vignette":"components/FilterVignette.coffee"}}}');
});
require.register("forresto-noflo-seriously/components/SetFilterSource.js", function(exports, require, module){
var Seriously, SetFilterSource, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

SetFilterSource = (function(_super) {
  __extends(SetFilterSource, _super);

  function SetFilterSource() {
    this.setSource = __bind(this.setSource, this);
    if (!window.nofloSeriously) {
      window.nofloSeriously = new Seriously();
    }
    this.seriously = window.nofloSeriously;
    this.inPorts = {
      source: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.ArrayPort('object')
    };
    this.inPorts.source.on('data', this.setSource);
  }

  SetFilterSource.prototype.setSource = function(data) {
    if (this.outPorts.out.isAttached()) {
      return this.outPorts.out.send(this.seriously.source(data));
    }
  };

  return SetFilterSource;

})(noflo.Component);

exports.getComponent = function() {
  return new SetFilterSource;
};

});
require.register("forresto-noflo-seriously/components/SetFilterTarget.js", function(exports, require, module){
var Seriously, SetFilterTarget, noflo,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

SetFilterTarget = (function(_super) {
  __extends(SetFilterTarget, _super);

  function SetFilterTarget() {
    this.seriouslyGo = __bind(this.seriouslyGo, this);
    this.setTarget = __bind(this.setTarget, this);
    this.unsyncSource = __bind(this.unsyncSource, this);
    this.syncSource = __bind(this.syncSource, this);
    if (!window.nofloSeriously) {
      window.nofloSeriously = new Seriously();
    }
    this.seriously = window.nofloSeriously;
    this.inPorts = {
      source: new noflo.ArrayPort('object'),
      target: new noflo.Port('object')
    };
    this.inPorts.source.on('data', this.syncSource);
    this.inPorts.source.on('disconnect', this.unsyncSource);
    this.inPorts.target.on('data', this.setTarget);
  }

  SetFilterTarget.prototype.syncSource = function(upstream) {
    if (!upstream) {
      return;
    }
    if (this.seriouslyNode) {
      this.seriouslyNode.source = upstream;
      return this.seriouslyGo();
    } else {
      return this.upstream = upstream;
    }
  };

  SetFilterTarget.prototype.unsyncSource = function(event) {
    if (this.seriouslyStarted) {
      this.seriously.stop();
      return this.seriouslyStarted = false;
    }
  };

  SetFilterTarget.prototype.setTarget = function(data) {
    this.seriouslyNode = this.seriously.target(data);
    if (this.upstream) {
      this.seriouslyNode.source = this.upstream;
      this.seriouslyGo();
      return this.upstream = null;
    }
  };

  SetFilterTarget.prototype.seriouslyGo = function() {
    if (!this.seriouslyStarted) {
      this.seriously.go();
      return this.seriouslyStarted = true;
    }
  };

  return SetFilterTarget;

})(noflo.Component);

exports.getComponent = function() {
  return new SetFilterTarget;
};

});
require.register("forresto-noflo-seriously/lib/SeriouslyEffect.js", function(exports, require, module){
var Seriously, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

exports.SeriouslyEffect = (function(_super) {
  __extends(SeriouslyEffect, _super);

  function SeriouslyEffect(filterName, imageInCount) {
    var effectInfo, input, key, nofloPort, seriouslyPort, type, _ref, _ref1;
    if (!window.nofloSeriously) {
      window.nofloSeriously = new Seriously();
    }
    this.seriously = window.nofloSeriously;
    this.sources = {};
    this.seriouslyNode = this.seriously.effect(filterName);
    effectInfo = this.seriously.effects()[filterName];
    if ((_ref = effectInfo.description) != null ? _ref.length : void 0) {
      this.description = effectInfo.description;
    }
    this.inPorts = {};
    this.outPorts = {
      out: new noflo.ArrayPort('object')
    };
    _ref1 = effectInfo.inputs;
    for (key in _ref1) {
      if (!__hasProp.call(_ref1, key)) continue;
      input = _ref1[key];
      seriouslyPort = key;
      nofloPort = seriouslyPort.toLowerCase();
      type = input.type;
      if (type === 'image') {
        this.inPorts[nofloPort] = new noflo.Port('object');
        this.inPorts[nofloPort].on('data', this.syncGraph.bind(this, nofloPort, seriouslyPort));
        this.inPorts[nofloPort].on('disconnect', this.unsyncGraph.bind(this, nofloPort, seriouslyPort));
      } else {
        this.inPorts[nofloPort] = new noflo.Port(type);
        this.inPorts[nofloPort].on('data', this.setParam.bind(this, nofloPort, seriouslyPort));
      }
    }
  }

  SeriouslyEffect.prototype.syncGraph = function(nofloPort, seriouslyPort, upstream) {
    if (!upstream) {
      return;
    }
    this.sources[nofloPort] = upstream;
    this.seriouslyNode[seriouslyPort] = upstream;
    if (this.outPorts.out.isAttached()) {
      return this.outPorts.out.send(this.seriouslyNode);
    }
  };

  SeriouslyEffect.prototype.unsyncGraph = function(nofloPort, seriouslyPort) {
    this.seriouslyNode[seriouslyPort] = null;
    delete this.sources[nofloPort];
    if (this.outPorts.out.isAttached()) {
      return this.outPorts.out.disconnect();
    }
  };

  SeriouslyEffect.prototype.setParam = function(nofloPort, seriouslyPort, data) {
    return this.seriouslyNode[seriouslyPort] = data;
  };

  SeriouslyEffect.prototype.shutdown = function() {
    var key, val, _ref, _results;
    _ref = this.sources;
    _results = [];
    for (key in _ref) {
      val = _ref[key];
      _results.push(this.unsyncGraph(key));
    }
    return _results;
  };

  return SeriouslyEffect;

})(noflo.Component);

});
require.register("forresto-noflo-seriously/components/FilterAscii.js", function(exports, require, module){
var Effect, FilterAscii, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.ascii.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterAscii = (function(_super) {
  __extends(FilterAscii, _super);

  function FilterAscii() {
    FilterAscii.__super__.constructor.call(this, "ascii", 1);
  }

  return FilterAscii;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterAscii;
};

});
require.register("forresto-noflo-seriously/components/FilterBleachBypass.js", function(exports, require, module){
var Effect, FilterBleachBypass, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.bleach-bypass.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterBleachBypass = (function(_super) {
  __extends(FilterBleachBypass, _super);

  function FilterBleachBypass() {
    FilterBleachBypass.__super__.constructor.call(this, "bleach-bypass", 1);
  }

  return FilterBleachBypass;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterBleachBypass;
};

});
require.register("forresto-noflo-seriously/components/FilterBlend.js", function(exports, require, module){
var Effect, FilterBlend, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.blend.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterBlend = (function(_super) {
  __extends(FilterBlend, _super);

  function FilterBlend() {
    FilterBlend.__super__.constructor.call(this, "blend", 2);
  }

  return FilterBlend;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterBlend;
};

});
require.register("forresto-noflo-seriously/components/FilterChannels.js", function(exports, require, module){
var Effect, FilterChannels, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.channels.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterChannels = (function(_super) {
  __extends(FilterChannels, _super);

  function FilterChannels() {
    FilterChannels.__super__.constructor.call(this, "channels", 1);
  }

  return FilterChannels;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterChannels;
};

});
require.register("forresto-noflo-seriously/components/FilterChroma.js", function(exports, require, module){
var Effect, FilterChroma, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.chroma.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterChroma = (function(_super) {
  __extends(FilterChroma, _super);

  function FilterChroma() {
    FilterChroma.__super__.constructor.call(this, "chroma", 1);
  }

  return FilterChroma;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterChroma;
};

});
require.register("forresto-noflo-seriously/components/FilterColor.js", function(exports, require, module){
var Effect, FilterColor, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.color.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterColor = (function(_super) {
  __extends(FilterColor, _super);

  function FilterColor() {
    FilterColor.__super__.constructor.call(this, "color", 1);
  }

  return FilterColor;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterColor;
};

});
require.register("forresto-noflo-seriously/components/FilterColorCube.js", function(exports, require, module){
var Effect, FilterColorCube, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.colorcube.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterColorCube = (function(_super) {
  __extends(FilterColorCube, _super);

  function FilterColorCube() {
    FilterColorCube.__super__.constructor.call(this, "colorcube", 1);
  }

  return FilterColorCube;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterColorCube;
};

});
require.register("forresto-noflo-seriously/components/FilterDaltonize.js", function(exports, require, module){
var Effect, FilterDaltonize, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.daltonize.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterDaltonize = (function(_super) {
  __extends(FilterDaltonize, _super);

  function FilterDaltonize() {
    FilterDaltonize.__super__.constructor.call(this, "daltonize", 1);
  }

  return FilterDaltonize;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterDaltonize;
};

});
require.register("forresto-noflo-seriously/components/FilterEdge.js", function(exports, require, module){
var Effect, FilterEdge, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.edge.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterEdge = (function(_super) {
  __extends(FilterEdge, _super);

  function FilterEdge() {
    FilterEdge.__super__.constructor.call(this, "edge", 1);
  }

  return FilterEdge;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterEdge;
};

});
require.register("forresto-noflo-seriously/components/FilterEmboss.js", function(exports, require, module){
var Effect, FilterEmboss, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.emboss.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterEmboss = (function(_super) {
  __extends(FilterEmboss, _super);

  function FilterEmboss() {
    FilterEmboss.__super__.constructor.call(this, "emboss", 1);
  }

  return FilterEmboss;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterEmboss;
};

});
require.register("forresto-noflo-seriously/components/FilterExposure.js", function(exports, require, module){
var Effect, FilterExposure, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.exposure.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterExposure = (function(_super) {
  __extends(FilterExposure, _super);

  function FilterExposure() {
    FilterExposure.__super__.constructor.call(this, "exposure", 1);
  }

  return FilterExposure;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterExposure;
};

});
require.register("forresto-noflo-seriously/components/FilterFader.js", function(exports, require, module){
var Effect, FilterFader, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.fader.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterFader = (function(_super) {
  __extends(FilterFader, _super);

  function FilterFader() {
    FilterFader.__super__.constructor.call(this, "fader", 1);
  }

  return FilterFader;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterFader;
};

});
require.register("forresto-noflo-seriously/components/FilterHex.js", function(exports, require, module){
var Effect, FilterHex, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.hex.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterHex = (function(_super) {
  __extends(FilterHex, _super);

  function FilterHex() {
    FilterHex.__super__.constructor.call(this, "hex", 1);
  }

  return FilterHex;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterHex;
};

});
require.register("forresto-noflo-seriously/components/FilterHueSaturation.js", function(exports, require, module){
var Effect, FilterHueSaturation, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.hue-saturation.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterHueSaturation = (function(_super) {
  __extends(FilterHueSaturation, _super);

  function FilterHueSaturation() {
    FilterHueSaturation.__super__.constructor.call(this, "hue-saturation", 1);
  }

  return FilterHueSaturation;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterHueSaturation;
};

});
require.register("forresto-noflo-seriously/components/FilterInvert.js", function(exports, require, module){
var Effect, FilterInvert, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.invert.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterInvert = (function(_super) {
  __extends(FilterInvert, _super);

  function FilterInvert() {
    FilterInvert.__super__.constructor.call(this, "invert", 1);
  }

  return FilterInvert;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterInvert;
};

});
require.register("forresto-noflo-seriously/components/FilterLumakey.js", function(exports, require, module){
var Effect, FilterLumakey, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.lumakey.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterLumakey = (function(_super) {
  __extends(FilterLumakey, _super);

  function FilterLumakey() {
    FilterLumakey.__super__.constructor.call(this, "lumakey", 1);
  }

  return FilterLumakey;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterLumakey;
};

});
require.register("forresto-noflo-seriously/components/FilterNightVision.js", function(exports, require, module){
var Effect, FilterNightVision, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.nightvision.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterNightVision = (function(_super) {
  __extends(FilterNightVision, _super);

  function FilterNightVision() {
    FilterNightVision.__super__.constructor.call(this, "nightvision", 1);
  }

  return FilterNightVision;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterNightVision;
};

});
require.register("forresto-noflo-seriously/components/FilterNoise.js", function(exports, require, module){
var Effect, FilterNoise, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.noise.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterNoise = (function(_super) {
  __extends(FilterNoise, _super);

  function FilterNoise() {
    FilterNoise.__super__.constructor.call(this, "noise", 1);
  }

  return FilterNoise;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterNoise;
};

});
require.register("forresto-noflo-seriously/components/FilterRipple.js", function(exports, require, module){
var Effect, FilterScanlines, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.scanlines.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterScanlines = (function(_super) {
  __extends(FilterScanlines, _super);

  function FilterScanlines() {
    FilterScanlines.__super__.constructor.call(this, "scanlines", 1);
  }

  return FilterScanlines;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterScanlines;
};

});
require.register("forresto-noflo-seriously/components/FilterScanLines.js", function(exports, require, module){
var Effect, FilterScanLines, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.scanlines.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterScanLines = (function(_super) {
  __extends(FilterScanLines, _super);

  function FilterScanLines() {
    FilterScanLines.__super__.constructor.call(this, "scanlines", 1);
  }

  return FilterScanLines;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterScanLines;
};

});
require.register("forresto-noflo-seriously/components/FilterSepia.js", function(exports, require, module){
var Effect, FilterSepia, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.sepia.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterSepia = (function(_super) {
  __extends(FilterSepia, _super);

  function FilterSepia() {
    FilterSepia.__super__.constructor.call(this, "sepia", 1);
  }

  return FilterSepia;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterSepia;
};

});
require.register("forresto-noflo-seriously/components/FilterSketch.js", function(exports, require, module){
var Effect, FilterSketch, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.sketch.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterSketch = (function(_super) {
  __extends(FilterSketch, _super);

  function FilterSketch() {
    FilterSketch.__super__.constructor.call(this, "sketch", 1);
  }

  return FilterSketch;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterSketch;
};

});
require.register("forresto-noflo-seriously/components/FilterSplit.js", function(exports, require, module){
var Effect, FilterSplit, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.split.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterSplit = (function(_super) {
  __extends(FilterSplit, _super);

  function FilterSplit() {
    FilterSplit.__super__.constructor.call(this, "split", 1);
  }

  return FilterSplit;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterSplit;
};

});
require.register("forresto-noflo-seriously/components/FilterTone.js", function(exports, require, module){
var Effect, FilterTone, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.tone.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterTone = (function(_super) {
  __extends(FilterTone, _super);

  function FilterTone() {
    FilterTone.__super__.constructor.call(this, "tone", 1);
  }

  return FilterTone;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterTone;
};

});
require.register("forresto-noflo-seriously/components/FilterTVGlitch.js", function(exports, require, module){
var Effect, FilterTVGlitch, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.tvglitch.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterTVGlitch = (function(_super) {
  __extends(FilterTVGlitch, _super);

  function FilterTVGlitch() {
    FilterTVGlitch.__super__.constructor.call(this, "tvglitch", 1);
  }

  return FilterTVGlitch;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterTVGlitch;
};

});
require.register("forresto-noflo-seriously/components/FilterVignette.js", function(exports, require, module){
var Effect, FilterVignette, Seriously, SeriouslyEffect, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

Seriously = require('../vendor/seriously.js');

Effect = require('../vendor/effects/seriously.vignette.js');

SeriouslyEffect = require('../lib/SeriouslyEffect').SeriouslyEffect;

FilterVignette = (function(_super) {
  __extends(FilterVignette, _super);

  function FilterVignette() {
    FilterVignette.__super__.constructor.call(this, "vignette", 1);
  }

  return FilterVignette;

})(SeriouslyEffect);

exports.getComponent = function() {
  return new FilterVignette;
};

});
require.register("components-underscore/underscore.js", function(exports, require, module){
//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from an array.
  // If **n** is not specified, returns a single random element from the array.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (arguments.length < 2 || guard) {
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = new Date();
      var later = function() {
        var last = (new Date()) - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

});
require.register("jonnor-OpenJSCADorg/openjscad.js", function(exports, require, module){
// == openjscad.js, originally written by Joost Nieuwenhuijse (MIT License)
//   few adjustments by Rene K. Mueller <spiritdude@gmail.com> for OpenJSCAD.org
//
// History:
// 2013/03/12: reenable webgui parameters to fit in current design
// 2013/03/11: few changes to fit design of http://openjscad.org

if (typeof require !== 'undefined') {
    // Running inside common.js environment
    GL = require("./lightgl");
    CAG = require("./csg").CAG;
    CSG = require("./csg").CSG;
}

OpenJsCad = function() { };

OpenJsCad.log = function(txt) {
  var timeInMs = Date.now();
  var prevtime = OpenJsCad.log.prevLogTime;
  if(!prevtime) prevtime = timeInMs;
  var deltatime = timeInMs - prevtime;
  OpenJsCad.log.prevLogTime = timeInMs;
  var timefmt = (deltatime*0.001).toFixed(3);
  txt = "["+timefmt+"] "+txt;
  if( (typeof(console) == "object") && (typeof(console.log) == "function") ) {
    console.log(txt);
  } else if( (typeof(self) == "object") && (typeof(self.postMessage) == "function") ) {
    self.postMessage({cmd: 'log', txt: txt});
  }
  else throw new Error("Cannot log");
};

// A viewer is a WebGL canvas that lets the user view a mesh. The user can
// tumble it around by dragging the mouse.
OpenJsCad.Viewer = function(containerelement, width, height, initialdepth) {
  var gl = GL.create();
  this.gl = gl;
  this.angleX = -60;
  this.angleY = 0;
  this.angleZ = -45;
  this.viewpointX = 0;
  this.viewpointY = -5;
  this.viewpointZ = initialdepth;

  this.touch = {
    lastX: 0,
    lastY: 0,
    scale: 0,
    ctrl: 0,
    shiftTimer: null,
    shiftControl: null,
    cur: null //current state
  };


  // Draw axes flag:
  this.drawAxes = true;
  // Draw triangle lines:
  this.drawLines = false;
  // Set to true so lines don't use the depth buffer
  this.lineOverlay = false;

  // Set up the viewport
  gl.canvas.width = width;
  gl.canvas.height = height;
  gl.viewport(0, 0, width, height);
  gl.matrixMode(gl.PROJECTION);
  gl.loadIdentity();
  gl.perspective(45, width / height, 0.5, 1000);
  gl.matrixMode(gl.MODELVIEW);

  // Set up WebGL state
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.clearColor(0.93, 0.93, 0.93, 1);
  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.CULL_FACE);
  gl.polygonOffset(1, 1);

  // Black shader for wireframe
  this.blackShader = new GL.Shader('\
    void main() {\
      gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
    }', '\
    void main() {\
      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);\
    }'
  );

  // Shader with diffuse and specular lighting
  this.lightingShader = new GL.Shader('\
      varying vec3 color;\
      varying float alpha;\
      varying vec3 normal;\
      varying vec3 light;\
      void main() {\
        const vec3 lightDir = vec3(1.0, 2.0, 3.0) / 3.741657386773941;\
        light = lightDir;\
        color = gl_Color.rgb;\
        alpha = gl_Color.a;\
        normal = gl_NormalMatrix * gl_Normal;\
        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
      }',
     '\
      varying vec3 color;\
      varying float alpha;\
      varying vec3 normal;\
      varying vec3 light;\
      void main() {\
        vec3 n = normalize(normal);\
        float diffuse = max(0.0, dot(light, n));\
        float specular = pow(max(0.0, -reflect(light, n).z), 10.0) * sqrt(diffuse);\
        gl_FragColor = vec4(mix(color * (0.3 + 0.7 * diffuse), vec3(1.0), specular), alpha);\
      }'
  );

  var _this=this;
  var shiftControl = document.createElement('div');
  shiftControl.className = 'shift-scene'
  shiftControl.innerHTML = '<div class="arrow arrow-left" />\
                              <div class="arrow arrow-right" />\
                              <div class="arrow arrow-top" />\
                              <div class="arrow arrow-bottom" />';
  this.touch.shiftControl = shiftControl;

  containerelement.appendChild(gl.canvas);
  containerelement.appendChild(shiftControl);

 if (typeof $ !== 'undefined') {
  $(containerelement).hammer({//touch screen control
      drag_lock_to_axis: true
    }).on("transform", function(e){
      if (e.gesture.touches.length >= 2) {
          _this.clearShift();
          _this.onTransform(e);
          e.preventDefault();
      }
    }).on("touch", function(e) {
      if (e.gesture.pointerType != 'touch'){
        e.preventDefault();
        return;
      }

      if (e.gesture.touches.length == 1) {
          var point = e.gesture.center;
          _this.touch.shiftTimer = setTimeout(function(){
              shiftControl.addClass('active').css({
                  left: point.pageX + 'px',
                  top: point.pageY + 'px'
              });
              _this.touch.shiftTimer = null;
              _this.touch.cur = 'shifting';
        }, 500);
      } else {
        _this.clearShift();
      }
    }).on("drag", function(e) {
      if (e.gesture.pointerType != 'touch') {
        e.preventDefault();
        return;
      }

      if (!_this.touch.cur || _this.touch.cur == 'dragging') {
          _this.clearShift();
          _this.onPanTilt(e);
      } else if (_this.touch.cur == 'shifting') {
          _this.onShift(e);
      }
    }).on("touchend", function(e) {
        _this.clearShift();
        if (_this.touch.cur) {
            shiftControl.removeClass('active shift-horizontal shift-vertical');
        }
    }).on("transformend dragstart dragend", function(e) {
      if ((e.type == 'transformend' && _this.touch.cur == 'transforming') || 
          (e.type == 'dragend' && _this.touch.cur == 'shifting') ||
          (e.type == 'dragend' && _this.touch.cur == 'dragging'))
        _this.touch.cur = null;
      _this.touch.lastX = 0;
      _this.touch.lastY = 0;
      _this.touch.scale = 0;
    });
  }

  gl.onmousemove = function(e) {
    _this.onMouseMove(e);
  };
  gl.ondraw = function() {
    _this.onDraw();
  };
  containerelement.onresize = function(e) {    // is not called
     // var viewer = document.getElementById('viewer');
     // fix distortion after resize of canvas
     //gl.perspective(45, viewer.offsetWidth / viewer.offsetHeight, 0.5, 1000);
     //_this.gl.perspective(45, containerelement.offsetWidth / containerelement.offsetHeight, 0.5, 1000);
     alert("canvas has been resized");
  };
  gl.onmousewheel = function(e) {
    var wheelDelta = 0;    
    if (e.wheelDelta) {
      wheelDelta = e.wheelDelta;
    } else if (e.detail) {
      // for firefox, see http://stackoverflow.com/questions/8886281/event-wheeldelta-returns-undefined
      wheelDelta = e.detail * -40;     
    }
    if(wheelDelta) {
      var factor = Math.pow(1.003, -wheelDelta);
      var coeff = _this.getZoom();
      coeff *= factor;
      _this.setZoom(coeff);
    }
  };
  this.clear();
};

OpenJsCad.Viewer.prototype = {
  setCsg: function(csg) {
    if(0&&csg.length) {                            // preparing multiple CSG's (not union-ed), not yet working
       for(var i=0; i<csg.length; i++)
          this.meshes.concat(OpenJsCad.Viewer.csgToMeshes(csg[i]));
    } else {
       this.meshes = OpenJsCad.Viewer.csgToMeshes(csg);
    }
    this.onDraw();    
  },

  clear: function() {
    // empty mesh list:
    this.meshes = []; 
    this.onDraw();    
  },

  supported: function() {
    return !!this.gl;
  },

  ZOOM_MAX: 1000,
  ZOOM_MIN: 10,
  onZoomChanged: null,
  plate: true,                   // render plate

  setZoom: function(coeff) { //0...1
    coeff=Math.max(coeff, 0);
    coeff=Math.min(coeff, 1);
    this.viewpointZ = this.ZOOM_MIN + coeff * (this.ZOOM_MAX - this.ZOOM_MIN);
    if(this.onZoomChanged) {
      this.onZoomChanged();
    }
    this.onDraw();
  },

  getZoom: function() {
    var coeff = (this.viewpointZ-this.ZOOM_MIN) / (this.ZOOM_MAX - this.ZOOM_MIN);
    return coeff;
  },
  
  onMouseMove: function(e) {
    if (e.dragging) {
      //console.log(e.which,e.button);
      var b = e.button;
      if(e.which) {                            // RANT: not even the mouse buttons are coherent among the brand (chrome,firefox,etc)
         b = e.which;
      }
      e.preventDefault();
      if(e.altKey||b==3) {                     // ROTATE X,Y (ALT or right mouse button)
        this.angleY += e.deltaX;
        this.angleX += e.deltaY;
        //this.angleX = Math.max(-180, Math.min(180, this.angleX));
      } else if(e.shiftKey||b==2) {            // PAN  (SHIFT or middle mouse button)
        var factor = 5e-3;
        this.viewpointX += factor * e.deltaX * this.viewpointZ;
        this.viewpointY -= factor * e.deltaY * this.viewpointZ;
      } else if(e.ctrlKey) {                   // ZOOM IN/OU
         var factor = Math.pow(1.006, e.deltaX+e.deltaY);
         var coeff = this.getZoom();
         coeff *= factor;
         this.setZoom(coeff);
      } else {                                 // ROTATE X,Z  left mouse button
        this.angleZ += e.deltaX;
        this.angleX += e.deltaY;
      }
      this.onDraw();
    }
  },
  clearShift: function() {
      if(this.touch.shiftTimer) {
          clearTimeout(this.touch.shiftTimer);
          this.touch.shiftTimer = null;
      }
      return this;
  },
  //pan & tilt with one finger
  onPanTilt: function(e) {
    this.touch.cur = 'dragging';
    var delta = 0;
    if (this.touch.lastY && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {
        //tilt
        delta = e.gesture.deltaY - this.touch.lastY;
        this.angleX += delta;
    } else if (this.touch.lastX && (e.gesture.direction == 'left' || e.gesture.direction == 'right')) {
        //pan
        delta = e.gesture.deltaX - this.touch.lastX;
        this.angleZ += delta;
    }
    if (delta)
      this.onDraw();
    this.touch.lastX = e.gesture.deltaX;
    this.touch.lastY = e.gesture.deltaY;
  },
  //shift after 0.5s touch&hold
  onShift: function(e) {
    this.touch.cur = 'shifting';
    var factor = 5e-3;
    var delta = 0;

    if (this.touch.lastY && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {
        this.touch.shiftControl
          .removeClass('shift-horizontal')
          .addClass('shift-vertical')
          .css('top', e.gesture.center.pageY + 'px');
        delta = e.gesture.deltaY - this.touch.lastY;
        this.viewpointY -= factor * delta * this.viewpointZ;
        this.angleX += delta;
    } 
    if (this.touch.lastX && (e.gesture.direction == 'left' || e.gesture.direction == 'right')) {
        this.touch.shiftControl
          .removeClass('shift-vertical')
          .addClass('shift-horizontal')
          .css('left', e.gesture.center.pageX + 'px');
        delta = e.gesture.deltaX - this.touch.lastX;
        this.viewpointX += factor * delta * this.viewpointZ;
        this.angleZ += delta;
    }
    if (delta)
      this.onDraw();
    this.touch.lastX = e.gesture.deltaX;
    this.touch.lastY = e.gesture.deltaY;
  },
  //zooming
  onTransform: function(e) {
      this.touch.cur = 'transforming';
      if (this.touch.scale) {
        var factor = 1 / (1 + e.gesture.scale - this.touch.scale);
        var coeff = this.getZoom();
        coeff *= factor;
        this.setZoom( coeff);
      }
      this.touch.scale = e.gesture.scale;
      return this;
  },
  onDraw: function(e) {
    var gl = this.gl;
    gl.makeCurrent();

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.loadIdentity();
    gl.translate(this.viewpointX, this.viewpointY, -this.viewpointZ);
    gl.rotate(this.angleX, 1, 0, 0);
    gl.rotate(this.angleY, 0, 1, 0);
    gl.rotate(this.angleZ, 0, 0, 1);

    gl.enable(gl.BLEND);
    //gl.disable(gl.DEPTH_TEST);
    if (!this.lineOverlay) gl.enable(gl.POLYGON_OFFSET_FILL);
    for (var i = 0; i < this.meshes.length; i++) {
      var mesh = this.meshes[i];
      this.lightingShader.draw(mesh, gl.TRIANGLES);
    }
    if (!this.lineOverlay) gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.BLEND);
    //gl.enable(gl.DEPTH_TEST);

    if(this.drawLines) {
      if (this.lineOverlay) gl.disable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);
      for (var i = 0; i < this.meshes.length; i++) {
        var mesh = this.meshes[i];
        this.blackShader.draw(mesh, gl.LINES);
      }
      gl.disable(gl.BLEND);
      if (this.lineOverlay) gl.enable(gl.DEPTH_TEST);
    }
    //EDW: axes
    if (this.drawAxes) {
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.begin(gl.LINES);
      var plate = 200;
      if(this.plate) {
         gl.color(.8,.8,.8,.5); // -- minor grid
         for(var x=-plate/2; x<=plate/2; x++) {
            if(x%10) {
               gl.vertex(-plate/2, x, 0);
               gl.vertex(plate/2, x, 0);
               gl.vertex(x, -plate/2, 0);
               gl.vertex(x, plate/2, 0);
            }
         }
         gl.color(.5,.5,.5,.5); // -- major grid
         for(var x=-plate/2; x<=plate/2; x+=10) {
            gl.vertex(-plate/2, x, 0);
            gl.vertex(plate/2, x, 0);
            gl.vertex(x, -plate/2, 0);
            gl.vertex(x, plate/2, 0);
         }
      }
      if(0) {
         //X - red
         gl.color(1, 0.5, 0.5, 0.2); //negative direction is lighter
         gl.vertex(-100, 0, 0);
         gl.vertex(0, 0, 0);
   
         gl.color(1, 0, 0, 0.8); //positive direction
         gl.vertex(0, 0, 0);
         gl.vertex(100, 0, 0);
         //Y - green
         gl.color(0.5, 1, 0.5, 0.2); //negative direction is lighter
         gl.vertex(0, -100, 0);
         gl.vertex(0, 0, 0);
   
         gl.color(0, 1, 0, 0.8); //positive direction
         gl.vertex(0, 0, 0);
         gl.vertex(0, 100, 0);
         //Z - black
         gl.color(0.5, 0.5, 0.5, 0.2); //negative direction is lighter
         gl.vertex(0, 0, -100);
         gl.vertex(0, 0, 0);
   
         gl.color(0.2, 0.2, 0.2, 0.8); //positive direction
         gl.vertex(0, 0, 0);
         gl.vertex(0, 0, 100);
      }
      if(0) {
         gl.triangle();
         gl.color(0.6, 0.2, 0.6, 0.2); //positive direction
         gl.vertex(-plate,-plate,0);
         gl.vertex(plate,-plate,0);
         gl.vertex(plate,plate,0);
         gl.end();
         gl.triangle();
         gl.color(0.6, 0.2, 0.6, 0.2); //positive direction
         gl.vertex(plate,plate,0);
         gl.vertex(-plate,plate,0);
         gl.vertex(-plate,-plate,0);
         gl.end();
      }
      gl.end();
      gl.disable(gl.BLEND);
      // GL.Mesh.plane({ detailX: 20, detailY: 40 });
    }
  }
};

// Convert from CSG solid to an array of GL.Mesh objects
// limiting the number of vertices per mesh to less than 2^16
OpenJsCad.Viewer.csgToMeshes = function(initial_csg) {
  var csg = initial_csg.canonicalized();
  var mesh = new GL.Mesh({ normals: true, colors: true });
  var meshes = [ mesh ];
  var vertexTag2Index = {};
  var vertices = [];
  var colors = [];
  var triangles = [];
  // set to true if we want to use interpolated vertex normals
  // this creates nice round spheres but does not represent the shape of
  // the actual model
  var smoothlighting = false;
  var polygons = csg.toPolygons();
  var numpolygons = polygons.length;
  for(var j = 0; j < numpolygons; j++) {
    var polygon = polygons[j];
    var color = [1,.4,1,1];      // -- default color

    if(polygon.shared && polygon.shared.color) {
      color = polygon.shared.color;
    }
    if(polygon.color) {
      color = polygon.color;
    }

	if (color.length < 4)
		color.push(1.); //opaque

    var indices = polygon.vertices.map(function(vertex) {
      var vertextag = vertex.getTag();
      var vertexindex;
      if(smoothlighting && (vertextag in vertexTag2Index)) {
        vertexindex = vertexTag2Index[vertextag];
      } else {
        vertexindex = vertices.length;
        vertexTag2Index[vertextag] = vertexindex;
        vertices.push([vertex.pos.x, vertex.pos.y, vertex.pos.z]);
        colors.push(color);
      }
      return vertexindex;
    });
    for (var i = 2; i < indices.length; i++) {
      triangles.push([indices[0], indices[i - 1], indices[i]]);
    }
    // if too many vertices, start a new mesh;
    if (vertices.length > 65000) {
      // finalize the old mesh	
      mesh.triangles = triangles;
      mesh.vertices = vertices;
      mesh.colors = colors;
      mesh.computeWireframe();
      mesh.computeNormals();
      // start a new mesh
      mesh = new GL.Mesh({ normals: true, colors: true });
      triangles = [];
      colors = [];
      vertices = [];
      meshes.push(mesh);	
    }
  }
  // finalize last mesh
  mesh.triangles = triangles;
  mesh.vertices = vertices;
  mesh.colors = colors;
  mesh.computeWireframe();
  mesh.computeNormals();
  return meshes;
};

// this is a bit of a hack; doesn't properly supports urls that start with '/'
// but does handle relative urls containing ../
OpenJsCad.makeAbsoluteUrl = function(url, baseurl) {
  if(!url.match(/^[a-z]+\:/i)) {
    var basecomps = baseurl.split("/");
    if(basecomps.length > 0) {
      basecomps.splice(basecomps.length - 1, 1);
    }
    var urlcomps = url.split("/");
    var comps = basecomps.concat(urlcomps);
    var comps2 = [];
    comps.map(function(c) {
      if(c == "..") {
        if(comps2.length > 0) {
          comps2.splice(comps2.length - 1, 1);
        }
      } else {
        comps2.push(c);
      }
    });  
    url = "";
    for(var i = 0; i < comps2.length; i++) {
      if(i > 0) url += "/";
      url += comps2[i];
    }
  }
  return url;
};

OpenJsCad.isChrome = function() {
  return (navigator.userAgent.search("Chrome") >= 0);
};

// This is called from within the web worker. Execute the main() function of the supplied script
// and post a message to the calling thread when finished
OpenJsCad.runMainInWorker = function(mainParameters) {
  try {
    if(typeof(main) != 'function') throw new Error('Your jscad file should contain a function main() which returns a CSG solid or a CAG area.');
    OpenJsCad.log.prevLogTime = Date.now();    
    var result = main(mainParameters);
    if( (typeof(result) != "object") || ((!(result instanceof CSG)) && (!(result instanceof CAG)))) {
      //throw new Error("Your main() function should return a CSG solid or a CAG area.");
    }
    if(result.length) {                   // main() return an array, we consider it a bunch of CSG not intersecting
       var o = result[0];
       if(o instanceof CAG) {
          o = o.extrude({offset: [0,0,0.1]});
       }
       for(var i=1; i<result.length; i++) {
          var c = result[i];
          if(c instanceof CAG) {
             c = c.extrude({offset: [0,0,0.1]});
          }
          o = o.unionForNonIntersecting(c);
       }
       result = o;
    } 
    var result_compact = result.toCompactBinary();   
    result = null; // not needed anymore
    self.postMessage({cmd: 'rendered', result: result_compact});
  }
  catch(e) {
    var errtxt = e.stack;
    if(!errtxt) {
      errtxt = e.toString();
    } 
    self.postMessage({cmd: 'error', err: errtxt});
  }
};

OpenJsCad.parseJsCadScriptSync = function(script, mainParameters, debugging) {
  var workerscript = "//SYNC\n";
  workerscript += "_includePath = "+JSON.stringify(_includePath)+";\n";
  workerscript += script;
  if(debugging) {
    workerscript += "\n\n\n\n\n\n\n/* -------------------------------------------------------------------------\n";
    workerscript += "OpenJsCad debugging\n\nAssuming you are running Chrome:\nF10 steps over an instruction\nF11 steps into an instruction\n";
    workerscript += "F8  continues running\nPress the (||) button at the bottom to enable pausing whenever an error occurs\n";
    workerscript += "Click on a line number to set or clear a breakpoint\n";
    workerscript += "For more information see: http://code.google.com/chrome/devtools/docs/overview.html\n\n";
    workerscript += "------------------------------------------------------------------------- */\n"; 
    workerscript += "\n\n// Now press F11 twice to enter your main() function:\n\n";
    workerscript += "debugger;\n";
  }
  workerscript += "var me = " + JSON.stringify(me) + ";\n";
  workerscript += "return main("+JSON.stringify(mainParameters)+");";  
// trying to get include() somewhere:
// 1) XHR works for SYNC <---
// 2) importScripts() does not work in SYNC
// 3) _csg_libraries.push(fn) provides only 1 level include()

  workerscript += "function include(fn) {\
  if(0) {\
    _csg_libraries.push(fn);\
  } else if(0) {\
    var url = _includePath!=='undefined'?_includePath:'./';\
    var index = url.indexOf('index.html');\
    if(index!=-1) {\
       url = url.substring(0,index);\
    }\
  	 importScripts(url+fn);\
  } else {\
   console.log('SYNC checking gMemFs for '+fn);\
   if(gMemFs[fn]) {\
      console.log('found locally & eval:',gMemFs[fn].name);\
      eval(gMemFs[fn].source); return;\
   }\
   var xhr = new XMLHttpRequest();\
   xhr.open('GET',_includePath+fn,false);\
   console.log('include:'+_includePath+fn);\
   xhr.onload = function() {\
      var src = this.responseText;\
      eval(src);\
   };\
   xhr.onerror = function() {\
   };\
   xhr.send();\
  }\
}\
";
  //workerscript += "function includePath(p) { _includePath = p; }\n";
  
  if(0) {
    OpenJsCad.log.prevLogTime = Date.now();    
    return eval(workerscript);      // old fashion-way

  } else {
    var f = new Function(workerscript);
    OpenJsCad.log.prevLogTime = Date.now();    
    return f();                     // execute the actual code
  }
};

// callback: should be function(error, csg)
OpenJsCad.parseJsCadScriptASync = function(script, mainParameters, options, callback) {
  var baselibraries = [
    "csg.js",
    "openjscad.js",
    "openscad.js"
    //"jquery/jquery-1.9.1.js",
    //"jquery/jquery-ui.js"
  ];

  var baseurl = document.location.href.replace(/\?.*$/, '');
  baseurl = baseurl.replace(/#.*$/,'');        // remove remote URL 
  var openjscadurl = baseurl;
  if (options['openJsCadPath'] != null) {
    openjscadurl = OpenJsCad.makeAbsoluteUrl( options['openJsCadPath'], baseurl );
  }
        
  var libraries = [];
  if (options['libraries'] != null) {
    libraries = options['libraries'];
  }
  for(var i in gMemFs) {            // let's test all files and check syntax before we do anything
    var src = gMemFs[i].source+"\nfunction include() { }\n";
    var f;
    try {
       f = new Function(src);
    } catch(e) {
      this.setError(i+": "+e.message);
    }
  }
  var workerscript = "//ASYNC\n";
  workerscript += "var me = " + JSON.stringify(me) + ";\n";
  workerscript += "var _csg_baseurl=" + JSON.stringify(baseurl)+";\n";        // -- we need it early for include()
  workerscript += "var _includePath=" + JSON.stringify(_includePath)+";\n";    //        ''            ''
  workerscript += "var gMemFs = [];\n";
  var ignoreInclude = false;
  var mainFile;
  for(var fn in gMemFs) {
     workerscript += "// "+gMemFs[fn].name+":\n";
     //workerscript += gMemFs[i].source+"\n";
     if(!mainFile) 
        mainFile = fn;
     if(fn=='main.jscad'||fn.match(/\/main.jscad$/)) 
        mainFile = fn;
     workerscript += "gMemFs[\""+gMemFs[fn].name+"\"] = "+JSON.stringify(gMemFs[fn].source)+";\n";
     ignoreInclude = true;
  }
  if(ignoreInclude) {
     workerscript += "eval(gMemFs['"+mainFile+"']);\n";
  } else {
     workerscript += script;
  }
  workerscript += "\n\n\n\n//// The following code is added by OpenJsCad + OpenJSCAD.org:\n";

  workerscript += "var _csg_baselibraries=" + JSON.stringify(baselibraries)+";\n";
  workerscript += "var _csg_libraries=" + JSON.stringify(libraries)+";\n";
  workerscript += "var _csg_openjscadurl=" + JSON.stringify(openjscadurl)+";\n";
  workerscript += "var _csg_makeAbsoluteURL=" + OpenJsCad.makeAbsoluteUrl.toString()+";\n";
//  workerscript += "if(typeof(libs) == 'function') _csg_libraries = _csg_libraries.concat(libs());\n";
  workerscript += "_csg_baselibraries = _csg_baselibraries.map(function(l){return _csg_makeAbsoluteURL(l,_csg_openjscadurl);});\n";
  workerscript += "_csg_libraries = _csg_libraries.map(function(l){return _csg_makeAbsoluteURL(l,_csg_baseurl);});\n";
  workerscript += "_csg_baselibraries.map(function(l){importScripts(l)});\n";
  workerscript += "_csg_libraries.map(function(l){importScripts(l)});\n";
  workerscript += "self.addEventListener('message', function(e) {if(e.data && e.data.cmd == 'render'){";
  workerscript += "  OpenJsCad.runMainInWorker("+JSON.stringify(mainParameters)+");";
//  workerscript += "  if(typeof(main) != 'function') throw new Error('Your jscad file should contain a function main() which returns a CSG solid.');\n";
//  workerscript += "  var csg; try {csg = main("+JSON.stringify(mainParameters)+"); self.postMessage({cmd: 'rendered', csg: csg});}";
//  workerscript += "  catch(e) {var errtxt = e.stack; self.postMessage({cmd: 'error', err: errtxt});}";
  workerscript += "}},false);\n";

// trying to get include() somewhere: 
// 1) XHR fails: not allowed in blobs
// 2) importScripts() works for ASYNC <----
// 3) _csg_libraries.push(fn) provides only 1 level include()

  if(!ignoreInclude) {
     workerscript += "function include(fn) {\
  if(0) {\
    _csg_libraries.push(fn);\
  } else if(1) {\
   if(gMemFs[fn]) {\
      eval(gMemFs[fn]); return;\
   }\
    var url = _csg_baseurl+_includePath;\
    var index = url.indexOf('index.html');\
    if(index!=-1) {\
       url = url.substring(0,index);\
    }\
  	 importScripts(url+fn);\
  } else {\
   var xhr = new XMLHttpRequest();\
   xhr.open('GET', _includePath+fn, true);\
   xhr.onload = function() {\
      return eval(this.responseText);\
   };\
   xhr.onerror = function() {\
   };\
   xhr.send();\
  }\
}\
";
  } else {
     //workerscript += "function include() {}\n";
     workerscript += "function include(fn) { eval(gMemFs[fn]); }\n";
  }
  //workerscript += "function includePath(p) { _includePath = p; }\n";
  var blobURL = OpenJsCad.textToBlobUrl(workerscript);
  
  if(!window.Worker) throw new Error("Your browser doesn't support Web Workers. Please try the Chrome or Firefox browser instead.");
  var worker = new Worker(blobURL);
  worker.onmessage = function(e) {
    if(e.data)
    { 
      if(e.data.cmd == 'rendered')
      {
        var resulttype = e.data.result.class;
        var result;
        if(resulttype == "CSG")
        {
          result = CSG.fromCompactBinary(e.data.result);
        }
        else if(resulttype == "CAG")
        {
          result = CAG.fromCompactBinary(e.data.result);
        }
        else
        {
          throw new Error("Cannot parse result");
        }
        callback(null, result);
      }
      else if(e.data.cmd == "error")
      {
        callback(e.data.err, null);
      }
      else if(e.data.cmd == "log")
      {
        console.log(e.data.txt);
      }
    }
  };
  worker.onerror = function(e) {
    var errtxt = "Error in line "+e.lineno+": "+e.message;
    callback(errtxt, null);
  };
  worker.postMessage({
    cmd: "render"
  }); // Start the worker.
  return worker;
};

OpenJsCad.getWindowURL = function() {
  if(window.URL) return window.URL;
  else if(window.webkitURL) return window.webkitURL;
  else throw new Error("Your browser doesn't support window.URL");
};

OpenJsCad.textToBlobUrl = function(txt) {
  var windowURL=OpenJsCad.getWindowURL();
  var blob = new Blob([txt]);
  var blobURL = windowURL.createObjectURL(blob);
  if(!blobURL) throw new Error("createObjectURL() failed"); 
  return blobURL;
};

OpenJsCad.revokeBlobUrl = function(url) {
  if(window.URL) window.URL.revokeObjectURL(url);
  else if(window.webkitURL) window.webkitURL.revokeObjectURL(url);
  else throw new Error("Your browser doesn't support window.URL");
};

OpenJsCad.FileSystemApiErrorHandler = function(fileError, operation) {
  var errormap = {
    1: 'NOT_FOUND_ERR',
    2: 'SECURITY_ERR',
    3: 'ABORT_ERR',
    4: 'NOT_READABLE_ERR',
    5: 'ENCODING_ERR',
    6: 'NO_MODIFICATION_ALLOWED_ERR',
    7: 'INVALID_STATE_ERR',
    8: 'SYNTAX_ERR',
    9: 'INVALID_MODIFICATION_ERR',
    10: 'QUOTA_EXCEEDED_ERR',
    11: 'TYPE_MISMATCH_ERR',
    12: 'PATH_EXISTS_ERR',
  };
  var errname;
  if(fileError.code in errormap)
  {
    errname = errormap[fileError.code];
  }
  else
  {
    errname = "Error #"+fileError.code;
  }
  var errtxt = "FileSystem API error: "+operation+" returned error "+errname;
  throw new Error(errtxt);
};

OpenJsCad.AlertUserOfUncaughtExceptions = function() {
  window.onerror = function(message, url, line) {
    message = message.replace(/^Uncaught /i, "");
    alert(message+"\n\n("+url+" line "+line+")");
  };
};

// parse the jscad script to get the parameter definitions
OpenJsCad.getParamDefinitions = function(script) {
  var scriptisvalid = true;
  script += "\nfunction include() {}";    // at least make it not throw an error so early
  try
  {
    // first try to execute the script itself
    // this will catch any syntax errors
    //    BUT we can't introduce any new function!!!
    (new Function(script))();
  }
  catch(e) {
    scriptisvalid = false;
  }
  var params = [];
  if(scriptisvalid)
  {
    var script1 = "if(typeof(getParameterDefinitions) == 'function') {return getParameterDefinitions();} else {return [];} ";
    script1 += script;
    var f = new Function(script1);
    params = f();
    if( (typeof(params) != "object") || (typeof(params.length) != "number") )
    {
      throw new Error("The getParameterDefinitions() function should return an array with the parameter definitions");
    }
  }
  return params;
};

OpenJsCad.Processor = function(containerdiv, onchange) {
  this.containerdiv = containerdiv;
  this.onchange = onchange;
  this.viewerdiv = null;
  this.viewer = null;
  this.zoomControl = null;
  //this.viewerwidth = 1200;
  //this.viewerheight = 800;
  this.initialViewerDistance = 100;
  this.processing = false;
  this.currentObject = null;
  this.hasValidCurrentObject = false;
  this.hasOutputFile = false;
  this.worker = null;
  this.paramDefinitions = [];
  this.paramControls = [];
  this.script = null;
  this.hasError = false;
  this.debugging = false;
  this.options = {};
  this.createElements();
};

OpenJsCad.Processor.convertToSolid = function(obj) {
  //echo("typeof="+typeof(obj),obj.length);

  if( (typeof(obj) == "object") && ((obj instanceof CAG)) ) {
    // convert a 2D shape to a thin solid:
    obj = obj.extrude({offset: [0,0,0.1]});

  } else if( (typeof(obj) == "object") && ((obj instanceof CSG)) ) {
    // obj already is a solid, nothing to do
    ;
    
  } else if(obj.length) {                   // main() return an array, we consider it a bunch of CSG not intersecting
    //echo("putting them together");
    var o = obj[0];
    for(var i=1; i<obj.length; i++) {
       o = o.unionForNonIntersecting(obj[i]);
    }
    obj = o;
    //echo("done.");
    
  } else {
    throw new Error("Cannot convert to solid");
  }
  return obj;
};

OpenJsCad.Processor.prototype = {
  createElements: function() {
    var that = this;   // for event handlers

    while(this.containerdiv.children.length > 0)
    {
      this.containerdiv.removeChild(0);
    }
/*    
    if(!OpenJsCad.isChrome() )
    {
      var div = document.createElement("div");
      div.innerHTML = "Please note: OpenJsCad currently only runs reliably on Google Chrome!";
      this.containerdiv.appendChild(div);
    }
*/    
    var viewerdiv = document.createElement("div");
    viewerdiv.className = "viewer";
    viewerdiv.style.width = '100%'; //this.viewerwidth; // + "px";
    viewerdiv.style.height = '100%'; //this.viewerheight; // + "px";
    viewerdiv.style.width = screen.width;
    viewerdiv.style.height = screen.height;
    //viewerdiv.style.overflow = 'hidden';
    viewerdiv.style.backgroundColor = "rgb(200,200,200)";
    this.containerdiv.appendChild(viewerdiv);
    this.viewerdiv = viewerdiv;
    try {
      //this.viewer = new OpenJsCad.Viewer(this.viewerdiv, this.viewerwidth, this.viewerheight, this.initialViewerDistance);
      //this.viewer = new OpenJsCad.Viewer(this.viewerdiv, viewerdiv.offsetWidth, viewer.offsetHeight, this.initialViewerDistance);
      this.viewer = new OpenJsCad.Viewer(this.viewerdiv, screen.width, screen.height, this.initialViewerDistance);
    } catch(e) {
      //      this.viewer = null;
      this.viewerdiv.innerHTML = "<b><br><br>Error: " + e.toString() + "</b><br><br>OpenJsCad currently requires Google Chrome or Firefox with WebGL enabled";
      //      this.viewerdiv.innerHTML = e.toString();
    }
    //Zoom control
    if(0) {
       var div = document.createElement("div");
       this.zoomControl = div.cloneNode(false);
       this.zoomControl.style.width = this.viewerwidth + 'px';
       this.zoomControl.style.height = '20px';
       this.zoomControl.style.backgroundColor = 'transparent';
       this.zoomControl.style.overflowX = 'scroll';
       div.style.width = this.viewerwidth * 11 + 'px';
       div.style.height = '1px';
       this.zoomControl.appendChild(div);
       this.zoomChangedBySlider = false;
       this.zoomControl.onscroll = function(event) {
         var zoom = that.zoomControl;
         var newzoom=zoom.scrollLeft / (10 * zoom.offsetWidth);
         that.zoomChangedBySlider=true; // prevent recursion via onZoomChanged 
         that.viewer.setZoom(newzoom);
         that.zoomChangedBySlider=false;
       };
       this.viewer.onZoomChanged = function() {
         if(!that.zoomChangedBySlider)
         {
           var newzoom = that.viewer.getZoom();
           that.zoomControl.scrollLeft = newzoom * (10 * that.zoomControl.offsetWidth);
         }
       };

       this.containerdiv.appendChild(this.zoomControl);
       //this.zoomControl.scrollLeft = this.viewer.viewpointZ / this.viewer.ZOOM_MAX * this.zoomControl.offsetWidth;
       this.zoomControl.scrollLeft = this.viewer.viewpointZ / this.viewer.ZOOM_MAX * 
         (this.zoomControl.scrollWidth - this.zoomControl.offsetWidth);

       //end of zoom control
    }
    //this.errordiv = document.createElement("div");
    this.errordiv = document.getElementById("errordiv");
    this.errorpre = document.createElement("pre"); 
    this.errordiv.appendChild(this.errorpre);
    //this.statusdiv = document.createElement("div");
    this.statusdiv = document.getElementById("statusdiv");
    this.statusdiv.className = "statusdiv";
    //this.statusdiv.style.width = this.viewerwidth + "px";
    this.statusspan = document.createElement("span");
    this.statusspan.id = 'statusspan';
    this.statusspan.style.marginRight = '2em';
    this.statusbuttons = document.createElement("span");
    this.statusbuttons.style.float = "right";
    this.statusdiv.appendChild(this.statusspan);
    this.statusdiv.appendChild(this.statusbuttons);
    this.abortbutton = document.createElement("button");
    this.abortbutton.innerHTML = "Abort";
    this.abortbutton.onclick = function(e) {
      that.abort();
    };
    this.statusbuttons.appendChild(this.abortbutton);
    this.formatDropdown = document.createElement("select");
    this.formatDropdown.onchange = function(e) {
      that.currentFormat = that.formatDropdown.options[that.formatDropdown.selectedIndex].value;
      that.updateDownloadLink();
    };
    this.statusbuttons.appendChild(this.formatDropdown);
    this.generateOutputFileButton = document.createElement("button");
    this.generateOutputFileButton.onclick = function(e) {
      that.generateOutputFile();
    };
    this.statusbuttons.appendChild(this.generateOutputFileButton);
    this.downloadOutputFileLink = document.createElement("a");
    this.downloadOutputFileLink.className = "downloadOutputFileLink"; // so we can css it
    this.statusbuttons.appendChild(this.downloadOutputFileLink);

    //this.parametersdiv = document.createElement("div");            // already created
    this.parametersdiv = document.getElementById("parametersdiv");   // get the info
    this.parametersdiv.id = "parametersdiv";
    // this.parametersdiv.className = "ui-draggable";                   // via jQuery draggable() but it screws up 

    var headerdiv = document.createElement("div");
    //headerdiv.innerText = "Parameters:";
    headerdiv.innerHTML = "Parameters:";
    headerdiv.className = "parameterheader";
    this.parametersdiv.appendChild(headerdiv);

    this.parameterstable = document.createElement("table");
    this.parameterstable.className = "parameterstable";
    this.parametersdiv.appendChild(this.parameterstable);

    var parseParametersButton = document.createElement("button");
    parseParametersButton.innerHTML = "Update";
    parseParametersButton.onclick = function(e) {
      that.rebuildSolid();
    };
    this.parametersdiv.appendChild(parseParametersButton);

    // implementing instantUpdate
    var instantUpdateCheckbox = document.createElement("input");
    instantUpdateCheckbox.type = "checkbox";
    instantUpdateCheckbox.id = "instantUpdate";
    this.parametersdiv.appendChild(instantUpdateCheckbox);

    var instantUpdateCheckboxText = document.createElement("span");
    instantUpdateCheckboxText.innerHTML = "Instant Update";
    instantUpdateCheckboxText.id = "instantUpdateLabel";
    this.parametersdiv.appendChild(instantUpdateCheckboxText);

    this.enableItems();    

    // they exist already, so no appendChild anymore (remains here)
    //this.containerdiv.appendChild(this.statusdiv);
    //this.containerdiv.appendChild(this.errordiv);
    //this.containerdiv.appendChild(this.parametersdiv); 

    this.clearViewer();
  },
  
  setCurrentObject: function(obj) {
    this.currentObject = obj;                                  // CAG or CSG
    if(this.viewer) {
      var csg = OpenJsCad.Processor.convertToSolid(obj);       // enfore CSG to display
      this.viewer.setCsg(csg);
      if(obj.length)             // if it was an array (multiple CSG is now one CSG), we have to reassign currentObject
         this.currentObject = csg;
    }
    this.hasValidCurrentObject = true;
    
    while(this.formatDropdown.options.length > 0)
      this.formatDropdown.options.remove(0);
    
    var that = this;
    this.supportedFormatsForCurrentObject().forEach(function(format) {
      var option = document.createElement("option");
      option.setAttribute("value", format);
      option.appendChild(document.createTextNode(that.formatInfo(format).displayName));
      that.formatDropdown.options.add(option);
    });
    
    this.updateDownloadLink();
  },
  
  selectedFormat: function() {
    return this.formatDropdown.options[this.formatDropdown.selectedIndex].value;
  },

  selectedFormatInfo: function() {
    return this.formatInfo(this.selectedFormat());
  },
  
  updateDownloadLink: function() {
    var ext = this.selectedFormatInfo().extension;
    this.generateOutputFileButton.innerHTML = "Generate "+ext.toUpperCase();
  },
  
  clearViewer: function() {
    this.clearOutputFile();
    this.setCurrentObject(new CSG());
    this.hasValidCurrentObject = false;
    this.enableItems();
  },
  
  abort: function() {
    if(this.processing)
    {
      //todo: abort
      this.processing=false;
      this.statusspan.innerHTML = "Aborted.";
      this.worker.terminate();
      this.enableItems();
      if(this.onchange) this.onchange();
    }
  },
  
  enableItems: function() {
    this.abortbutton.style.display = this.processing? "inline":"none";
    this.formatDropdown.style.display = ((!this.hasOutputFile)&&(this.hasValidCurrentObject))? "inline":"none";
    this.generateOutputFileButton.style.display = ((!this.hasOutputFile)&&(this.hasValidCurrentObject))? "inline":"none";
    this.downloadOutputFileLink.style.display = this.hasOutputFile? "inline":"none";
    this.parametersdiv.style.display = (this.paramControls.length > 0)? "inline-block":"none";     // was 'block' 
    this.errordiv.style.display = this.hasError? "block":"none";
    this.statusdiv.style.display = this.hasError? "none":"block";    
  },

  setOpenJsCadPath: function(path) {
    this.options[ 'openJsCadPath' ] = path;
  },

  addLibrary: function(lib) {
    if( this.options[ 'libraries' ] == null ) {
      this.options[ 'libraries' ] = [];
    }
    this.options[ 'libraries' ].push( lib );
  },
  
  setError: function(txt) {
    this.hasError = (txt != "");
    this.errorpre.innerText = txt;
    this.enableItems();
  },
  
  setDebugging: function(debugging) {
    this.debugging = debugging;
  },
  
  // script: javascript code
  // filename: optional, the name of the .jscad file
  setJsCad: function(script, filename) {
    if(!filename) filename = "openjscad.jscad";
    filename = filename.replace(/\.jscad$/i, "");
    this.abort();
    this.clearViewer();
    this.paramDefinitions = [];
    this.paramControls = [];
    this.script = null;
    this.setError("");
    var scripthaserrors = false;
    try
    {
      this.paramDefinitions = OpenJsCad.getParamDefinitions(script);
      this.createParamControls();
    }
    catch(e)
    {
      this.setError(e.toString());
      this.statusspan.innerHTML = "Error.";
      scripthaserrors = true;
    }
    if(!scripthaserrors)
    {
      this.script = script;
      this.filename = filename;
      this.rebuildSolid();
    }
    else
    {
      this.enableItems();
      if(this.onchange) this.onchange();
    }
  },
  
  getParamValues: function()
  {
    var paramValues = {};
    for(var i = 0; i < this.paramDefinitions.length; i++)
    {
      var paramdef = this.paramDefinitions[i];
      var type = "text";
      if('type' in paramdef)
      {
        type = paramdef.type;
      }
      var control = this.paramControls[i];
      var value = null;
      if( (type == "text") || (type == "float") || (type == "int") )
      {
        value = control.value;
        if( (type == "float") || (type == "int") )
        {
          var isnumber = !isNaN(parseFloat(value)) && isFinite(value);
          if(!isnumber)
          {
            throw new Error("Not a number: "+value);
          }
          if(type == "int")
          {
            value = parseInt(value);
          }
          else
          {
            value = parseFloat(value);
          }
        }
      }
      else if(type == "choice")
      {
        value = control.options[control.selectedIndex].value;
      }
      paramValues[paramdef.name] = value;
    }
    return paramValues;
  },
    
  rebuildSolid: function()
  {
    this.abort();
    this.setError("");
    this.clearViewer();
    this.processing = true;
    this.statusspan.innerHTML = "Rendering code, please wait <img id=busy src='imgs/busy.gif'>";
    this.enableItems();
    var that = this;
    var paramValues = this.getParamValues();
    var useSync = this.debugging;

    //useSync = true;
    if(!useSync)
    {
      try
      {
          console.log("trying async compute");
          this.worker = OpenJsCad.parseJsCadScriptASync(this.script, paramValues, this.options, function(err, obj) {
          that.processing = false;
          that.worker = null;
          if(err)
          {
            that.setError(err);
            that.statusspan.innerHTML = "Error.";
          }
          else
          {
            that.setCurrentObject(obj);
            that.statusspan.innerHTML = "Ready.";
          }
          that.enableItems();
          if(that.onchange) that.onchange();
        });
      }
      catch(e)
      {
        console.log("async failed, try sync compute, error: "+e.message);
        useSync = true;
      }
    }
    
    if(useSync)
    {
      try
      {
        this.statusspan.innerHTML = "Rendering code, please wait <img id=busy src='imgs/busy.gif'>";
        var obj = OpenJsCad.parseJsCadScriptSync(this.script, paramValues, this.debugging);
        that.setCurrentObject(obj);
        that.processing = false;
        that.statusspan.innerHTML = "Ready.";
      }
      catch(e)
      {
        that.processing = false;
        var errtxt = e.stack;
        if(!errtxt)
        {
          errtxt = e.toString();
        }
        that.setError(errtxt);
        that.statusspan.innerHTML = "Error.";
      }
      that.enableItems();
      if(that.onchange) that.onchange();
    }
  },
  
  hasSolid: function() {
    return this.hasValidCurrentObject;
  },

  isProcessing: function() {
    return this.processing;
  },
   
  clearOutputFile: function() {
    if(this.hasOutputFile)
    {
      this.hasOutputFile = false;
      if(this.outputFileDirEntry)
      {
        this.outputFileDirEntry.removeRecursively(function(){});
        this.outputFileDirEntry=null;
      }
      if(this.outputFileBlobUrl)
      {
        OpenJsCad.revokeBlobUrl(this.outputFileBlobUrl);
        this.outputFileBlobUrl = null;
      }
      this.enableItems();
      if(this.onchange) this.onchange();
    }
  },

  generateOutputFile: function() {
    this.clearOutputFile();
    if(this.hasValidCurrentObject)
    {
      try
      {
        this.generateOutputFileFileSystem();
      }
      catch(e)
      {
        this.generateOutputFileBlobUrl();
      }
    }
  },

  currentObjectToBlob: function() {
    var format = this.selectedFormat();
    
    var blob;
    if(format == "stla") {      
      blob = this.currentObject.toStlString();        
      blob = new Blob([blob],{ type: this.formatInfo(format).mimetype });
    }
    else if(format == "stlb") {      
      //blob = this.currentObject.fixTJunctions().toStlBinary();   // gives normal errors, but we keep it for now (fixTJunctions() needs debugging)
      blob = this.currentObject.toStlBinary({webBlob: true});     

      // -- binary string -> blob gives bad data, so we request cgs.js already blobbing the binary
      //blob = new Blob([blob],{ type: this.formatInfo(format).mimetype+"/charset=UTF-8" }); 
    }
    else if(format == "amf") {
      blob = this.currentObject.toAMFString({
        producer: "OpenJSCAD.org "+version,
        date: new Date()
      });
      blob = new Blob([blob],{ type: this.formatInfo(format).mimetype });
    }  
    else if(format == "x3d") {
      blob = this.currentObject.fixTJunctions().toX3D(bb);
    }
    else if(format == "dxf") {
      blob = this.currentObject.toDxf();
    }
    else {
      throw new Error("Not supported");
    }    
    return blob;
  },
  
  supportedFormatsForCurrentObject: function() {
    if (this.currentObject instanceof CSG) {
      return ["stlb", "stla", "amf", "x3d"];
    } else if (this.currentObject instanceof CAG) {
      return ["dxf"];
    } else {
      throw new Error("Not supported");
    }
  },
  
  formatInfo: function(format) {
    return {
      stla: {
        displayName: "STL (ASCII)",
        extension: "stl",
        mimetype: "application/sla",
        },
      stlb: {
        displayName: "STL (Binary)",
        extension: "stl",
        mimetype: "application/sla",
        },
      amf: {
        displayName: "AMF (experimental)",
        extension: "amf",
        mimetype: "application/amf+xml",
        },
      x3d: {
        displayName: "X3D",
        extension: "x3d",
        mimetype: "model/x3d+xml",
        },
      dxf: {
        displayName: "DXF",
        extension: "dxf",
        mimetype: "application/dxf",
        }
    }[format];
  },

  downloadLinkTextForCurrentObject: function() {
    var ext = this.selectedFormatInfo().extension;
    return "Download "+ext.toUpperCase();
  },

  generateOutputFileBlobUrl: function() {
    var blob = this.currentObjectToBlob();
    var windowURL=OpenJsCad.getWindowURL();
    this.outputFileBlobUrl = windowURL.createObjectURL(blob);
    if(!this.outputFileBlobUrl) throw new Error("createObjectURL() failed"); 
    this.hasOutputFile = true;
    this.downloadOutputFileLink.href = this.outputFileBlobUrl;
    this.downloadOutputFileLink.innerHTML = this.downloadLinkTextForCurrentObject();
    var ext = this.selectedFormatInfo().extension;
    this.downloadOutputFileLink.setAttribute("download", "openjscad."+ext);
    this.enableItems();
    if(this.onchange) this.onchange();
  },

  generateOutputFileFileSystem: function() {
    window.requestFileSystem  = window.requestFileSystem || window.webkitRequestFileSystem;
    if(!window.requestFileSystem)
    {
      throw new Error("Your browser does not support the HTML5 FileSystem API. Please try the Chrome browser instead.");
    }
    // create a random directory name:
    var dirname = "OpenJsCadOutput1_"+parseInt(Math.random()*1000000000, 10)+"."+extension;
    var extension = this.selectedFormatInfo().extension;
    var filename = "output."+extension;
    var that = this;
    window.requestFileSystem(TEMPORARY, 20*1024*1024, function(fs){
        fs.root.getDirectory(dirname, {create: true, exclusive: true}, function(dirEntry) {
            that.outputFileDirEntry = dirEntry;
            dirEntry.getFile(filename, {create: true, exclusive: true}, function(fileEntry) {
                 fileEntry.createWriter(function(fileWriter) {
                    fileWriter.onwriteend = function(e) {
                      that.hasOutputFile = true;
                      that.downloadOutputFileLink.href = fileEntry.toURL();
                      that.downloadOutputFileLink.type = that.selectedFormatInfo().mimetype; 
                      that.downloadOutputFileLink.innerHTML = that.downloadLinkTextForCurrentObject();
                      that.downloadOutputFileLink.setAttribute("download", fileEntry.name);
                      that.enableItems();
                      if(that.onchange) that.onchange();
                    };
                    fileWriter.onerror = function(e) {
                      throw new Error('Write failed: ' + e.toString());
                    };
                    var blob = that.currentObjectToBlob();
                    console.log(blob,blob.length);                
                    fileWriter.write(blob);
                  }, 
                  function(fileerror){OpenJsCad.FileSystemApiErrorHandler(fileerror, "createWriter");} 
                );
              },
              function(fileerror){OpenJsCad.FileSystemApiErrorHandler(fileerror, "getFile('"+filename+"')");} 
            );
          },
          function(fileerror){OpenJsCad.FileSystemApiErrorHandler(fileerror, "getDirectory('"+dirname+"')");} 
        );         
      }, 
      function(fileerror){OpenJsCad.FileSystemApiErrorHandler(fileerror, "requestFileSystem");}
    );
  },
  
  createParamControls: function() {
    this.parameterstable.innerHTML = "";
    this.paramControls = [];
    var paramControls = [];
    var tablerows = [];
    for(var i = 0; i < this.paramDefinitions.length; i++)
    {
      var errorprefix = "Error in parameter definition #"+(i+1)+": ";
      var paramdef = this.paramDefinitions[i];
      if(!('name' in paramdef))
      {
        throw new Error(errorprefix + "Should include a 'name' parameter");
      }
      var type = "text";
      if('type' in paramdef)
      {
        type = paramdef.type;
      }
      if( (type !== "text") && (type !== "int") && (type !== "float") && (type !== "choice") )
      {
        throw new Error(errorprefix + "Unknown parameter type '"+type+"'");
      }
      var control;
      if( (type == "text") || (type == "int") || (type == "float") )
      {
        control = document.createElement("input");
        control.type = "text";
        if('default' in paramdef)
        {
          control.value = paramdef["default"];
        }
        else if('initial' in paramdef)
          control.value = paramdef.initial;
        else
        {
          if( (type == "int") || (type == "float") )
          {
            control.value = "0";
          }
          else
          {
            control.value = "";
          }
        }
        if(paramdef.size!==undefined) 
           control.size = paramdef.size;
      }
      else if(type == "choice")
      {
        if(!('values' in paramdef))
        {
          throw new Error(errorprefix + "Should include a 'values' parameter");
        }        
        control = document.createElement("select");
        var values = paramdef.values;
        var captions;
        if('captions' in paramdef)
        {
          captions = paramdef.captions;
          if(captions.length != values.length)
          {
            throw new Error(errorprefix + "'captions' and 'values' should have the same number of items");
          }
        }
        else
        {
          captions = values;
        }
        var selectedindex = 0;
        for(var valueindex = 0; valueindex < values.length; valueindex++)
        {
          var option = document.createElement("option");
          option.value = values[valueindex];
          option.text = captions[valueindex];
          control.add(option);
          if('default' in paramdef)
          {
            if(paramdef["default"] == values[valueindex])
            {
              selectedindex = valueindex;
            }
          }
          else if('initial' in paramdef)
          {
            if(paramdef.initial == values[valueindex])
            {
              selectedindex = valueindex;
            }
          }
        }
        if(values.length > 0)
        {
          control.selectedIndex = selectedindex;
        }        
      }
      // implementing instantUpdate
      control.onchange = function() { 
         if(document.getElementById("instantUpdate").checked==true) {
            that.rebuildSolid();
         }
      };
      paramControls.push(control);
      var tr = document.createElement("tr");
      var td = document.createElement("td");
      var label = paramdef.name + ":";
      if('caption' in paramdef)
      {
        label = paramdef.caption;
        td.className = 'caption';
      }
       
      td.innerHTML = label;
      tr.appendChild(td);
      td = document.createElement("td");
      td.appendChild(control);
      tr.appendChild(td);
      tablerows.push(tr);
    }
    var that = this;
    tablerows.map(function(tr){
      that.parameterstable.appendChild(tr);
    }); 
    this.paramControls = paramControls;
  },
};


if (typeof exports !== 'undefined') {
    module.exports = OpenJsCad
}


});
require.register("jonnor-OpenJSCADorg/lightgl.js", function(exports, require, module){
/*
 * lightgl.js
 * http://github.com/evanw/lightgl.js/
 *
 * Copyright 2011 Evan Wallace
 * Released under the MIT license
 */
var GL = (function() {

	// src/texture.js
	// Provides a simple wrapper around WebGL textures that supports render-to-texture.
	// ### new GL.Texture(width, height[, options])
	//
	// The arguments `width` and `height` give the size of the texture in texels.
	// WebGL texture dimensions must be powers of two unless `filter` is set to
	// either `gl.NEAREST` or `gl.LINEAR` and `wrap` is set to `gl.CLAMP_TO_EDGE`
	// (which they are by default).
	//
	// Texture parameters can be passed in via the `options` argument.
	// Example usage:
	//
	//     var t = new GL.Texture(256, 256, {
	//       // Defaults to gl.LINEAR, set both at once with "filter"
	//       magFilter: gl.NEAREST,
	//       minFilter: gl.LINEAR,
	//
	//       // Defaults to gl.CLAMP_TO_EDGE, set both at once with "wrap"
	//       wrapS: gl.REPEAT,
	//       wrapT: gl.REPEAT,
	//
	//       format: gl.RGB, // Defaults to gl.RGBA
	//       type: gl.FLOAT // Defaults to gl.UNSIGNED_BYTE
	//     });


	function Texture(width, height, options) {
		options = options || {};
		this.id = gl.createTexture();
		this.width = width;
		this.height = height;
		this.format = options.format || gl.RGBA;
		this.type = options.type || gl.UNSIGNED_BYTE;
		gl.bindTexture(gl.TEXTURE_2D, this.id);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, options.filter || options.magFilter || gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.filter || options.minFilter || gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.wrap || options.wrapS || gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.wrap || options.wrapT || gl.CLAMP_TO_EDGE);
		gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
	}

	var framebuffer;
	var renderbuffer;
	var checkerboardCanvas;

	Texture.prototype = {
		// ### .bind([unit])
		//
		// Bind this texture to the given texture unit (0-7, defaults to 0).
		bind: function(unit) {
			gl.activeTexture(gl.TEXTURE0 + (unit || 0));
			gl.bindTexture(gl.TEXTURE_2D, this.id);
		},

		// ### .unbind([unit])
		//
		// Clear the given texture unit (0-7, defaults to 0).
		unbind: function(unit) {
			gl.activeTexture(gl.TEXTURE0 + (unit || 0));
			gl.bindTexture(gl.TEXTURE_2D, null);
		},

		// ### .drawTo(callback[, options])
		//
		// Render all draw calls in `callback` to this texture. This method
		// sets up a framebuffer with this texture as the color attachment
		// and a renderbuffer as the depth attachment.  The viewport is
		// temporarily changed to the size of the texture.
		//
		// The depth buffer can be omitted via `options` as shown in the
		// example below:
		//
		//     texture.drawTo(function() {
		//       gl.clearColor(1, 0, 0, 1);
		//       gl.clear(gl.COLOR_BUFFER_BIT);
		//     }, { depth: false });
		drawTo: function(callback, options) {

			options = options || {};
			var v = gl.getParameter(gl.VIEWPORT);
			gl.viewport(0, 0, this.width, this.height);

			framebuffer = framebuffer || gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);

			if(options.depth !== false) {
				renderbuffer = renderbuffer || gl.createRenderbuffer();
				gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
				if(this.width != renderbuffer.width || this.height != renderbuffer.height) {
					renderbuffer.width = this.width;
					renderbuffer.height = this.height;
					gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
				}
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
			}

			callback();

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.viewport(v[0], v[1], v[2], v[3]);
		},

		// ### .swapWith(other)
		//
		// Switch this texture with `other`, useful for the ping-pong rendering
		// technique used in multi-stage rendering.
		swapWith: function(other) {
			var temp;
			temp = other.id;
			other.id = this.id;
			this.id = temp;
			temp = other.width;
			other.width = this.width;
			this.width = temp;
			temp = other.height;
			other.height = this.height;
			this.height = temp;
		}
	};

	// ### GL.Texture.fromImage(image[, options])
	//
	// Return a new image created from `image`, an `<img>` tag.
	Texture.fromImage = function(image, options) {
		options = options || {};
		var texture = new Texture(image.width, image.height, options);
		try {
			gl.texImage2D(gl.TEXTURE_2D, 0, texture.format, texture.format, texture.type, image);
		} catch(e) {
			if(window.location.protocol == 'file:') {
				throw 'image not loaded for security reasons (serve this page over "http://" instead)';
			} else {
				throw 'image not loaded for security reasons (image must originate from the same ' +
					'domain as this page or use Cross-Origin Resource Sharing)';
			}
		}
		if(options.minFilter && options.minFilter != gl.NEAREST && options.minFilter != gl.LINEAR) {
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		return texture;
	};

	// ### GL.Texture.fromURL(url[, options])
	//
	// Returns a checkerboard texture that will switch to the correct texture when
	// it loads.
	Texture.fromURL = function(url, options) {
		checkerboardCanvas = checkerboardCanvas || (function() {
			var c = document.createElement('canvas').getContext('2d');
			c.canvas.width = c.canvas.height = 128;
			for(var y = 0; y < c.canvas.height; y += 16) {
				for(var x = 0; x < c.canvas.width; x += 16) {
					c.fillStyle = (x ^ y) & 16 ? '#FFF' : '#DDD';
					c.fillRect(x, y, 16, 16);
				}
			}
			return c.canvas;
		})();
		var texture = Texture.fromImage(checkerboardCanvas, options);
		var image = new Image();
		var context = gl;
		image.onload = function() {
			context.makeCurrent();
			Texture.fromImage(image, options).swapWith(texture);
		};
		image.src = url;
		return texture;
	};

	// src/mesh.js
	// Represents indexed triangle geometry with arbitrary additional attributes.
	// You need a shader to draw a mesh; meshes can't draw themselves.
	//
	// A mesh is a collection of `GL.Buffer` objects which are either vertex buffers
	// (holding per-vertex attributes) or index buffers (holding the order in which
	// vertices are rendered). By default, a mesh has a position vertex buffer called
	// `vertices` and a triangle index buffer called `triangles`. New buffers can be
	// added using `addVertexBuffer()` and `addIndexBuffer()`. Two strings are
	// required when adding a new vertex buffer, the name of the data array on the
	// mesh instance and the name of the GLSL attribute in the vertex shader.
	//
	// Example usage:
	//
	//     var mesh = new GL.Mesh({ coords: true, lines: true });
	//
	//     // Default attribute "vertices", available as "gl_Vertex" in
	//     // the vertex shader
	//     mesh.vertices = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]];
	//
	//     // Optional attribute "coords" enabled in constructor,
	//     // available as "gl_TexCoord" in the vertex shader
	//     mesh.coords = [[0, 0], [1, 0], [0, 1], [1, 1]];
	//
	//     // Custom attribute "weights", available as "weight" in the
	//     // vertex shader
	//     mesh.addVertexBuffer('weights', 'weight');
	//     mesh.weights = [1, 0, 0, 1];
	//
	//     // Default index buffer "triangles"
	//     mesh.triangles = [[0, 1, 2], [2, 1, 3]];
	//
	//     // Optional index buffer "lines" enabled in constructor
	//     mesh.lines = [[0, 1], [0, 2], [1, 3], [2, 3]];
	//
	//     // Upload provided data to GPU memory
	//     mesh.compile();
	// ### new GL.Indexer()
	//
	// Generates indices into a list of unique objects from a stream of objects
	// that may contain duplicates. This is useful for generating compact indexed
	// meshes from unindexed data.


	function Indexer() {
		this.unique = [];
		this.indices = [];
		this.map = {};
	}

	Indexer.prototype = {
		// ### .add(v)
		//
		// Adds the object `obj` to `unique` if it hasn't already been added. Returns
		// the index of `obj` in `unique`.
		add: function(obj) {
			var key = JSON.stringify(obj);
			if(!(key in this.map)) {
				this.map[key] = this.unique.length;
				this.unique.push(obj);
			}
			return this.map[key];
		}
	};

	// ### new GL.Buffer(target, type)
	//
	// Provides a simple method of uploading data to a GPU buffer. Example usage:
	//
	//     var vertices = new GL.Buffer(gl.ARRAY_BUFFER, Float32Array);
	//     var indices = new GL.Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
	//     vertices.data = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]];
	//     indices.data = [[0, 1, 2], [2, 1, 3]];
	//     vertices.compile();
	//     indices.compile();
	//


	function Buffer(target, type) {
		this.buffer = null;
		this.target = target;
		this.type = type;
		this.data = [];
	}

	Buffer.prototype = {
		// ### .compile(type)
		//
		// Upload the contents of `data` to the GPU in preparation for rendering. The
		// data must be a list of lists where each inner list has the same length. For
		// example, each element of data for vertex normals would be a list of length three.
		// This will remember the data length and element length for later use by shaders.
		// The type can be either `gl.STATIC_DRAW` or `gl.DYNAMIC_DRAW`, and defaults to
		// `gl.STATIC_DRAW`.
		//
		// This could have used `[].concat.apply([], this.data)` to flatten
		// the array but Google Chrome has a maximum number of arguments so the
		// concatenations are chunked to avoid that limit.
		compile: function(type) {
			var data = [];
			for(var i = 0, chunk = 10000; i < this.data.length; i += chunk) {
				data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));
			}
			var spacing = this.data.length ? data.length / this.data.length : 0;
			if(spacing != Math.round(spacing)) throw 'buffer elements not of consistent size, average size is ' + spacing;
			this.buffer = this.buffer || gl.createBuffer();
			this.buffer.length = data.length;
			this.buffer.spacing = spacing;
			gl.bindBuffer(this.target, this.buffer);
			gl.bufferData(this.target, new this.type(data), type || gl.STATIC_DRAW);
		}
	};

	// ### new GL.Mesh([options])
	//
	// Represents a collection of vertex buffers and index buffers. Each vertex
	// buffer maps to one attribute in GLSL and has a corresponding property set
	// on the Mesh instance. There is one vertex buffer by default: `vertices`,
	// which maps to `gl_Vertex`. The `coords`, `normals`, and `colors` vertex
	// buffers map to `gl_TexCoord`, `gl_Normal`, and `gl_Color` respectively,
	// and can be enabled by setting the corresponding options to true. There are
	// two index buffers, `triangles` and `lines`, which are used for rendering
	// `gl.TRIANGLES` and `gl.LINES`, respectively. Only `triangles` is enabled by
	// default, although `computeWireframe()` will add a normal buffer if it wasn't
	// initially enabled.


	function Mesh(options) {
		options = options || {};
		this.vertexBuffers = {};
		this.indexBuffers = {};
		this.addVertexBuffer('vertices', 'gl_Vertex');
		if(options.coords) this.addVertexBuffer('coords', 'gl_TexCoord');
		if(options.normals) this.addVertexBuffer('normals', 'gl_Normal');
		if(options.colors) this.addVertexBuffer('colors', 'gl_Color');
		if(!('triangles' in options) || options.triangles) this.addIndexBuffer('triangles');
		if(options.lines) this.addIndexBuffer('lines');
	}

	Mesh.prototype = {
		// ### .addVertexBuffer(name, attribute)
		//
		// Add a new vertex buffer with a list as a property called `name` on this object
		// and map it to the attribute called `attribute` in all shaders that draw this mesh.
		addVertexBuffer: function(name, attribute) {
			var buffer = this.vertexBuffers[attribute] = new Buffer(gl.ARRAY_BUFFER, Float32Array);
			buffer.name = name;
			this[name] = [];
		},

		// ### .addIndexBuffer(name)
		//
		// Add a new index buffer with a list as a property called `name` on this object.
		addIndexBuffer: function(name) {
			this.indexBuffers[name] = new Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
			this[name] = [];
		},

		// ### .compile()
		//
		// Upload all attached buffers to the GPU in preparation for rendering. This
		// doesn't need to be called every frame, only needs to be done when the data
		// changes.
		compile: function() {
			for(var attribute in this.vertexBuffers) {
				var buffer = this.vertexBuffers[attribute];
				buffer.data = this[buffer.name];
				buffer.compile();
			}

			for(var name in this.indexBuffers) {
				var buffer = this.indexBuffers[name];
				buffer.data = this[name];
				buffer.compile();
			}
		},

		// ### .transform(matrix)
		//
		// Transform all vertices by `matrix` and all normals by the inverse transpose
		// of `matrix`.
		transform: function(matrix) {
			this.vertices = this.vertices.map(function(v) {
				return matrix.transformPoint(Vector.fromArray(v)).toArray();
			});
			if(this.normals) {
				var invTrans = matrix.inverse().transpose();
				this.normals = this.normals.map(function(n) {
					return invTrans.transformVector(Vector.fromArray(n)).unit().toArray();
				});
			}
			this.compile();
			return this;
		},

		// ### .computeNormals()
		//
		// Computes a new normal for each vertex from the average normal of the
		// neighboring triangles. This means adjacent triangles must share vertices
		// for the resulting normals to be smooth.
		computeNormals: function() {
			if(!this.normals) this.addVertexBuffer('normals', 'gl_Normal');
			for(var i = 0; i < this.vertices.length; i++) {
				this.normals[i] = new Vector();
			}
			for(var i = 0; i < this.triangles.length; i++) {
				var t = this.triangles[i];
				var a = Vector.fromArray(this.vertices[t[0]]);
				var b = Vector.fromArray(this.vertices[t[1]]);
				var c = Vector.fromArray(this.vertices[t[2]]);
				var normal = b.subtract(a).cross(c.subtract(a)).unit();
				this.normals[t[0]] = this.normals[t[0]].add(normal);
				this.normals[t[1]] = this.normals[t[1]].add(normal);
				this.normals[t[2]] = this.normals[t[2]].add(normal);
			}
			for(var i = 0; i < this.vertices.length; i++) {
				this.normals[i] = this.normals[i].unit().toArray();
			}
			this.compile();
			return this;
		},

		// ### .computeWireframe()
		//
		// Populate the `lines` index buffer from the `triangles` index buffer.
		computeWireframe: function() {
			var indexer = new Indexer();
			for(var i = 0; i < this.triangles.length; i++) {
				var t = this.triangles[i];
				for(var j = 0; j < t.length; j++) {
					var a = t[j],
						b = t[(j + 1) % t.length];
					indexer.add([Math.min(a, b), Math.max(a, b)]);
				}
			}
			if(!this.lines) this.addIndexBuffer('lines');
			this.lines = indexer.unique;
			this.compile();
			return this;
		},

		// ### .getAABB()
		//
		// Computes the axis-aligned bounding box, which is an object whose `min` and
		// `max` properties contain the minimum and maximum coordinates of all vertices.
		getAABB: function() {
			var aabb = {
				min: new Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
			};
			aabb.max = aabb.min.negative();
			for(var i = 0; i < this.vertices.length; i++) {
				var v = Vector.fromArray(this.vertices[i]);
				aabb.min = Vector.min(aabb.min, v);
				aabb.max = Vector.max(aabb.max, v);
			}
			return aabb;
		},

		// ### .getBoundingSphere()
		//
		// Computes a sphere that contains all vertices (not necessarily the smallest
		// sphere). The returned object has two properties, `center` and `radius`.
		getBoundingSphere: function() {
			var aabb = this.getAABB();
			var sphere = {
				center: aabb.min.add(aabb.max).divide(2),
				radius: 0
			};
			for(var i = 0; i < this.vertices.length; i++) {
				sphere.radius = Math.max(sphere.radius, Vector.fromArray(this.vertices[i]).subtract(sphere.center).length());
			}
			return sphere;
		}
	};

	// ### GL.Mesh.plane([options])
	//
	// Generates a square 2x2 mesh the xy plane centered at the origin. The
	// `options` argument specifies options to pass to the mesh constructor.
	// Additional options include `detailX` and `detailY`, which set the tesselation
	// in x and y, and `detail`, which sets both `detailX` and `detailY` at once.
	// Two triangles are generated by default.
	// Example usage:
	//
	//     var mesh1 = GL.Mesh.plane();
	//     var mesh2 = GL.Mesh.plane({ detail: 5 });
	//     var mesh3 = GL.Mesh.plane({ detailX: 20, detailY: 40 });
	//
	Mesh.plane = function(options) {
		options = options || {};
		var mesh = new Mesh(options),
			detailX = options.detailX || options.detail || 1,
			detailY = options.detailY || options.detail || 1;

		for(var y = 0; y <= detailY; y++) {
			var t = y / detailY;
			for(var x = 0; x <= detailX; x++) {
				var s = x / detailX;
				mesh.vertices.push([2 * s - 1, 2 * t - 1, 0]);
				if(mesh.coords) mesh.coords.push([s, t]);
				if(mesh.normals) mesh.normals.push([0, 0, 1]);
				if(x < detailX && y < detailY) {
					var i = x + y * (detailX + 1);
					mesh.triangles.push([i, i + 1, i + detailX + 1]);
					mesh.triangles.push([i + detailX + 1, i + 1, i + detailX + 2]);
				}
			}
		}

		mesh.compile();
		return mesh;
	};

	var cubeData = [
		[0, 4, 2, 6, -1, 0, 0], // -x
		[1, 3, 5, 7, +1, 0, 0], // +x
		[0, 1, 4, 5, 0, -1, 0], // -y
		[2, 6, 3, 7, 0, +1, 0], // +y
		[0, 2, 1, 3, 0, 0, -1], // -z
		[4, 5, 6, 7, 0, 0, +1] // +z
		];

	function pickOctant(i) {
		return new Vector((i & 1) * 2 - 1, (i & 2) - 1, (i & 4) / 2 - 1);
	}

	// ### GL.Mesh.cube([options])
	//
	// Generates a 2x2x2 box centered at the origin. The `options` argument
	// specifies options to pass to the mesh constructor.
	Mesh.cube = function(options) {
		var mesh = new Mesh(options);

		for(var i = 0; i < cubeData.length; i++) {
			var data = cubeData[i],
				v = i * 4;
			for(var j = 0; j < 4; j++) {
				var d = data[j];
				mesh.vertices.push(pickOctant(d).toArray());
				if(mesh.coords) mesh.coords.push([j & 1, (j & 2) / 2]);
				if(mesh.normals) mesh.normals.push(data.slice(4, 7));
			}
			mesh.triangles.push([v, v + 1, v + 2]);
			mesh.triangles.push([v + 2, v + 1, v + 3]);
		}

		mesh.compile();
		return mesh;
	};

	// ### GL.Mesh.sphere([options])
	//
	// Generates a geodesic sphere of radius 1. The `options` argument specifies
	// options to pass to the mesh constructor in addition to the `detail` option,
	// which controls the tesselation level. The detail is `6` by default.
	// Example usage:
	//
	//     var mesh1 = GL.Mesh.sphere();
	//     var mesh2 = GL.Mesh.sphere({ detail: 2 });
	//
	Mesh.sphere = function(options) {
		function tri(a, b, c) {
			return flip ? [a, c, b] : [a, b, c];
		}

		function fix(x) {
			return x + (x - x * x) / 2;
		}
		options = options || {};
		var mesh = new Mesh(options);
		var indexer = new Indexer(),
			detail = options.detail || 6;

		for(var octant = 0; octant < 8; octant++) {
			var scale = pickOctant(octant);
			var flip = scale.x * scale.y * scale.z > 0;
			var data = [];
			for(var i = 0; i <= detail; i++) {
				// Generate a row of vertices on the surface of the sphere
				// using barycentric coordinates.
				for(var j = 0; i + j <= detail; j++) {
					var a = i / detail;
					var b = j / detail;
					var c = (detail - i - j) / detail;
					var vertex = {
						vertex: new Vector(fix(a), fix(b), fix(c)).unit().multiply(scale).toArray()
					};
					if(mesh.coords) vertex.coord = scale.y > 0 ? [1 - a, c] : [c, 1 - a];
					data.push(indexer.add(vertex));
				}

				// Generate triangles from this row and the previous row.
				if(i > 0) {
					for(var j = 0; i + j <= detail; j++) {
						var a = (i - 1) * (detail + 1) + ((i - 1) - (i - 1) * (i - 1)) / 2 + j;
						var b = i * (detail + 1) + (i - i * i) / 2 + j;
						mesh.triangles.push(tri(data[a], data[a + 1], data[b]));
						if(i + j < detail) {
							mesh.triangles.push(tri(data[b], data[a + 1], data[b + 1]));
						}
					}
				}
			}
		}

		// Reconstruct the geometry from the indexer.
		mesh.vertices = indexer.unique.map(function(v) {
			return v.vertex;
		});
		if(mesh.coords) mesh.coords = indexer.unique.map(function(v) {
			return v.coord;
		});
		if(mesh.normals) mesh.normals = mesh.vertices;
		mesh.compile();
		return mesh;
	};

	// ### GL.Mesh.load(json[, options])
	//
	// Creates a mesh from the JSON generated by the `convert/convert.py` script.
	// Example usage:
	//
	//     var data = {
	//       vertices: [[0, 0, 0], [1, 0, 0], [0, 1, 0]],
	//       triangles: [[0, 1, 2]]
	//     };
	//     var mesh = GL.Mesh.load(data);
	//
	Mesh.load = function(json, options) {
		options = options || {};
		if(!('coords' in options)) options.coords = !! json.coords;
		if(!('normals' in options)) options.normals = !! json.normals;
		if(!('colors' in options)) options.colors = !! json.colors;
		if(!('triangles' in options)) options.triangles = !! json.triangles;
		if(!('lines' in options)) options.lines = !! json.lines;
		var mesh = new Mesh(options);
		mesh.vertices = json.vertices;
		if(mesh.coords) mesh.coords = json.coords;
		if(mesh.normals) mesh.normals = json.normals;
		if(mesh.colors) mesh.colors = json.colors;
		if(mesh.triangles) mesh.triangles = json.triangles;
		if(mesh.lines) mesh.lines = json.lines;
		mesh.compile();
		return mesh;
	};

	// src/vector.js
	// Provides a simple 3D vector class. Vector operations can be done using member
	// functions, which return new vectors, or static functions, which reuse
	// existing vectors to avoid generating garbage.


	function Vector(x, y, z) {
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	}

	// ### Instance Methods
	// The methods `add()`, `subtract()`, `multiply()`, and `divide()` can all
	// take either a vector or a number as an argument.
	Vector.prototype = {
		negative: function() {
			return new Vector(-this.x, -this.y, -this.z);
		},
		add: function(v) {
			if(v instanceof Vector) return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
			else return new Vector(this.x + v, this.y + v, this.z + v);
		},
		subtract: function(v) {
			if(v instanceof Vector) return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
			else return new Vector(this.x - v, this.y - v, this.z - v);
		},
		multiply: function(v) {
			if(v instanceof Vector) return new Vector(this.x * v.x, this.y * v.y, this.z * v.z);
			else return new Vector(this.x * v, this.y * v, this.z * v);
		},
		divide: function(v) {
			if(v instanceof Vector) return new Vector(this.x / v.x, this.y / v.y, this.z / v.z);
			else return new Vector(this.x / v, this.y / v, this.z / v);
		},
		equals: function(v) {
			return this.x == v.x && this.y == v.y && this.z == v.z;
		},
		dot: function(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		},
		cross: function(v) {
			return new Vector(
			this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
		},
		length: function() {
			return Math.sqrt(this.dot(this));
		},
		unit: function() {
			return this.divide(this.length());
		},
		min: function() {
			return Math.min(Math.min(this.x, this.y), this.z);
		},
		max: function() {
			return Math.max(Math.max(this.x, this.y), this.z);
		},
		toAngles: function() {
			return {
				theta: Math.atan2(this.z, this.x),
				phi: Math.asin(this.y / this.length())
			};
		},
		toArray: function(n) {
			return [this.x, this.y, this.z].slice(0, n || 3);
		},
		clone: function() {
			return new Vector(this.x, this.y, this.z);
		},
		init: function(x, y, z) {
			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		}
	};

	// ### Static Methods
	// `Vector.randomDirection()` returns a vector with a length of 1 and a
	// statistically uniform direction. `Vector.lerp()` performs linear
	// interpolation between two vectors.
	Vector.negative = function(a, b) {
		b.x = -a.x;
		b.y = -a.y;
		b.z = -a.z;
		return b;
	};
	Vector.add = function(a, b, c) {
		if(b instanceof Vector) {
			c.x = a.x + b.x;
			c.y = a.y + b.y;
			c.z = a.z + b.z;
		} else {
			c.x = a.x + b;
			c.y = a.y + b;
			c.z = a.z + b;
		}
		return c;
	};
	Vector.subtract = function(a, b, c) {
		if(b instanceof Vector) {
			c.x = a.x - b.x;
			c.y = a.y - b.y;
			c.z = a.z - b.z;
		} else {
			c.x = a.x - b;
			c.y = a.y - b;
			c.z = a.z - b;
		}
		return c;
	};
	Vector.multiply = function(a, b, c) {
		if(b instanceof Vector) {
			c.x = a.x * b.x;
			c.y = a.y * b.y;
			c.z = a.z * b.z;
		} else {
			c.x = a.x * b;
			c.y = a.y * b;
			c.z = a.z * b;
		}
		return c;
	};
	Vector.divide = function(a, b, c) {
		if(b instanceof Vector) {
			c.x = a.x / b.x;
			c.y = a.y / b.y;
			c.z = a.z / b.z;
		} else {
			c.x = a.x / b;
			c.y = a.y / b;
			c.z = a.z / b;
		}
		return c;
	};
	Vector.cross = function(a, b, c) {
		c.x = a.y * b.z - a.z * b.y;
		c.y = a.z * b.x - a.x * b.z;
		c.z = a.x * b.y - a.y * b.x;
		return c;
	};
	Vector.unit = function(a, b) {
		var length = a.length();
		b.x = a.x / length;
		b.y = a.y / length;
		b.z = a.z / length;
		return b;
	};
	Vector.fromAngles = function(theta, phi) {
		return new Vector(Math.cos(theta) * Math.cos(phi), Math.sin(phi), Math.sin(theta) * Math.cos(phi));
	};
	Vector.randomDirection = function() {
		return Vector.fromAngles(Math.random() * Math.PI * 2, Math.asin(Math.random() * 2 - 1));
	};
	Vector.min = function(a, b) {
		return new Vector(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z));
	};
	Vector.max = function(a, b) {
		return new Vector(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z));
	};
	Vector.lerp = function(a, b, fraction) {
		return b.subtract(a).multiply(fraction).add(a);
	};
	Vector.fromArray = function(a) {
		return new Vector(a[0], a[1], a[2]);
	};

	// src/shader.js
	// Provides a convenient wrapper for WebGL shaders. A few uniforms and attributes,
	// prefixed with `gl_`, are automatically added to all shader sources to make
	// simple shaders easier to write.
	//
	// Example usage:
	//
	//     var shader = new GL.Shader('\
	//       void main() {\
	//         gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
	//       }\
	//     ', '\
	//       uniform vec4 color;\
	//       void main() {\
	//         gl_FragColor = color;\
	//       }\
	//     ');
	//
	//     shader.uniforms({
	//       color: [1, 0, 0, 1]
	//     }).draw(mesh);

	function regexMap(regex, text, callback) {
		var result;
		while((result = regex.exec(text)) !== null) {
			callback(result);
		}
	}

	// Non-standard names beginning with `gl_` must be mangled because they will
	// otherwise cause a compiler error.
	var LIGHTGL_PREFIX = 'LIGHTGL';

	// ### new GL.Shader(vertexSource, fragmentSource)
	//
	// Compiles a shader program using the provided vertex and fragment shaders.


	function Shader(vertexSource, fragmentSource) {
		// Allow passing in the id of an HTML script tag with the source


		function followScriptTagById(id) {
			var element = document.getElementById(id);
			return element ? element.text : id;
		}
		vertexSource = followScriptTagById(vertexSource);
		fragmentSource = followScriptTagById(fragmentSource);

		// Headers are prepended to the sources to provide some automatic functionality.
		var header = '\
    uniform mat3 gl_NormalMatrix;\
    uniform mat4 gl_ModelViewMatrix;\
    uniform mat4 gl_ProjectionMatrix;\
    uniform mat4 gl_ModelViewProjectionMatrix;\
    uniform mat4 gl_ModelViewMatrixInverse;\
    uniform mat4 gl_ProjectionMatrixInverse;\
    uniform mat4 gl_ModelViewProjectionMatrixInverse;\
  ';
		var vertexHeader = header + '\
    attribute vec4 gl_Vertex;\
    attribute vec4 gl_TexCoord;\
    attribute vec3 gl_Normal;\
    attribute vec4 gl_Color;\
    vec4 ftransform() {\
      return gl_ModelViewProjectionMatrix * gl_Vertex;\
    }\
  ';
		var fragmentHeader = '\
    precision highp float;\
  ' + header;

		// Check for the use of built-in matrices that require expensive matrix
		// multiplications to compute, and record these in `usedMatrices`.
		var source = vertexSource + fragmentSource;
		var usedMatrices = {};
		regexMap(/\b(gl_[^;]*)\b;/g, header, function(groups) {
			var name = groups[1];
			if(source.indexOf(name) != -1) {
				var capitalLetters = name.replace(/[a-z_]/g, '');
				usedMatrices[capitalLetters] = LIGHTGL_PREFIX + name;
			}
		});
		if(source.indexOf('ftransform') != -1) usedMatrices.MVPM = LIGHTGL_PREFIX + 'gl_ModelViewProjectionMatrix';
		this.usedMatrices = usedMatrices;

		// The `gl_` prefix must be substituted for something else to avoid compile
		// errors, since it's a reserved prefix. This prefixes all reserved names with
		// `_`. The header is inserted after any extensions, since those must come
		// first.


		function fix(header, source) {
			var replaced = {};
			var match = /^((\s*\/\/.*\n|\s*#extension.*\n)+)\^*$/.exec(source);
			source = match ? match[1] + header + source.substr(match[1].length) : header + source;
			regexMap(/\bgl_\w+\b/g, header, function(result) {
				if(!(result in replaced)) {
					source = source.replace(new RegExp('\\b' + result + '\\b', 'g'), LIGHTGL_PREFIX + result);
					replaced[result] = true;
				}
			});
			return source;
		}
		vertexSource = fix(vertexHeader, vertexSource);
		fragmentSource = fix(fragmentHeader, fragmentSource);

		// Compile and link errors are thrown as strings.


		function compileSource(type, source) {
			var shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				throw 'compile error: ' + gl.getShaderInfoLog(shader);
			}
			return shader;
		}
		this.program = gl.createProgram();
		gl.attachShader(this.program, compileSource(gl.VERTEX_SHADER, vertexSource));
		gl.attachShader(this.program, compileSource(gl.FRAGMENT_SHADER, fragmentSource));
		gl.linkProgram(this.program);
		if(!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
			throw 'link error: ' + gl.getProgramInfoLog(this.program);
		}
		this.attributes = {};
		this.uniformLocations = {};

		// Sampler uniforms need to be uploaded using `gl.uniform1i()` instead of `gl.uniform1f()`.
		// To do this automatically, we detect and remember all uniform samplers in the source code.
		var isSampler = {};
		regexMap(/uniform\s+sampler(1D|2D|3D|Cube)\s+(\w+)\s*;/g, vertexSource + fragmentSource, function(groups) {
			isSampler[groups[2]] = 1;
		});
		this.isSampler = isSampler;
	}

	function isArray(obj) {
		var str = Object.prototype.toString.call(obj);
		return str == '[object Array]' || str == '[object Float32Array]';
	}

	function isNumber(obj) {
		var str = Object.prototype.toString.call(obj);
		return str == '[object Number]' || str == '[object Boolean]';
	}

	Shader.prototype = {
		// ### .uniforms(uniforms)
		//
		// Set a uniform for each property of `uniforms`. The correct `gl.uniform*()` method is
		// inferred from the value types and from the stored uniform sampler flags.
		uniforms: function(uniforms) {
			gl.useProgram(this.program);

			for(var name in uniforms) {
				var location = this.uniformLocations[name] || gl.getUniformLocation(this.program, name);
				if(!location) continue;
				this.uniformLocations[name] = location;
				var value = uniforms[name];
				if(value instanceof Vector) {
					value = [value.x, value.y, value.z];
				} else if(value instanceof Matrix) {
					value = value.m;
				}
				if(isArray(value)) {
					switch(value.length) {
					case 1:
						gl.uniform1fv(location, new Float32Array(value));
						break;
					case 2:
						gl.uniform2fv(location, new Float32Array(value));
						break;
					case 3:
						gl.uniform3fv(location, new Float32Array(value));
						break;
					case 4:
						gl.uniform4fv(location, new Float32Array(value));
						break;
						// Matrices are automatically transposed, since WebGL uses column-major
						// indices instead of row-major indices.
					case 9:
						gl.uniformMatrix3fv(location, false, new Float32Array([
							value[0], value[3], value[6], value[1], value[4],
							value[7], value[2], value[5], value[8]]));
						break;
					case 16:
						gl.uniformMatrix4fv(location, false, new Float32Array([
							value[0], value[4], value[8], value[12],
							value[1], value[5], value[9], value[13],
							value[2], value[6], value[10], value[14],
							value[3], value[7], value[11], value[15]]));
						break;
					default:
						throw 'don\'t know how to load uniform "' + name + '" of length ' + value.length;
					}
				} else if(isNumber(value)) {
					(this.isSampler[name] ? gl.uniform1i : gl.uniform1f).call(gl, location, value);
				} else {
					throw 'attempted to set uniform "' + name + '" to invalid value ' + value;
				}
			}

			return this;
		},

		// ### .draw(mesh[, mode])
		//
		// Sets all uniform matrix attributes, binds all relevant buffers, and draws the
		// mesh geometry as indexed triangles or indexed lines. Set `mode` to `gl.LINES`
		// (and either add indices to `lines` or call `computeWireframe()`) to draw the
		// mesh in wireframe.
		draw: function(mesh, mode) {
			this.drawBuffers(
				mesh.vertexBuffers,
				mesh.indexBuffers[mode == gl.LINES ? 'lines' : 'triangles'],
				arguments.length < 2 ? gl.TRIANGLES : mode
			);
		},

		// ### .drawBuffers(vertexBuffers, indexBuffer, mode)
		//
		// Sets all uniform matrix attributes, binds all relevant buffers, and draws the
		// indexed mesh geometry. The `vertexBuffers` argument is a map from attribute
		// names to `Buffer` objects of type `gl.ARRAY_BUFFER`, `indexBuffer` is a `Buffer`
		// object of type `gl.ELEMENT_ARRAY_BUFFER`, and `mode` is a WebGL primitive mode
		// like `gl.TRIANGLES` or `gl.LINES`. This method automatically creates and caches
		// vertex attribute pointers for attributes as needed.
		drawBuffers: function(vertexBuffers, indexBuffer, mode) {
			// Only construct up the built-in matrices we need for this shader.
			var used = this.usedMatrices;
			var MVM = gl.modelviewMatrix;
			var PM = gl.projectionMatrix;
			var MVMI = (used.MVMI || used.NM) ? MVM.inverse() : null;
			var PMI = (used.PMI) ? PM.inverse() : null;
			var MVPM = (used.MVPM || used.MVPMI) ? PM.multiply(MVM) : null;
			var matrices = {};
			if(used.MVM) matrices[used.MVM] = MVM;
			if(used.MVMI) matrices[used.MVMI] = MVMI;
			if(used.PM) matrices[used.PM] = PM;
			if(used.PMI) matrices[used.PMI] = PMI;
			if(used.MVPM) matrices[used.MVPM] = MVPM;
			if(used.MVPMI) matrices[used.MVPMI] = MVPM.inverse();
			if(used.NM) {
				var m = MVMI.m;
				matrices[used.NM] = [m[0], m[4], m[8], m[1], m[5], m[9], m[2], m[6], m[10]];
			}
			this.uniforms(matrices);

			// Create and enable attribute pointers as necessary.
			var length = 0;
			for(var attribute in vertexBuffers) {
				var buffer = vertexBuffers[attribute];
				var location = this.attributes[attribute] ||
							gl.getAttribLocation(
								this.program,
								attribute.replace(/^(gl_.*)$/, LIGHTGL_PREFIX + '$1')
							);
				if(location == -1 || !buffer.buffer)
					continue;
				this.attributes[attribute] = location;
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
				gl.enableVertexAttribArray(location);
				gl.vertexAttribPointer(location, buffer.buffer.spacing, gl.FLOAT, false, 0, 0);
				length = buffer.buffer.length / buffer.buffer.spacing;
			}

			// Disable unused attribute pointers.
			for(var attribute in this.attributes) {
				if(!(attribute in vertexBuffers)) {
					gl.disableVertexAttribArray(this.attributes[attribute]);
				}
			}

			// Draw the geometry.
			if(length && (!indexBuffer || indexBuffer.buffer)) {
				if(indexBuffer) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
					gl.drawElements(mode, indexBuffer.buffer.length, gl.UNSIGNED_SHORT, 0);
				} else {
					gl.drawArrays(mode, 0, length);
				}
			}

			return this;
		}
	};

	// ### GL.Shader.fromURL(vsURL, fsURL)
	//
	// Compiles a shader program using the provided vertex and fragment
	// shaders. The shaders are loaded synchronously from the given URLs.
	//
	Shader.fromURL = function(vsURL, fsURL) {

		var XMLHttpRequestGet = function(uri) {
				var mHttpReq = new XMLHttpRequest();
				mHttpReq.open("GET", uri, false);
				mHttpReq.send(null);
				if(mHttpReq.status !== 200) {
					throw 'could not load ' + uri;
				}
				return mHttpReq.responseText;
			};

		var vsSource = XMLHttpRequestGet(vsURL);
		var fsSource = XMLHttpRequestGet(fsURL);

		return new Shader(vsSource, fsSource);
	};

	Shader.from = function(vsURLorID, fsURLorID) {
		try {
			return new Shader(vsURLorID, fsURLorID);
		} catch(e) {
			return Shader.fromURL(vsURLorID, fsURLorID);
		}
	};

	// src/main.js
	// The internal `gl` variable holds the current WebGL context.
	var gl;

	var GL = {
		// ### Initialization
		//
		// `GL.create()` creates a new WebGL context and augments it with
		// more methods. Uses the HTML canvas given in 'options' or creates
		// a new one if necessary. The alpha channel is disabled by default
		// because it usually causes unintended transparencies in the
		// canvas.
		create: function(options) {
			options = options || {};
			var canvas = options.canvas;
			if(!canvas) {
				canvas = document.createElement('canvas');
				canvas.width = options.width || 800;
				canvas.height = options.height || 600;
			}
			if(!('alpha' in options)) options.alpha = false;
			try {
				gl = canvas.getContext('webgl', options);
			} catch(e) {}
			try {
				gl = gl || canvas.getContext('experimental-webgl', options);
			} catch(e) {}
			if(!gl) throw 'WebGL not supported';
			addMatrixStack();
			addImmediateMode();
			addEventListeners();
			addOtherMethods();
			return gl;
		},

		// `GL.keys` contains a mapping of key codes to booleans indicating whether
		// that key is currently pressed.
		keys: {},

		// Export all external classes.
		Matrix: Matrix,
		Indexer: Indexer,
		Buffer: Buffer,
		Mesh: Mesh,
		HitTest: HitTest,
		Raytracer: Raytracer,
		Shader: Shader,
		Texture: Texture,
		Vector: Vector
	};

	// ### Matrix stack
	//
	// Implement the OpenGL modelview and projection matrix stacks, along with some
	// other useful GLU matrix functions.

	function addMatrixStack() {
		gl.MODELVIEW = ENUM | 1;
		gl.PROJECTION = ENUM | 2;
		var tempMatrix = new Matrix();
		var resultMatrix = new Matrix();
		gl.modelviewMatrix = new Matrix();
		gl.projectionMatrix = new Matrix();
		var modelviewStack = [];
		var projectionStack = [];
		var matrix, stack;
		gl.matrixMode = function(mode) {
			switch(mode) {
			case gl.MODELVIEW:
				matrix = 'modelviewMatrix';
				stack = modelviewStack;
				break;
			case gl.PROJECTION:
				matrix = 'projectionMatrix';
				stack = projectionStack;
				break;
			default:
				throw 'invalid matrix mode ' + mode;
			}
		};
		gl.loadIdentity = function() {
			Matrix.identity(gl[matrix]);
		};
		gl.loadMatrix = function(m) {
			var from = m.m,
				to = gl[matrix].m;
			for(var i = 0; i < 16; i++) {
				to[i] = from[i];
			}
		};
		gl.multMatrix = function(m) {
			gl.loadMatrix(Matrix.multiply(gl[matrix], m, resultMatrix));
		};
		gl.perspective = function(fov, aspect, near, far) {
			gl.multMatrix(Matrix.perspective(fov, aspect, near, far, tempMatrix));
		};
		gl.frustum = function(l, r, b, t, n, f) {
			gl.multMatrix(Matrix.frustum(l, r, b, t, n, f, tempMatrix));
		};
		gl.ortho = function(l, r, b, t, n, f) {
			gl.multMatrix(Matrix.ortho(l, r, b, t, n, f, tempMatrix));
		};
		gl.scale = function(x, y, z) {
			gl.multMatrix(Matrix.scale(x, y, z, tempMatrix));
		};
		gl.translate = function(x, y, z) {
			gl.multMatrix(Matrix.translate(x, y, z, tempMatrix));
		};
		gl.rotate = function(a, x, y, z) {
			gl.multMatrix(Matrix.rotate(a, x, y, z, tempMatrix));
		};
		gl.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz) {
			gl.multMatrix(Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz, tempMatrix));
		};
		gl.pushMatrix = function() {
			stack.push(Array.prototype.slice.call(gl[matrix].m));
		};
		gl.popMatrix = function() {
			var m = stack.pop();
			gl[matrix].m = hasFloat32Array ? new Float32Array(m) : m;
		};
		gl.project = function(objX, objY, objZ, modelview, projection, viewport) {
			modelview = modelview || gl.modelviewMatrix;
			projection = projection || gl.projectionMatrix;
			viewport = viewport || gl.getParameter(gl.VIEWPORT);
			var point = projection.transformPoint(modelview.transformPoint(new Vector(objX, objY, objZ)));
			return new Vector(
			viewport[0] + viewport[2] * (point.x * 0.5 + 0.5), viewport[1] + viewport[3] * (point.y * 0.5 + 0.5), point.z * 0.5 + 0.5);
		};
		gl.unProject = function(winX, winY, winZ, modelview, projection, viewport) {
			modelview = modelview || gl.modelviewMatrix;
			projection = projection || gl.projectionMatrix;
			viewport = viewport || gl.getParameter(gl.VIEWPORT);
			var point = new Vector(
			(winX - viewport[0]) / viewport[2] * 2 - 1, (winY - viewport[1]) / viewport[3] * 2 - 1, winZ * 2 - 1);
			return Matrix.inverse(Matrix.multiply(projection, modelview, tempMatrix), resultMatrix).transformPoint(point);
		};
		gl.matrixMode(gl.MODELVIEW);
	}

	// ### Immediate mode
	//
	// Provide an implementation of OpenGL's deprecated immediate mode. This is
	// depricated for a reason: constantly re-specifying the geometry is a bad
	// idea for performance. You should use a `GL.Mesh` instead, which specifies
	// the geometry once and caches it on the graphics card. Still, nothing
	// beats a quick `gl.begin(gl.POINTS); gl.vertex(1, 2, 3); gl.end();` for
	// debugging. This intentionally doesn't implement fixed-function lighting
	// because it's only meant for quick debugging tasks.

	function addImmediateMode() {
		var immediateMode = {
			mesh: new Mesh({
				coords: true,
				colors: true,
				triangles: false
			}),
			mode: -1,
			coord: [0, 0, 0, 0],
			color: [1, 1, 1, 1],
			pointSize: 1,
			shader: new Shader('\
      uniform float pointSize;\
      varying vec4 color;\
      varying vec4 coord;\
      void main() {\
        color = gl_Color;\
        coord = gl_TexCoord;\
        gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
        gl_PointSize = pointSize;\
      }\
    ', '\
      uniform sampler2D texture;\
      uniform float pointSize;\
      uniform bool useTexture;\
      varying vec4 color;\
      varying vec4 coord;\
      void main() {\
        gl_FragColor = color;\
        if (useTexture) gl_FragColor *= texture2D(texture, coord.xy);\
      }\
    ')
		};
		gl.pointSize = function(pointSize) {
			immediateMode.shader.uniforms({
				pointSize: pointSize
			});
		};
		gl.begin = function(mode) {
			if(immediateMode.mode != -1) throw 'mismatched gl.begin() and gl.end() calls';
			immediateMode.mode = mode;
			immediateMode.mesh.colors = [];
			immediateMode.mesh.coords = [];
			immediateMode.mesh.vertices = [];
		};
		gl.color = function(r, g, b, a) {
			immediateMode.color = (arguments.length == 1) ? r.toArray().concat(1) : [r, g, b, a || 1];
		};
		gl.texCoord = function(s, t) {
			immediateMode.coord = (arguments.length == 1) ? s.toArray(2) : [s, t];
		};
		gl.vertex = function(x, y, z) {
			immediateMode.mesh.colors.push(immediateMode.color);
			immediateMode.mesh.coords.push(immediateMode.coord);
			immediateMode.mesh.vertices.push(arguments.length == 1 ? x.toArray() : [x, y, z]);
		};
		gl.end = function() {
			if(immediateMode.mode == -1) throw 'mismatched gl.begin() and gl.end() calls';
			immediateMode.mesh.compile();
			immediateMode.shader.uniforms({
				useTexture: !! gl.getParameter(gl.TEXTURE_BINDING_2D)
			}).draw(immediateMode.mesh, immediateMode.mode);
			immediateMode.mode = -1;
		};
	}

	// ### Improved mouse events
	//
	// This adds event listeners on the `gl.canvas` element that call
	// `gl.onmousedown()`, `gl.onmousemove()`, and `gl.onmouseup()` with an
	// augmented event object. The event object also has the properties `x`, `y`,
	// `deltaX`, `deltaY`, and `dragging`.


	function addEventListeners() {

		var context = gl,
			oldX = 0,
			oldY = 0,
			buttons = {},
			hasOld = false;
		var has = Object.prototype.hasOwnProperty;

		function isDragging() {
			for(var b in buttons) {
				if(has.call(buttons, b) && buttons[b]) return true;
			}
			return false;
		}

		function augment(original) {
			// Make a copy of original, a native `MouseEvent`, so we can overwrite
			// WebKit's non-standard read-only `x` and `y` properties (which are just
			// duplicates of `pageX` and `pageY`). We can't just use
			// `Object.create(original)` because some `MouseEvent` functions must be
			// called in the context of the original event object.
			var e = {};
			for(var name in original) {
				if(typeof original[name] == 'function') {
					e[name] = (function(callback) {
						return function() {
							callback.apply(original, arguments);
						};
					})(original[name]);
				} else {
					e[name] = original[name];
				}
			}
			e.original = original;
			e.x = e.pageX;
			e.y = e.pageY;
			for(var obj = gl.canvas; obj; obj = obj.offsetParent) {
				e.x -= obj.offsetLeft;
				e.y -= obj.offsetTop;
			}
			if(hasOld) {
				e.deltaX = e.x - oldX;
				e.deltaY = e.y - oldY;
			} else {
				e.deltaX = 0;
				e.deltaY = 0;
				hasOld = true;
			}
			oldX = e.x;
			oldY = e.y;
			e.dragging = isDragging();
			e.preventDefault = function() {
				e.original.preventDefault();
			};
			e.stopPropagation = function() {
				e.original.stopPropagation();
			};
			return e;
		}

		function augmentTouchEvent(original) {
			var e = {};
			for(var name in original) {
				if(typeof original[name] == 'function') {
					e[name] = (function(callback) {
						return function() {
							callback.apply(original, arguments);
						};
					})(original[name]);
				} else {
					e[name] = original[name];
				}
			}
			e.original = original;

			if(e.targetTouches.length > 0) {
				var touch = e.targetTouches[0];
				e.x = touch.pageX;
				e.y = touch.pageY;

				for(var obj = gl.canvas; obj; obj = obj.offsetParent) {
					e.x -= obj.offsetLeft;
					e.y -= obj.offsetTop;
				}
				if(hasOld) {
					e.deltaX = e.x - oldX;
					e.deltaY = e.y - oldY;
				} else {
					e.deltaX = 0;
					e.deltaY = 0;
					hasOld = true;
				}
				oldX = e.x;
				oldY = e.y;
				e.dragging = true;
			}

			e.preventDefault = function() {
				e.original.preventDefault();
			};
			e.stopPropagation = function() {
				e.original.stopPropagation();
			};
			return e;
		}

		function mousedown(e) {
			gl = context;
			if(!isDragging()) {
				// Expand the event handlers to the document to handle dragging off canvas.
				on(document, 'mousemove', mousemove);
				on(document, 'mouseup', mouseup);
				off(gl.canvas, 'mousemove', mousemove);
				off(gl.canvas, 'mouseup', mouseup);
			}
			buttons[e.which] = true;
			e = augment(e);
			if(gl.onmousedown) gl.onmousedown(e);
			e.preventDefault();
		}

		function mousemove(e) {
			gl = context;
			e = augment(e);
			if(gl.onmousemove) gl.onmousemove(e);
			e.preventDefault();
		}

		function mouseup(e) {
			gl = context;
			buttons[e.which] = false;
			if(!isDragging()) {
				// Shrink the event handlers back to the canvas when dragging ends.
				off(document, 'mousemove', mousemove);
				off(document, 'mouseup', mouseup);
				on(gl.canvas, 'mousemove', mousemove);
				on(gl.canvas, 'mouseup', mouseup);
			}
			e = augment(e);
			if(gl.onmouseup) gl.onmouseup(e);
			e.preventDefault();
		}

		function mousewheel(e) {
			gl = context;
			e = augment(e);
			if(gl.onmousewheel) gl.onmousewheel(e);
			e.preventDefault();
		}

		function touchstart(e) {
			resetAll();
			// Expand the event handlers to the document to handle dragging off canvas.
			on(document, 'touchmove', touchmove);
			on(document, 'touchend', touchend);
			off(gl.canvas, 'touchmove', touchmove);
			off(gl.canvas, 'touchend', touchend);
			gl = context;
			e = augmentTouchEvent(e);
			if(gl.ontouchstart) gl.ontouchstart(e);
			e.preventDefault();
		}

		function touchmove(e) {
			gl = context;
			if(e.targetTouches.length === 0) {
				touchend(e);
			}
			e = augmentTouchEvent(e);
			if(gl.ontouchmove) gl.ontouchmove(e);
			e.preventDefault();
		}

		function touchend(e) {
			// Shrink the event handlers back to the canvas when dragging ends.
			off(document, 'touchmove', touchmove);
			off(document, 'touchend', touchend);
			on(gl.canvas, 'touchmove', touchmove);
			on(gl.canvas, 'touchend', touchend);
			gl = context;
			e = augmentTouchEvent(e);
			if(gl.ontouchend) gl.ontouchend(e);
			e.preventDefault();
		}

		function reset() {
			hasOld = false;
		}

		function resetAll() {
			buttons = {};
			hasOld = false;
		}

		// We can keep mouse and touch events enabled at the same time,
		// because Google Chrome will apparently never fire both of them.
		on(gl.canvas, 'mousedown', mousedown);
		on(gl.canvas, 'mousemove', mousemove);
		on(gl.canvas, 'mouseup', mouseup);
		on(gl.canvas, 'mousewheel', mousewheel);
		on(gl.canvas, 'DOMMouseScroll', mousewheel);
		on(gl.canvas, 'mouseover', reset);
		on(gl.canvas, 'mouseout', reset);
		on(gl.canvas, 'touchstart', touchstart);
		on(gl.canvas, 'touchmove', touchmove);
		on(gl.canvas, 'touchend', touchend);
		on(document, 'contextmenu', resetAll);
	}

	// ### Automatic keyboard state
	//
	// The current keyboard state is stored in `GL.keys`, a map of integer key
	// codes to booleans indicating whether that key is currently pressed. Certain
	// keys also have named identifiers that can be used directly, such as
	// `GL.keys.SPACE`. Values in `GL.keys` are initially undefined until that
	// key is pressed for the first time. If you need a boolean value, you can
	// cast the value to boolean by applying the not operator twice (as in
	// `!!GL.keys.SPACE`).

	function mapKeyCode(code) {
		var named = {
			8: 'BACKSPACE',
			9: 'TAB',
			13: 'ENTER',
			16: 'SHIFT',
			27: 'ESCAPE',
			32: 'SPACE',
			37: 'LEFT',
			38: 'UP',
			39: 'RIGHT',
			40: 'DOWN'
		};
		return named[code] || (code >= 65 && code <= 90 ? String.fromCharCode(code) : null);
	}

	function on(element, name, callback) {
		element.addEventListener(name, callback);
	}

	function off(element, name, callback) {
		element.removeEventListener(name, callback);
	}

	on(document, 'keydown', function(e) {
		if(!e.altKey && !e.ctrlKey && !e.metaKey) {
			var key = mapKeyCode(e.keyCode);
			if(key) GL.keys[key] = true;
			GL.keys[e.keyCode] = true;
		}
	});

	on(document, 'keyup', function(e) {
		if(!e.altKey && !e.ctrlKey && !e.metaKey) {
			var key = mapKeyCode(e.keyCode);
			if(key) GL.keys[key] = false;
			GL.keys[e.keyCode] = false;
		}
	});

	function addOtherMethods() {
		// ### Multiple contexts
		//
		// When using multiple contexts in one web page, `gl.makeCurrent()` must be
		// called before issuing commands to a different context.
		(function(context) {
			gl.makeCurrent = function() {
				gl = context;
			};
		})(gl);

		// ### Animation
		//
		// Call `gl.animate()` to provide an animation loop that repeatedly calls
		// `gl.onupdate()` and `gl.ondraw()`.
		gl.animate = function() {
			var post = window.requestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				function(callback) {
					setTimeout(callback, 1000 / 60);
				};
			var time = new Date().getTime();
			var context = gl;

			function update() {
				gl = context;
				var now = new Date().getTime();
				if(gl.onupdate) gl.onupdate((now - time) / 1000);
				if(gl.ondraw) gl.ondraw();
				post(update);
				time = now;
			}
			update();
		};

		// ### Fullscreen
		//
		// Provide an easy way to get a fullscreen app running, including an
		// automatic 3D perspective projection matrix by default. This should be
		// called once.
		//
		// Just fullscreen, no automatic camera:
		//
		//     gl.fullscreen({ camera: false });
		//
		// Adjusting field of view, near plane distance, and far plane distance:
		//
		//     gl.fullscreen({ fov: 45, near: 0.1, far: 1000 });
		//
		// Adding padding from the edge of the window:
		//
		//     gl.fullscreen({ paddingLeft: 250, paddingBottom: 60 });
		//
		gl.fullscreen = function(options) {
			options = options || {};
			var top = options.paddingTop || 0;
			var left = options.paddingLeft || 0;
			var right = options.paddingRight || 0;
			var bottom = options.paddingBottom || 0;
			if(!document.body) {
				throw 'document.body doesn\'t exist yet (call gl.fullscreen() from ' + 'window.onload() or from inside the <body> tag)';
			}
			document.body.appendChild(gl.canvas);
			document.body.style.overflow = 'hidden';
			gl.canvas.style.position = 'absolute';
			gl.canvas.style.left = left + 'px';
			gl.canvas.style.top = top + 'px';

			function resize() {
				gl.canvas.width = window.innerWidth - left - right;
				gl.canvas.height = window.innerHeight - top - bottom;
				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
				if(options.camera || !('camera' in options)) {
					gl.matrixMode(gl.PROJECTION);
					gl.loadIdentity();
					gl.perspective(options.fov || 45, gl.canvas.width / gl.canvas.height, options.near || 0.1, options.far || 1000);
					gl.matrixMode(gl.MODELVIEW);
				}
				if(gl.onresize) gl.onresize();
				if(gl.ondraw) gl.ondraw();
			}
			on(window, 'resize', resize);
			resize();
		};
	}

	// A value to bitwise-or with new enums to make them distinguishable from the
	// standard WebGL enums.
	var ENUM = 0x12340000;

	// src/matrix.js
	// Represents a 4x4 matrix stored in row-major order that uses Float32Arrays
	// when available. Matrix operations can either be done using convenient
	// methods that return a new matrix for the result or optimized methods
	// that store the result in an existing matrix to avoid generating garbage.
	var hasFloat32Array = (typeof Float32Array != 'undefined');

	// ### new GL.Matrix([elements])
	//
	// This constructor takes 16 arguments in row-major order, which can be passed
	// individually, as a list, or even as four lists, one for each row. If the
	// arguments are omitted then the identity matrix is constructed instead.


	function Matrix() {
		var m = Array.prototype.concat.apply([], arguments);
		if(!m.length) {
			m = [
			1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		}
		this.m = hasFloat32Array ? new Float32Array(m) : m;
	}

	Matrix.prototype = {
		// ### .inverse()
		//
		// Returns the matrix that when multiplied with this matrix results in the
		// identity matrix.
		inverse: function() {
			return Matrix.inverse(this, new Matrix());
		},

		// ### .transpose()
		//
		// Returns this matrix, exchanging columns for rows.
		transpose: function() {
			return Matrix.transpose(this, new Matrix());
		},

		// ### .multiply(matrix)
		//
		// Returns the concatenation of the transforms for this matrix and `matrix`.
		// This emulates the OpenGL function `glMultMatrix()`.
		multiply: function(matrix) {
			return Matrix.multiply(this, matrix, new Matrix());
		},

		// ### .transformPoint(point)
		//
		// Transforms the vector as a point with a w coordinate of 1. This
		// means translations will have an effect, for example.
		transformPoint: function(v) {
			var m = this.m;
			return new Vector(
					m[0] * v.x + m[1] * v.y + m[2] * v.z + m[3],
					m[4] * v.x + m[5] * v.y + m[6] * v.z + m[7],
					m[8] * v.x + m[9] * v.y + m[10] * v.z + m[11]
				).divide(m[12] * v.x + m[13] * v.y + m[14] * v.z + m[15]);
		},

		// ### .transformPoint(vector)
		//
		// Transforms the vector as a vector with a w coordinate of 0. This
		// means translations will have no effect, for example.
		transformVector: function(v) {
			var m = this.m;
			return new Vector(
					m[0] * v.x + m[1] * v.y + m[2] * v.z,
					m[4] * v.x + m[5] * v.y + m[6] * v.z,
					m[8] * v.x + m[9] * v.y + m[10] * v.z
				);
		}
	};

	// ### GL.Matrix.inverse(matrix[, result])
	//
	// Returns the matrix that when multiplied with `matrix` results in the
	// identity matrix. You can optionally pass an existing matrix in `result`
	// to avoid allocating a new matrix. This implementation is from the Mesa
	// OpenGL function `__gluInvertMatrixd()` found in `project.c`.
	Matrix.inverse = function(matrix, result) {
		result = result || new Matrix();
		var m = matrix.m,
			r = result.m;

		r[0] = m[5] * m[10] * m[15] - m[5] * m[14] * m[11] - m[6] * m[9] * m[15] + m[6] * m[13] * m[11] + m[7] * m[9] * m[14] - m[7] * m[13] * m[10];
		r[1] = -m[1] * m[10] * m[15] + m[1] * m[14] * m[11] + m[2] * m[9] * m[15] - m[2] * m[13] * m[11] - m[3] * m[9] * m[14] + m[3] * m[13] * m[10];
		r[2] = m[1] * m[6] * m[15] - m[1] * m[14] * m[7] - m[2] * m[5] * m[15] + m[2] * m[13] * m[7] + m[3] * m[5] * m[14] - m[3] * m[13] * m[6];
		r[3] = -m[1] * m[6] * m[11] + m[1] * m[10] * m[7] + m[2] * m[5] * m[11] - m[2] * m[9] * m[7] - m[3] * m[5] * m[10] + m[3] * m[9] * m[6];

		r[4] = -m[4] * m[10] * m[15] + m[4] * m[14] * m[11] + m[6] * m[8] * m[15] - m[6] * m[12] * m[11] - m[7] * m[8] * m[14] + m[7] * m[12] * m[10];
		r[5] = m[0] * m[10] * m[15] - m[0] * m[14] * m[11] - m[2] * m[8] * m[15] + m[2] * m[12] * m[11] + m[3] * m[8] * m[14] - m[3] * m[12] * m[10];
		r[6] = -m[0] * m[6] * m[15] + m[0] * m[14] * m[7] + m[2] * m[4] * m[15] - m[2] * m[12] * m[7] - m[3] * m[4] * m[14] + m[3] * m[12] * m[6];
		r[7] = m[0] * m[6] * m[11] - m[0] * m[10] * m[7] - m[2] * m[4] * m[11] + m[2] * m[8] * m[7] + m[3] * m[4] * m[10] - m[3] * m[8] * m[6];

		r[8] = m[4] * m[9] * m[15] - m[4] * m[13] * m[11] - m[5] * m[8] * m[15] + m[5] * m[12] * m[11] + m[7] * m[8] * m[13] - m[7] * m[12] * m[9];
		r[9] = -m[0] * m[9] * m[15] + m[0] * m[13] * m[11] + m[1] * m[8] * m[15] - m[1] * m[12] * m[11] - m[3] * m[8] * m[13] + m[3] * m[12] * m[9];
		r[10] = m[0] * m[5] * m[15] - m[0] * m[13] * m[7] - m[1] * m[4] * m[15] + m[1] * m[12] * m[7] + m[3] * m[4] * m[13] - m[3] * m[12] * m[5];
		r[11] = -m[0] * m[5] * m[11] + m[0] * m[9] * m[7] + m[1] * m[4] * m[11] - m[1] * m[8] * m[7] - m[3] * m[4] * m[9] + m[3] * m[8] * m[5];

		r[12] = -m[4] * m[9] * m[14] + m[4] * m[13] * m[10] + m[5] * m[8] * m[14] - m[5] * m[12] * m[10] - m[6] * m[8] * m[13] + m[6] * m[12] * m[9];
		r[13] = m[0] * m[9] * m[14] - m[0] * m[13] * m[10] - m[1] * m[8] * m[14] + m[1] * m[12] * m[10] + m[2] * m[8] * m[13] - m[2] * m[12] * m[9];
		r[14] = -m[0] * m[5] * m[14] + m[0] * m[13] * m[6] + m[1] * m[4] * m[14] - m[1] * m[12] * m[6] - m[2] * m[4] * m[13] + m[2] * m[12] * m[5];
		r[15] = m[0] * m[5] * m[10] - m[0] * m[9] * m[6] - m[1] * m[4] * m[10] + m[1] * m[8] * m[6] + m[2] * m[4] * m[9] - m[2] * m[8] * m[5];

		var det = m[0] * r[0] + m[1] * r[4] + m[2] * r[8] + m[3] * r[12];
		for(var i = 0; i < 16; i++) r[i] /= det;
		return result;
	};

	// ### GL.Matrix.transpose(matrix[, result])
	//
	// Returns `matrix`, exchanging columns for rows. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix.
	Matrix.transpose = function(matrix, result) {
		result = result || new Matrix();
		var m = matrix.m,
			r = result.m;
		r[0] = m[0];
		r[1] = m[4];
		r[2] = m[8];
		r[3] = m[12];
		r[4] = m[1];
		r[5] = m[5];
		r[6] = m[9];
		r[7] = m[13];
		r[8] = m[2];
		r[9] = m[6];
		r[10] = m[10];
		r[11] = m[14];
		r[12] = m[3];
		r[13] = m[7];
		r[14] = m[11];
		r[15] = m[15];
		return result;
	};

	// ### GL.Matrix.multiply(left, right[, result])
	//
	// Returns the concatenation of the transforms for `left` and `right`. You can
	// optionally pass an existing matrix in `result` to avoid allocating a new
	// matrix. This emulates the OpenGL function `glMultMatrix()`.
	Matrix.multiply = function(left, right, result) {
		result = result || new Matrix();
		var a = left.m,
			b = right.m,
			r = result.m;

		r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
		r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
		r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
		r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

		r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
		r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
		r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
		r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

		r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
		r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
		r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
		r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

		r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
		r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
		r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
		r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];

		return result;
	};

	// ### GL.Matrix.identity([result])
	//
	// Returns an identity matrix. You can optionally pass an existing matrix in
	// `result` to avoid allocating a new matrix. This emulates the OpenGL function
	// `glLoadIdentity()`.
	Matrix.identity = function(result) {
		result = result || new Matrix();
		var m = result.m;
		m[0] = m[5] = m[10] = m[15] = 1;
		m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
		return result;
	};

	// ### GL.Matrix.perspective(fov, aspect, near, far[, result])
	//
	// Returns a perspective transform matrix, which makes far away objects appear
	// smaller than nearby objects. The `aspect` argument should be the width
	// divided by the height of your viewport and `fov` is the top-to-bottom angle
	// of the field of view in degrees. You can optionally pass an existing matrix
	// in `result` to avoid allocating a new matrix. This emulates the OpenGL
	// function `gluPerspective()`.
	Matrix.perspective = function(fov, aspect, near, far, result) {
		var y = Math.tan(fov * Math.PI / 360) * near;
		var x = y * aspect;
		return Matrix.frustum(-x, x, -y, y, near, far, result);
	};

	// ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])
	//
	// Sets up a viewing frustum, which is shaped like a truncated pyramid with the
	// camera where the point of the pyramid would be. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix. This emulates
	// the OpenGL function `glFrustum()`.
	Matrix.frustum = function(l, r, b, t, n, f, result) {
		result = result || new Matrix();
		var m = result.m;

		m[0] = 2 * n / (r - l);
		m[1] = 0;
		m[2] = (r + l) / (r - l);
		m[3] = 0;

		m[4] = 0;
		m[5] = 2 * n / (t - b);
		m[6] = (t + b) / (t - b);
		m[7] = 0;

		m[8] = 0;
		m[9] = 0;
		m[10] = -(f + n) / (f - n);
		m[11] = -2 * f * n / (f - n);

		m[12] = 0;
		m[13] = 0;
		m[14] = -1;
		m[15] = 0;

		return result;
	};

	// ### GL.Matrix.ortho(left, right, bottom, top, near, far[, result])
	//
	// Returns an orthographic projection, in which objects are the same size no
	// matter how far away or nearby they are. You can optionally pass an existing
	// matrix in `result` to avoid allocating a new matrix. This emulates the OpenGL
	// function `glOrtho()`.
	Matrix.ortho = function(l, r, b, t, n, f, result) {
		result = result || new Matrix();
		var m = result.m;

		m[0] = 2 / (r - l);
		m[1] = 0;
		m[2] = 0;
		m[3] = -(r + l) / (r - l);

		m[4] = 0;
		m[5] = 2 / (t - b);
		m[6] = 0;
		m[7] = -(t + b) / (t - b);

		m[8] = 0;
		m[9] = 0;
		m[10] = -2 / (f - n);
		m[11] = -(f + n) / (f - n);

		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;

		return result;
	};

	// ### GL.Matrix.scale(x, y, z[, result])
	//
	// This emulates the OpenGL function `glScale()`. You can optionally pass an
	// existing matrix in `result` to avoid allocating a new matrix.
	Matrix.scale = function(x, y, z, result) {
		result = result || new Matrix();
		var m = result.m;

		m[0] = x;
		m[1] = 0;
		m[2] = 0;
		m[3] = 0;

		m[4] = 0;
		m[5] = y;
		m[6] = 0;
		m[7] = 0;

		m[8] = 0;
		m[9] = 0;
		m[10] = z;
		m[11] = 0;

		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;

		return result;
	};

	// ### GL.Matrix.translate(x, y, z[, result])
	//
	// This emulates the OpenGL function `glTranslate()`. You can optionally pass
	// an existing matrix in `result` to avoid allocating a new matrix.
	Matrix.translate = function(x, y, z, result) {
		result = result || new Matrix();
		var m = result.m;

		m[0] = 1;
		m[1] = 0;
		m[2] = 0;
		m[3] = x;

		m[4] = 0;
		m[5] = 1;
		m[6] = 0;
		m[7] = y;

		m[8] = 0;
		m[9] = 0;
		m[10] = 1;
		m[11] = z;

		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;

		return result;
	};

	// ### GL.Matrix.rotate(a, x, y, z[, result])
	//
	// Returns a matrix that rotates by `a` degrees around the vector `x, y, z`.
	// You can optionally pass an existing matrix in `result` to avoid allocating
	// a new matrix. This emulates the OpenGL function `glRotate()`.
	Matrix.rotate = function(a, x, y, z, result) {
		if(!a || (!x && !y && !z)) {
			return Matrix.identity(result);
		}

		result = result || new Matrix();
		var m = result.m;

		var d = Math.sqrt(x * x + y * y + z * z);
		a *= Math.PI / 180;
		x /= d;
		y /= d;
		z /= d;
		var c = Math.cos(a),
			s = Math.sin(a),
			t = 1 - c;

		m[0] = x * x * t + c;
		m[1] = x * y * t - z * s;
		m[2] = x * z * t + y * s;
		m[3] = 0;

		m[4] = y * x * t + z * s;
		m[5] = y * y * t + c;
		m[6] = y * z * t - x * s;
		m[7] = 0;

		m[8] = z * x * t - y * s;
		m[9] = z * y * t + x * s;
		m[10] = z * z * t + c;
		m[11] = 0;

		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;

		return result;
	};

	// ### GL.Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz[, result])
	//
	// Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking
	// toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.
	// You can optionally pass an existing matrix in `result` to avoid allocating
	// a new matrix. This emulates the OpenGL function `gluLookAt()`.
	Matrix.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz, result) {
		result = result || new Matrix();
		var m = result.m;

		var e = new Vector(ex, ey, ez);
		var c = new Vector(cx, cy, cz);
		var u = new Vector(ux, uy, uz);
		var f = e.subtract(c).unit();
		var s = u.cross(f).unit();
		var t = f.cross(s).unit();

		m[0] = s.x;
		m[1] = s.y;
		m[2] = s.z;
		m[3] = -s.dot(e);

		m[4] = t.x;
		m[5] = t.y;
		m[6] = t.z;
		m[7] = -t.dot(e);

		m[8] = f.x;
		m[9] = f.y;
		m[10] = f.z;
		m[11] = -f.dot(e);

		m[12] = 0;
		m[13] = 0;
		m[14] = 0;
		m[15] = 1;

		return result;
	};

	// src/raytracer.js
	// Provides a convenient raytracing interface.
	// ### new GL.HitTest([t, hit, normal])
	//
	// This is the object used to return hit test results. If there are no
	// arguments, the constructed argument represents a hit infinitely far
	// away.


	function HitTest(t, hit, normal) {
		this.t = arguments.length ? t : Number.MAX_VALUE;
		this.hit = hit;
		this.normal = normal;
	}

	// ### .mergeWith(other)
	//
	// Changes this object to be the closer of the two hit test results.
	HitTest.prototype = {
		mergeWith: function(other) {
			if(other.t > 0 && other.t < this.t) {
				this.t = other.t;
				this.hit = other.hit;
				this.normal = other.normal;
			}
		}
	};

	// ### new GL.Raytracer()
	//
	// This will read the current modelview matrix, projection matrix, and viewport,
	// reconstruct the eye position, and store enough information to later generate
	// per-pixel rays using `getRayForPixel()`.
	//
	// Example usage:
	//
	//     var tracer = new GL.Raytracer();
	//     var ray = tracer.getRayForPixel(
	//       gl.canvas.width / 2,
	//       gl.canvas.height / 2);
	//     var result = GL.Raytracer.hitTestSphere(
	//       tracer.eye, ray, new GL.Vector(0, 0, 0), 1);


	function Raytracer() {
		var v = gl.getParameter(gl.VIEWPORT);
		var m = gl.modelviewMatrix.m;

		var axisX = new Vector(m[0], m[4], m[8]);
		var axisY = new Vector(m[1], m[5], m[9]);
		var axisZ = new Vector(m[2], m[6], m[10]);
		var offset = new Vector(m[3], m[7], m[11]);
		this.eye = new Vector(-offset.dot(axisX), -offset.dot(axisY), -offset.dot(axisZ));

		var minX = v[0],
			maxX = minX + v[2];
		var minY = v[1],
			maxY = minY + v[3];
		this.ray00 = gl.unProject(minX, minY, 1).subtract(this.eye);
		this.ray10 = gl.unProject(maxX, minY, 1).subtract(this.eye);
		this.ray01 = gl.unProject(minX, maxY, 1).subtract(this.eye);
		this.ray11 = gl.unProject(maxX, maxY, 1).subtract(this.eye);
		this.viewport = v;
	}

	Raytracer.prototype = {
		// ### .getRayForPixel(x, y)
		//
		// Returns the ray originating from the camera and traveling through the pixel `x, y`.
		getRayForPixel: function(x, y) {
			x = (x - this.viewport[0]) / this.viewport[2];
			y = 1 - (y - this.viewport[1]) / this.viewport[3];
			var ray0 = Vector.lerp(this.ray00, this.ray10, x);
			var ray1 = Vector.lerp(this.ray01, this.ray11, x);
			return Vector.lerp(ray0, ray1, y).unit();
		}
	};

	// ### GL.Raytracer.hitTestBox(origin, ray, min, max)
	//
	// Traces the ray starting from `origin` along `ray` against the axis-aligned box
	// whose coordinates extend from `min` to `max`. Returns a `HitTest` with the
	// information or `null` for no intersection.
	//
	// This implementation uses the [slab intersection method](http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm).
	Raytracer.hitTestBox = function(origin, ray, min, max) {
		var tMin = min.subtract(origin).divide(ray);
		var tMax = max.subtract(origin).divide(ray);
		var t1 = Vector.min(tMin, tMax);
		var t2 = Vector.max(tMin, tMax);
		var tNear = t1.max();
		var tFar = t2.min();

		if(tNear > 0 && tNear < tFar) {
			var epsilon = 1.0e-6,
				hit = origin.add(ray.multiply(tNear));
			min = min.add(epsilon);
			max = max.subtract(epsilon);
			return new HitTest(tNear, hit, new Vector(
			(hit.x > max.x) - (hit.x < min.x), (hit.y > max.y) - (hit.y < min.y), (hit.z > max.z) - (hit.z < min.z)));
		}

		return null;
	};

	// ### GL.Raytracer.hitTestSphere(origin, ray, center, radius)
	//
	// Traces the ray starting from `origin` along `ray` against the sphere defined
	// by `center` and `radius`. Returns a `HitTest` with the information or `null`
	// for no intersection.
	Raytracer.hitTestSphere = function(origin, ray, center, radius) {
		var offset = origin.subtract(center);
		var a = ray.dot(ray);
		var b = 2 * ray.dot(offset);
		var c = offset.dot(offset) - radius * radius;
		var discriminant = b * b - 4 * a * c;

		if(discriminant > 0) {
			var t = (-b - Math.sqrt(discriminant)) / (2 * a),
				hit = origin.add(ray.multiply(t));
			return new HitTest(t, hit, hit.subtract(center).divide(radius));
		}

		return null;
	};

	// ### GL.Raytracer.hitTestTriangle(origin, ray, a, b, c)
	//
	// Traces the ray starting from `origin` along `ray` against the triangle defined
	// by the points `a`, `b`, and `c`. Returns a `HitTest` with the information or
	// `null` for no intersection.
	Raytracer.hitTestTriangle = function(origin, ray, a, b, c) {
		var ab = b.subtract(a);
		var ac = c.subtract(a);
		var normal = ab.cross(ac).unit();
		var t = normal.dot(a.subtract(origin)) / normal.dot(ray);

		if(t > 0) {
			var hit = origin.add(ray.multiply(t));
			var toHit = hit.subtract(a);
			var dot00 = ac.dot(ac);
			var dot01 = ac.dot(ab);
			var dot02 = ac.dot(toHit);
			var dot11 = ab.dot(ab);
			var dot12 = ab.dot(toHit);
			var divide = dot00 * dot11 - dot01 * dot01;
			var u = (dot11 * dot02 - dot01 * dot12) / divide;
			var v = (dot00 * dot12 - dot01 * dot02) / divide;
			if(u >= 0 && v >= 0 && u + v <= 1) return new HitTest(t, hit, normal);
		}

		return null;
	};

	return GL;
})();

if (typeof exports !== 'undefined') {
    // Running as common.js module
    module.exports = GL
}

});
require.register("jonnor-OpenJSCADorg/csg.js", function(exports, require, module){
/*
## License

Copyright (c) 2013 Eduard Bespalov (edwbes@gmail.com): .solidFromSlices()
Copyright (c) 2013 Rene K. Mueller (http://OpenJSCAD.org): AMF export added, CSG.center([flag,flag,flag]);
Copyright (c) 2012 Joost Nieuwenhuijse (joost@newhouse.nl)
Copyright (c) 2012 Alexandre Girard (https://github.com/alx)
Copyright (c) 2011 Evan Wallace (http://evanw.github.com/csg.js/) -- original csg.js

All code released under MIT license

## Overview

For an overview of the CSG process see the original csg.js code:
http://evanw.github.com/csg.js/

CSG operations through BSP trees suffer from one problem: heavy fragmentation
of polygons. If two CSG solids of n polygons are unified, the resulting solid may have
in the order of n*n polygons, because each polygon is split by the planes of all other
polygons. After a few operations the number of polygons explodes.

This version of CSG.js solves the problem in 3 ways:

1. Every polygon split is recorded in a tree (CSG.PolygonTreeNode). This is a separate
tree, not to be confused with the CSG tree. If a polygon is split into two parts but in
the end both fragments have not been discarded by the CSG operation, we can retrieve
the original unsplit polygon from the tree, instead of the two fragments.

This does not completely solve the issue though: if a polygon is split multiple times
the number of fragments depends on the order of subsequent splits, and we might still
end up with unncessary splits:
Suppose a polygon is first split into A and B, and then into A1, B1, A2, B2. Suppose B2 is
discarded. We will end up with 2 polygons: A and B1. Depending on the actual split boundaries
we could still have joined A and B1 into one polygon. Therefore a second approach is used as well:

2. After CSG operations all coplanar polygon fragments are joined by a retesselating
operation. See CSG.reTesselated(). Retesselation is done through a
linear sweep over the polygon surface. The sweep line passes over the y coordinates
of all vertices in the polygon. Polygons are split at each sweep line, and the fragments
are joined horizontally and vertically into larger polygons (making sure that we
will end up with convex polygons).
This still doesn't solve the problem completely: due to floating point imprecisions
we may end up with small gaps between polygons, and polygons may not be exactly coplanar
anymore, and as a result the retesselation algorithm may fail to join those polygons.
Therefore:

3. A canonicalization algorithm is implemented: it looks for vertices that have
approximately the same coordinates (with a certain tolerance, say 1e-5) and replaces
them with the same vertex. If polygons share a vertex they will actually point to the
same CSG.Vertex instance. The same is done for polygon planes. See CSG.canonicalized().


Performance improvements to the original CSG.js:

Replaced the flip() and invert() methods by flipped() and inverted() which don't
modify the source object. This allows to get rid of all clone() calls, so that
multiple polygons can refer to the same CSG.Plane instance etc.

The original union() used an extra invert(), clipTo(), invert() sequence just to remove the
coplanar front faces from b; this is now combined in a single b.clipTo(a, true) call.

Detection whether a polygon is in front or in back of a plane: for each polygon
we are caching the coordinates of the bounding sphere. If the bounding sphere is
in front or in back of the plane we don't have to check the individual vertices
anymore.


Other additions to the original CSG.js:

CSG.Vector class has been renamed into CSG.Vector3D

Classes for 3D lines, 2D vectors, 2D lines, and methods to find the intersection of
a line and a plane etc.

Transformations: CSG.transform(), CSG.translate(), CSG.rotate(), CSG.scale()

Expanding or contracting a solid: CSG.expand() and CSG.contract(). Creates nice
smooth corners.

The vertex normal has been removed since it complicates retesselation. It's not needed
for solid CAD anyway.

*/

var toplevel = this;
if (typeof exports !== 'undefined') {
    // Running as common.js module
    toplevel = exports;
}

(function(module){

var _CSGDEBUG = false;

function fnNumberSort(a, b) {
	return a - b;
}

// # class CSG
// Holds a binary space partition tree representing a 3D solid. Two solids can
// be combined using the `union()`, `subtract()`, and `intersect()` methods.
var CSG = function() {
	this.polygons = [];
	this.properties = new CSG.Properties();
	this.isCanonicalized = true;
	this.isRetesselated = true;
};

CSG.defaultResolution2D = 32;
CSG.defaultResolution3D = 12;

// Construct a CSG solid from a list of `CSG.Polygon` instances.
CSG.fromPolygons = function(polygons) {
	var csg = new CSG();
	csg.polygons = polygons;
	csg.isCanonicalized = false;
	csg.isRetesselated = false;
	return csg;
};

// Construct a CSG solid from generated slices.
// Look at CSG.Polygon.prototype.solidFromSlices for details
CSG.fromSlices = function(options) {
	return (new CSG.Polygon.createFromPoints([
			[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]
	])).solidFromSlices(options);
};

// create from an untyped object with identical property names:
CSG.fromObject = function(obj) {
	var polygons = obj.polygons.map(function(p) {
		return CSG.Polygon.fromObject(p);
	});
	var csg = CSG.fromPolygons(polygons);
	csg = csg.canonicalized();
	return csg;
};

// Reconstruct a CSG from the output of toCompactBinary()
CSG.fromCompactBinary = function(bin) {
	if(bin['class'] != "CSG") throw new Error("Not a CSG");
	var planes = [],
		planeData = bin.planeData,
		numplanes = planeData.length / 4,
		arrayindex = 0,
		x, y, z, w, normal, plane;
	for(var planeindex = 0; planeindex < numplanes; planeindex++) {
		x = planeData[arrayindex++];
		y = planeData[arrayindex++];
		z = planeData[arrayindex++];
		w = planeData[arrayindex++];
		normal = new CSG.Vector3D(x, y, z);
		plane = new CSG.Plane(normal, w);
		planes.push(plane);
	}

	var vertices = [],
		vertexData = bin.vertexData,
		numvertices = vertexData.length / 3,
		pos, vertex;
	arrayindex = 0;
	for(var vertexindex = 0; vertexindex < numvertices; vertexindex++) {
		x = vertexData[arrayindex++];
		y = vertexData[arrayindex++];
		z = vertexData[arrayindex++];
		pos = new CSG.Vector3D(x, y, z);
		vertex = new CSG.Vertex(pos);
		vertices.push(vertex);
	}

	var shareds = bin.shared.map(function(shared) {
		return CSG.Polygon.Shared.fromObject(shared);
	});

	var polygons = [],
		numpolygons = bin.numPolygons,
		numVerticesPerPolygon = bin.numVerticesPerPolygon,
		polygonVertices = bin.polygonVertices,
		polygonPlaneIndexes = bin.polygonPlaneIndexes,
		polygonSharedIndexes = bin.polygonSharedIndexes,
		numpolygonvertices, polygonvertices, shared, polygon;//already defined plane,
	arrayindex = 0;
	for(var polygonindex = 0; polygonindex < numpolygons; polygonindex++) {
		numpolygonvertices = numVerticesPerPolygon[polygonindex];
		polygonvertices = [];
		for(var i = 0; i < numpolygonvertices; i++) {
			polygonvertices.push(vertices[polygonVertices[arrayindex++]]);
		}
		plane = planes[polygonPlaneIndexes[polygonindex]];
		shared = shareds[polygonSharedIndexes[polygonindex]];
		polygon = new CSG.Polygon(polygonvertices, shared, plane);
		polygons.push(polygon);
	}
	var csg = CSG.fromPolygons(polygons);
	csg.isCanonicalized = true;
	csg.isRetesselated = true;
	return csg;
};

CSG.prototype = {
	toPolygons: function() {
		return this.polygons;
	},

	// Return a new CSG solid representing space in either this solid or in the
	// solid `csg`. Neither this solid nor the solid `csg` are modified.
	//
	//     A.union(B)
	//
	//     +-------+            +-------+
	//     |       |            |       |
	//     |   A   |            |       |
	//     |    +--+----+   =   |       +----+
	//     +----+--+    |       +----+       |
	//          |   B   |            |       |
	//          |       |            |       |
	//          +-------+            +-------+
	//
	union: function(csg) {
		var csgs;
		if(csg instanceof Array) {
			csgs = csg;
		} else {
			csgs = [csg];
		}
		var result = this;
		for(var i = 0; i < csgs.length; i++) {
			var islast = (i == (csgs.length - 1));
			result = result.unionSub(csgs[i], islast, islast);
		}
		return result;
	},

	unionSub: function(csg, retesselate, canonicalize) {
		if(!this.mayOverlap(csg)) {
			return this.unionForNonIntersecting(csg);
		} else {
			var a = new CSG.Tree(this.polygons);
			var b = new CSG.Tree(csg.polygons);
			a.clipTo(b, false);

			// b.clipTo(a, true); // ERROR: this doesn't work
			b.clipTo(a);
			b.invert();
			b.clipTo(a);
			b.invert();

			var newpolygons = a.allPolygons().concat(b.allPolygons());
			var result = CSG.fromPolygons(newpolygons);
			result.properties = this.properties._merge(csg.properties);
			if(retesselate) result = result.reTesselated();
			if(canonicalize) result = result.canonicalized();
			return result;
		}
	},

	// Like union, but when we know that the two solids are not intersecting
	// Do not use if you are not completely sure that the solids do not intersect!
	unionForNonIntersecting: function(csg) {
		var newpolygons = this.polygons.concat(csg.polygons);
		var result = CSG.fromPolygons(newpolygons);
		result.properties = this.properties._merge(csg.properties);
		result.isCanonicalized = this.isCanonicalized && csg.isCanonicalized;
		result.isRetesselated = this.isRetesselated && csg.isRetesselated;
		return result;
	},

	// Return a new CSG solid representing space in this solid but not in the
	// solid `csg`. Neither this solid nor the solid `csg` are modified.
	//
	//     A.subtract(B)
	//
	//     +-------+            +-------+
	//     |       |            |       |
	//     |   A   |            |       |
	//     |    +--+----+   =   |    +--+
	//     +----+--+    |       +----+
	//          |   B   |
	//          |       |
	//          +-------+
	//
	subtract: function(csg) {
		var csgs;
		if(csg instanceof Array) {
			csgs = csg;
		} else {
			csgs = [csg];
		}
		var result = this;
		for(var i = 0; i < csgs.length; i++) {
			var islast = (i == (csgs.length - 1));
			result = result.subtractSub(csgs[i], islast, islast);
		}
		return result;
	},

	subtractSub: function(csg, retesselate, canonicalize) {
		var a = new CSG.Tree(this.polygons);
		var b = new CSG.Tree(csg.polygons);
		a.invert();
		a.clipTo(b);
		b.clipTo(a, true);
		a.addPolygons(b.allPolygons());
		a.invert();
		var result = CSG.fromPolygons(a.allPolygons());
		result.properties = this.properties._merge(csg.properties);
		if(retesselate) result = result.reTesselated();
		if(canonicalize) result = result.canonicalized();
		return result;
	},

	// Return a new CSG solid representing space both this solid and in the
	// solid `csg`. Neither this solid nor the solid `csg` are modified.
	//
	//     A.intersect(B)
	//
	//     +-------+
	//     |       |
	//     |   A   |
	//     |    +--+----+   =   +--+
	//     +----+--+    |       +--+
	//          |   B   |
	//          |       |
	//          +-------+
	//
	intersect: function(csg) {
		var csgs;
		if(csg instanceof Array) {
			csgs = csg;
		} else {
			csgs = [csg];
		}
		var result = this;
		for(var i = 0; i < csgs.length; i++) {
			var islast = (i == (csgs.length - 1));
			result = result.intersectSub(csgs[i], islast, islast);
		}
		return result;
	},

	intersectSub: function(csg, retesselate, canonicalize) {
		var a = new CSG.Tree(this.polygons);
		var b = new CSG.Tree(csg.polygons);
		a.invert();
		b.clipTo(a);
		b.invert();
		a.clipTo(b);
		b.clipTo(a);
		a.addPolygons(b.allPolygons());
		a.invert();
		var result = CSG.fromPolygons(a.allPolygons());
		result.properties = this.properties._merge(csg.properties);
		if(retesselate) result = result.reTesselated();
		if(canonicalize) result = result.canonicalized();
		return result;
	},

	// Return a new CSG solid with solid and empty space switched. This solid is
	// not modified.
	inverse: function() {
		var flippedpolygons = this.polygons.map(function(p) {
			return p.flipped();
		});
		return CSG.fromPolygons(flippedpolygons);
		// TODO: flip properties
	},

	// Affine transformation of CSG object. Returns a new CSG object
	transform1: function(matrix4x4) {
		var newpolygons = this.polygons.map(function(p) {
			return p.transform(matrix4x4);
		});
		var result = CSG.fromPolygons(newpolygons);
		result.properties = this.properties._transform(matrix4x4);
		result.isRetesselated = this.isRetesselated;
		return result;
	},

	transform: function(matrix4x4) {
		var ismirror = matrix4x4.isMirroring();
		var transformedvertices = {};
		var transformedplanes = {};
		var newpolygons = this.polygons.map(function(p) {
			var newplane;
			var plane = p.plane;
			var planetag = plane.getTag();
			if(planetag in transformedplanes) {
				newplane = transformedplanes[planetag];
			} else {
				newplane = plane.transform(matrix4x4);
				transformedplanes[planetag] = newplane;
			}
			var newvertices = p.vertices.map(function(v) {
				var newvertex;
				var vertextag = v.getTag();
				if(vertextag in transformedvertices) {
					newvertex = transformedvertices[vertextag];
				} else {
					newvertex = v.transform(matrix4x4);
					transformedvertices[vertextag] = newvertex;
				}
				return newvertex;
			});
			if(ismirror) newvertices.reverse();
			return new CSG.Polygon(newvertices, p.shared, newplane);
		});
		var result = CSG.fromPolygons(newpolygons);
		result.properties = this.properties._transform(matrix4x4);
		result.isRetesselated = this.isRetesselated;
		result.isCanonicalized = this.isCanonicalized;
		return result;
	},

	toStlString: function() {
		var result = "solid csg.js\n";
		this.polygons.map(function(p) {
			result += p.toStlString();
		});
		result += "endsolid csg.js\n";
		return result;
	},

	toAMFString: function(m) {
		var result = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<amf"+(m&&m.unit?" unit=\"+m.unit\"":"")+">\n";
		for(var k in m) {
			result += "<metadata type=\""+k+"\">"+m[k]+"</metadata>\n";
		}
		result += "<object id=\"0\">\n<mesh>\n<vertices>\n";

		this.polygons.map(function(p) {                  // first we dump all vertices of all polygons
         for(var i=0; i<p.vertices.length; i++) {
            result += p.vertices[i].toAMFString();
         }
      });
      result += "</vertices>\n";

      var n = 0;
		this.polygons.map(function(p) {                  // then we dump all polygons
         result += "<volume>\n";
         if(p.vertices.length<3) 
            return;
			var r = 1, g = 0.4, b = 1, a = 1, colorSet = false;
			if(p.shared && p.shared.color) {
				r = p.shared.color[0];
				g = p.shared.color[1];
				b = p.shared.color[2];
            a = p.shared.color[3];
				colorSet = true;
			} else if(p.color) {
            r = p.color[0];
            g = p.color[1];
            b = p.color[2];
            if(p.color.length()>3) a = p.color[3];
				colorSet = true;
         }

   		result += "<color><r>"+r+"</r><g>"+g+"</g><b>"+b+"</b>"+(a!==undefined?"<a>"+a+"</a>":"")+"</color>";

         for(var i=0; i<p.vertices.length-2; i++) {      // making sure they are all triangles (triangular polygons)
            result += "<triangle>";
            result += "<v1>" + (n) + "</v1>";
            result += "<v2>" + (n+i+1) + "</v2>";
            result += "<v3>" + (n+i+2) + "</v3>";
            result += "</triangle>\n";
         }
         n += p.vertices.length;
         result += "</volume>\n";
		});
		result += "</mesh>\n</object>\n";
		result += "</amf>\n";
		return result;
	},

	toX3D: function() {
		// materialPolygonLists
		// key: a color string (e.g. "0 1 1" for yellow)
		// value: an array of strings specifying polygons of this color
		//        (as space-separated indices into vertexCoords)
		var materialPolygonLists = {},
		// list of coordinates (as "x y z" strings)
			vertexCoords = [],
		// map to look up the index in vertexCoords of a given vertex
			vertexTagToCoordIndexMap = {};

		this.polygons.map(function(p) {
			var red = 0,
				green = 0,
				blue = 1; // default color is blue
			if(p.shared && p.shared.color) {
				red = p.shared.color[0];
				green = p.shared.color[1];
				blue = p.shared.color[2];
			}

			var polygonVertexIndices = [],
				numvertices = p.vertices.length,
				vertex;
			for(var i = 0; i < numvertices; i++) {
				vertex = p.vertices[i];
				if(!(vertex.getTag() in vertexTagToCoordIndexMap)) {
					vertexCoords.push(vertex.pos._x.toString() + " " +
						vertex.pos._y.toString() + " " +
						vertex.pos._z.toString()
					);
					vertexTagToCoordIndexMap[vertex.getTag()] = vertexCoords.length - 1;
				}
				polygonVertexIndices.push(vertexTagToCoordIndexMap[vertex.getTag()]);
			}

			var polygonString = polygonVertexIndices.join(" ");

			var colorString = red.toString() + " " + green.toString() + " " + blue.toString();
			if(!(colorString in materialPolygonLists)) {
				materialPolygonLists[colorString] = [];
			}
			// add this polygonString to the list of colorString-colored polygons
			materialPolygonLists[colorString].push(polygonString);
		});


		// create output document
		var docType = document.implementation.createDocumentType("X3D",
			'ISO//Web3D//DTD X3D 3.1//EN" "http://www.web3d.org/specifications/x3d-3.1.dtd', null);
		var exportDoc = document.implementation.createDocument(null, "X3D", docType);
		exportDoc.insertBefore(
			exportDoc.createProcessingInstruction('xml', 'version="1.0" encoding="UTF-8"'),
			exportDoc.doctype);

		var exportRoot = exportDoc.getElementsByTagName("X3D")[0];
		exportRoot.setAttribute("profile", "Interchange");
		exportRoot.setAttribute("version", "3.1");
		exportRoot.setAttribute("xsd:noNamespaceSchemaLocation","http://www.web3d.org/specifications/x3d-3.1.xsd");
		exportRoot.setAttribute("xmlns:xsd", "http://www.w3.org/2001/XMLSchema-instance");

		var exportScene = exportDoc.createElement("Scene");
		exportRoot.appendChild(exportScene);

		/*
	  For each color, create a shape made of an appropriately colored
	  material which contains all polygons that are this color.

	  The first shape will contain the definition of all vertices,
	  (<Coordinate DEF="coords_mesh"/>), which will be referenced by
	  subsequent shapes.
	*/
		var coordsMeshDefined = false;
		for(var colorString in materialPolygonLists) {
			var polygonList = materialPolygonLists[colorString];
			var shape = exportDoc.createElement("Shape");
			exportScene.appendChild(shape);

			var appearance = exportDoc.createElement("Appearance");
			shape.appendChild(appearance);

			var material = exportDoc.createElement("Material");
			appearance.appendChild(material);
			material.setAttribute("diffuseColor", colorString);
			material.setAttribute("ambientIntensity", "1.0");

			var ifs = exportDoc.createElement("IndexedFaceSet");
			shape.appendChild(ifs);
			ifs.setAttribute("solid", "true");
			ifs.setAttribute("coordIndex", polygonList.join(" -1 ") + " -1");

			var coordinate = exportDoc.createElement("Coordinate");
			ifs.appendChild(coordinate);
			if(coordsMeshDefined) {
				coordinate.setAttribute("USE", "coords_mesh");
			} else {
				coordinate.setAttribute("DEF", "coords_mesh");
				coordinate.setAttribute("point", vertexCoords.join(" "));
				coordsMeshDefined = true;
			}
		}

		var x3dstring = (new XMLSerializer()).serializeToString(exportDoc);
		return new Blob([x3dstring], {
			type: "model/x3d+xml"
		});
	},

	// see http://en.wikipedia.org/wiki/STL_%28file_format%29#Binary_STL
	toStlBinary: function(p) {
		// first check if the host is little-endian:
		var buffer = new ArrayBuffer(4);
		var int32buffer = new Int32Array(buffer, 0, 1);
		var int8buffer = new Int8Array(buffer, 0, 4);
		int32buffer[0] = 0x11223344;
		if(int8buffer[0] != 0x44) {
			throw new Error("Binary STL output is currently only supported on little-endian (Intel) processors");
		}

		var numtriangles = 0;
		this.polygons.map(function(p) {
			var numvertices = p.vertices.length;
			var thisnumtriangles = (numvertices >= 3) ? numvertices - 2 : 0;
			numtriangles += thisnumtriangles;
		});
		var headerarray = new Uint8Array(80);
		for(var i = 0; i < 80; i++) {
			headerarray[i] = 65;
		}
		var ar1 = new Uint32Array(1);
		ar1[0] = numtriangles;
		// write the triangles to allTrianglesBuffer:
		var allTrianglesBuffer = new ArrayBuffer(50 * numtriangles);
		var allTrianglesBufferAsInt8 = new Int8Array(allTrianglesBuffer);
		// a tricky problem is that a Float32Array must be aligned at 4-byte boundaries (at least in certain browsers)
		// while each triangle takes 50 bytes. Therefore we write each triangle to a temporary buffer, and copy that
		// into allTrianglesBuffer:
		var triangleBuffer = new ArrayBuffer(50);
		var triangleBufferAsInt8 = new Int8Array(triangleBuffer);
		// each triangle consists of 12 floats:
		var triangleFloat32array = new Float32Array(triangleBuffer, 0, 12);
		// and one uint16:
		var triangleUint16array = new Uint16Array(triangleBuffer, 48, 1);
		var byteoffset = 0;
		this.polygons.map(function(p) {
			var numvertices = p.vertices.length;
			for(var i = 0; i < numvertices - 2; i++) {
				var normal = p.plane.normal;
				triangleFloat32array[0] = normal._x;
				triangleFloat32array[1] = normal._y;
				triangleFloat32array[2] = normal._z;
				var arindex = 3;
				for(var v = 0; v < 3; v++) {
					var vv = v + ((v > 0) ? i : 0);
					var vertexpos = p.vertices[vv].pos;
					triangleFloat32array[arindex++] = vertexpos._x;
					triangleFloat32array[arindex++] = vertexpos._y;
					triangleFloat32array[arindex++] = vertexpos._z;
				}
				triangleUint16array[0] = 0;
				// copy the triangle into allTrianglesBuffer:
				allTrianglesBufferAsInt8.set(triangleBufferAsInt8, byteoffset);
				byteoffset += 50;
			}
		});
      if(p&&p.webBlob) {      // -- want a blob direct
			return new Blob([headerarray.buffer, ar1.buffer, allTrianglesBuffer], {
			   type: "application/sla"
			});
      } else {
         // we differentiate, as binary string blobbing gives bad blob in web, we need binary string for CLI
         //    perhaps there is a way to make it working (see openjscad for stlb)\
         //
         // concat 3 buffers together -- don't make blob so early, we want data (non-blob) for nodejs too
         //    must be string data direct to write
         var stl = new Uint8Array(headerarray.buffer.byteLength + ar1.buffer.byteLength + allTrianglesBuffer.byteLength);
         var j = 0;
         for(var i=0; i<headerarray.buffer.byteLength; i++) { stl.buffer[j++] = headerarray.buffer[i]; }
         for(var i=0; i<ar1.buffer.byteLength; i++) { stl.buffer[j++] = ar1.buffer[i]; }
         for(var i=0; i<allTrianglesBuffer.byteLength; i++) { stl.buffer[j++] = allTrianglesBuffer[i]; }
         return String.fromCharCode.apply(null, new Uint8Array(stl.buffer)); 
         
      }   
	},

	toString: function() {
		var result = "CSG solid:\n";
		this.polygons.map(function(p) {
			result += p.toString();
		});
		return result;
	},

   center: function(c) {
      if(!c.length) c = [c,c,c];
      var b = this.getBounds();
      return this.translate([
         c[0]?-(b[1].x-b[0].x)/2-b[0].x:0,
         c[1]?-(b[1].y-b[0].y)/2-b[0].y:0,
         c[2]?-(b[1].z-b[0].z)/2-b[0].z:0]);
   },

	// Expand the solid
	// resolution: number of points per 360 degree for the rounded corners
	expand: function(radius, resolution) {
		var result = this.expandedShell(radius, resolution, true);
		result = result.reTesselated();
		result.properties = this.properties; // keep original properties
		return result;
	},

	// Contract the solid
	// resolution: number of points per 360 degree for the rounded corners
	contract: function(radius, resolution) {
		var expandedshell = this.expandedShell(radius, resolution, false);
		var result = this.subtract(expandedshell);
		result = result.reTesselated();
		result.properties = this.properties; // keep original properties
		return result;
	},

	// Create the expanded shell of the solid:
	// All faces are extruded to get a thickness of 2*radius
	// Cylinders are constructed around every side
	// Spheres are placed on every vertex
	// unionWithThis: if true, the resulting solid will be united with 'this' solid;
	//   the result is a true expansion of the solid
	//   If false, returns only the shell
	expandedShell: function(radius, resolution, unionWithThis) {
		var csg = this.reTesselated();
		var result;
		if(unionWithThis) {
			result = csg;
		} else {
			result = new CSG();
		}

		// first extrude all polygons:
		csg.polygons.map(function(polygon) {
			var extrudevector = polygon.plane.normal.unit().times(2 * radius);
			var translatedpolygon = polygon.translate(extrudevector.times(-0.5));
			var extrudedface = translatedpolygon.extrude(extrudevector);
			result = result.unionSub(extrudedface, false, false);
		});

		// Make a list of all unique vertex pairs (i.e. all sides of the solid)
		// For each vertex pair we collect the following:
		//   v1: first coordinate
		//   v2: second coordinate
		//   planenormals: array of normal vectors of all planes touching this side
		var vertexpairs = {}; // map of 'vertex pair tag' to {v1, v2, planenormals}
		csg.polygons.map(function(polygon) {
			var numvertices = polygon.vertices.length;
			var prevvertex = polygon.vertices[numvertices - 1];
			var prevvertextag = prevvertex.getTag();
			for(var i = 0; i < numvertices; i++) {
				var vertex = polygon.vertices[i];
				var vertextag = vertex.getTag();
				var vertextagpair;
				if(vertextag < prevvertextag) {
					vertextagpair = vertextag + "-" + prevvertextag;
				} else {
					vertextagpair = prevvertextag + "-" + vertextag;
				}
				var obj;
				if(vertextagpair in vertexpairs) {
					obj = vertexpairs[vertextagpair];
				} else {
					obj = {
						v1: prevvertex,
						v2: vertex,
						planenormals: []
					};
					vertexpairs[vertextagpair] = obj;
				}
				obj.planenormals.push(polygon.plane.normal);

				prevvertextag = vertextag;
				prevvertex = vertex;
			}
		});

		// now construct a cylinder on every side
		// The cylinder is always an approximation of a true cylinder: it will have <resolution> polygons
		// around the sides. We will make sure though that the cylinder will have an edge at every
		// face that touches this side. This ensures that we will get a smooth fill even
		// if two edges are at, say, 10 degrees and the resolution is low.
		// Note: the result is not retesselated yet but it really should be!
		for(var vertextagpair in vertexpairs) {
			var vertexpair = vertexpairs[vertextagpair],
				startpoint = vertexpair.v1.pos,
				endpoint = vertexpair.v2.pos,
			// our x,y and z vectors:
				zbase = endpoint.minus(startpoint).unit(),
				xbase = vertexpair.planenormals[0].unit(),
				ybase = xbase.cross(zbase),

			// make a list of angles that the cylinder should traverse:
				angles = [];

			// first of all equally spaced around the cylinder:
			for(var i = 0; i < resolution; i++) {
				angles.push(i * Math.PI * 2 / resolution);
			}

			// and also at every normal of all touching planes:
			for(var i = 0, iMax = vertexpair.planenormals.length; i < iMax; i++) {
				var planenormal = vertexpair.planenormals[i],
					si = ybase.dot(planenormal),
					co = xbase.dot(planenormal),
					angle = Math.atan2(si, co);

				if(angle < 0) angle += Math.PI * 2;
				angles.push(angle);
				angle = Math.atan2(-si, -co);
				if(angle < 0) angle += Math.PI * 2;
				angles.push(angle);
			}

			// this will result in some duplicate angles but we will get rid of those later.
			// Sort:
			angles = angles.sort(fnNumberSort);

			// Now construct the cylinder by traversing all angles:
			var numangles = angles.length,
				prevp1, prevp2,
				startfacevertices = [],
				endfacevertices = [],
				polygons = [];
			for(var i = -1; i < numangles; i++) {
				var angle = angles[(i < 0) ? (i + numangles) : i],
					si = Math.sin(angle),
					co = Math.cos(angle),
					p = xbase.times(co * radius).plus(ybase.times(si * radius)),
					p1 = startpoint.plus(p),
					p2 = endpoint.plus(p),
					skip = false;
				if(i >= 0) {
					if(p1.distanceTo(prevp1) < 1e-5) {
						skip = true;
					}
				}
				if(!skip) {
					if(i >= 0) {
						startfacevertices.push(new CSG.Vertex(p1));
						endfacevertices.push(new CSG.Vertex(p2));
						var polygonvertices = [
							new CSG.Vertex(prevp2),
							new CSG.Vertex(p2),
							new CSG.Vertex(p1),
							new CSG.Vertex(prevp1)];
						var polygon = new CSG.Polygon(polygonvertices);
						polygons.push(polygon);
					}
					prevp1 = p1;
					prevp2 = p2;
				}
			}
			endfacevertices.reverse();
			polygons.push(new CSG.Polygon(startfacevertices));
			polygons.push(new CSG.Polygon(endfacevertices));
			var cylinder = CSG.fromPolygons(polygons);
			result = result.unionSub(cylinder, false, false);
		}

		// make a list of all unique vertices
		// For each vertex we also collect the list of normals of the planes touching the vertices
		var vertexmap = {};
		csg.polygons.map(function(polygon) {
			polygon.vertices.map(function(vertex) {
				var vertextag = vertex.getTag();
				var obj;
				if(vertextag in vertexmap) {
					obj = vertexmap[vertextag];
				} else {
					obj = {
						pos: vertex.pos,
						normals: []
					};
					vertexmap[vertextag] = obj;
				}
				obj.normals.push(polygon.plane.normal);
			});
		});

		// and build spheres at each vertex
		// We will try to set the x and z axis to the normals of 2 planes
		// This will ensure that our sphere tesselation somewhat matches 2 planes
		for(var vertextag in vertexmap) {
			var vertexobj = vertexmap[vertextag];
			// use the first normal to be the x axis of our sphere:
			var xaxis = vertexobj.normals[0].unit();
			// and find a suitable z axis. We will use the normal which is most perpendicular to the x axis:
			var bestzaxis = null;
			var bestzaxisorthogonality = 0;
			for(var i = 1; i < vertexobj.normals.length; i++) {
				var normal = vertexobj.normals[i].unit();
				var cross = xaxis.cross(normal);
				var crosslength = cross.length();
				if(crosslength > 0.05) {
					if(crosslength > bestzaxisorthogonality) {
						bestzaxisorthogonality = crosslength;
						bestzaxis = normal;
					}
				}
			}
			if(!bestzaxis) {
				bestzaxis = xaxis.randomNonParallelVector();
			}
			var yaxis = xaxis.cross(bestzaxis).unit();
			var zaxis = yaxis.cross(xaxis);
			var sphere = CSG.sphere({
				center: vertexobj.pos,
				radius: radius,
				resolution: resolution,
				axes: [xaxis, yaxis, zaxis]
			});
			result = result.unionSub(sphere, false, false);
		}

		return result;
	},

	canonicalized: function() {
		if(this.isCanonicalized) {
			return this;
		} else {
			var factory = new CSG.fuzzyCSGFactory();
			var result = factory.getCSG(this);
			result.isCanonicalized = true;
			result.isRetesselated = this.isRetesselated;
			result.properties = this.properties; // keep original properties
			return result;
		}
	},

	reTesselated: function() {
		if(this.isRetesselated) {
			return this;
		} else {
			var csg = this.canonicalized();
			var polygonsPerPlane = {};
			csg.polygons.map(function(polygon) {
				var planetag = polygon.plane.getTag();
				var sharedtag = polygon.shared.getTag();
				planetag += "/" + sharedtag;
				if(!(planetag in polygonsPerPlane)) {
					polygonsPerPlane[planetag] = [];
				}
				polygonsPerPlane[planetag].push(polygon);
			});
			var destpolygons = [];
			for(var planetag in polygonsPerPlane) {
				var sourcepolygons = polygonsPerPlane[planetag];
				if(sourcepolygons.length < 2) {
					destpolygons = destpolygons.concat(sourcepolygons);
				} else {
					var retesselayedpolygons = [];
					CSG.reTesselateCoplanarPolygons(sourcepolygons, retesselayedpolygons);
					destpolygons = destpolygons.concat(retesselayedpolygons);
				}
			}
			var result = CSG.fromPolygons(destpolygons);
			result.isRetesselated = true;
			result = result.canonicalized();
			//      result.isCanonicalized = true;
			result.properties = this.properties; // keep original properties
			return result;
		}
	},

	// returns an array of two CSG.Vector3Ds (minimum coordinates and maximum coordinates)
	getBounds: function() {
		if(!this.cachedBoundingBox) {
			var minpoint = new CSG.Vector3D(0, 0, 0);
			var maxpoint = new CSG.Vector3D(0, 0, 0);
			var polygons = this.polygons;
			var numpolygons = polygons.length;
			for(var i = 0; i < numpolygons; i++) {
				var polygon = polygons[i];
				var bounds = polygon.boundingBox();
				if(i === 0) {
					minpoint = bounds[0];
					maxpoint = bounds[1];
				} else {
					minpoint = minpoint.min(bounds[0]);
					maxpoint = maxpoint.max(bounds[1]);
				}
			}
			this.cachedBoundingBox = [minpoint, maxpoint];
		}
		return this.cachedBoundingBox;
	},

	// returns true if there is a possibility that the two solids overlap
	// returns false if we can be sure that they do not overlap
	mayOverlap: function(csg) {
		if((this.polygons.length === 0) || (csg.polygons.length === 0)) {
			return false;
		} else {
			var mybounds = this.getBounds();
			var otherbounds = csg.getBounds();
         // [0].x/y  
         //    +-----+
         //    |     |
         //    |     |
         //    +-----+ 
         //          [1].x/y
         //return false;
         //echo(mybounds,"=",otherbounds);
			if(mybounds[1].x < otherbounds[0].x) return false;
			if(mybounds[0].x > otherbounds[1].x) return false;
			if(mybounds[1].y < otherbounds[0].y) return false;
			if(mybounds[0].y > otherbounds[1].y) return false;
			if(mybounds[1].z < otherbounds[0].z) return false;
			if(mybounds[0].z > otherbounds[1].z) return false;
			return true;
		}
	},

	// Cut the solid by a plane. Returns the solid on the back side of the plane
	cutByPlane: function(plane) {
		if(this.polygons.length === 0) {
			return new CSG();
		}
		// Ideally we would like to do an intersection with a polygon of inifinite size
		// but this is not supported by our implementation. As a workaround, we will create
		// a cube, with one face on the plane, and a size larger enough so that the entire
		// solid fits in the cube.
		// find the max distance of any vertex to the center of the plane:
		var planecenter = plane.normal.times(plane.w);
		var maxdistance = 0;
		this.polygons.map(function(polygon) {
			polygon.vertices.map(function(vertex) {
				var distance = vertex.pos.distanceToSquared(planecenter);
				if(distance > maxdistance) maxdistance = distance;
			});
		});
		maxdistance = Math.sqrt(maxdistance);
		maxdistance *= 1.01; // make sure it's really larger
		// Now build a polygon on the plane, at any point farther than maxdistance from the plane center:
		var vertices = [];
		var orthobasis = new CSG.OrthoNormalBasis(plane);
		vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(maxdistance, -maxdistance))));
		vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(-maxdistance, -maxdistance))));
		vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(-maxdistance, maxdistance))));
		vertices.push(new CSG.Vertex(orthobasis.to3D(new CSG.Vector2D(maxdistance, maxdistance))));
		var polygon = new CSG.Polygon(vertices, null, plane.flipped());

		// and extrude the polygon into a cube, backwards of the plane:
		var cube = polygon.extrude(plane.normal.times(-maxdistance));

		// Now we can do the intersection:
		var result = this.intersect(cube);
		result.properties = this.properties; // keep original properties
		return result;
	},

	// Connect a solid to another solid, such that two CSG.Connectors become connected
	//   myConnector: a CSG.Connector of this solid
	//   otherConnector: a CSG.Connector to which myConnector should be connected
	//   mirror: false: the 'axis' vectors of the connectors should point in the same direction
	//           true: the 'axis' vectors of the connectors should point in opposite direction
	//   normalrotation: degrees of rotation between the 'normal' vectors of the two
	//                   connectors
	connectTo: function(myConnector, otherConnector, mirror, normalrotation) {
		var matrix = myConnector.getTransformationTo(otherConnector, mirror, normalrotation);
		return this.transform(matrix);
	},

	// set the .shared property of all polygons
	// Returns a new CSG solid, the original is unmodified!
	setShared: function(shared) {
		var polygons = this.polygons.map(function(p) {
			return new CSG.Polygon(p.vertices, shared, p.plane);
		});
		var result = CSG.fromPolygons(polygons);
		result.properties = this.properties; // keep original properties
		result.isRetesselated = this.isRetesselated;
		result.isCanonicalized = this.isCanonicalized;
		return result;
	},

	/**
	 * @param {Array} color [red, green, blue] color values are float numbers 0..1
	 * @return {CSG} new CSG instance
	 */
	setColor: function(red, green, blue, alpha) { //for backward compatibility
		var color = red instanceof Array ? red : [red||0, green||0, blue||0, isNaN(alpha) ? 1. : alpha];
		var newshared = new CSG.Polygon.Shared(color);
		return this.setShared(newshared);
	},

	toCompactBinary: function() {
		var csg = this.canonicalized(),
			numpolygons = csg.polygons.length,
			numpolygonvertices = 0,
			numvertices = 0,
			vertexmap = {},
			vertices = [],
			numplanes = 0,
			planemap = {},
			polygonindex = 0,
			planes = [],
			shareds = [],
			sharedmap = {},
			numshared = 0;
		// for (var i = 0, iMax = csg.polygons.length; i < iMax; i++) {
		// 	var p = csg.polygons[i];
		// 	for (var j = 0, jMax = p.length; j < jMax; j++) {
		// 		++numpolygonvertices;
		// 		var vertextag = p[j].getTag();
		// 		if(!(vertextag in vertexmap)) {
		// 			vertexmap[vertextag] = numvertices++;
		// 			vertices.push(p[j]);
		// 		}
		// 	}
		csg.polygons.map(function(p) {
			p.vertices.map(function(v) {
				++numpolygonvertices;
				var vertextag = v.getTag();
				if(!(vertextag in vertexmap)) {
					vertexmap[vertextag] = numvertices++;
					vertices.push(v);
				}
			});

			var planetag = p.plane.getTag();
			if(!(planetag in planemap)) {
				planemap[planetag] = numplanes++;
				planes.push(p.plane);
			}
			var sharedtag = p.shared.getTag();
			if(!(sharedtag in sharedmap)) {
				sharedmap[sharedtag] = numshared++;
				shareds.push(p.shared);
			}
		});
		var numVerticesPerPolygon = new Uint32Array(numpolygons),
			polygonSharedIndexes = new Uint32Array(numpolygons),
			polygonVertices = new Uint32Array(numpolygonvertices),
			polygonPlaneIndexes = new Uint32Array(numpolygons),
			vertexData = new Float64Array(numvertices * 3),
			planeData = new Float64Array(numplanes * 4),
			polygonVerticesIndex = 0;
		for(var polygonindex = 0; polygonindex < numpolygons; ++polygonindex) {
			var p = csg.polygons[polygonindex];
			numVerticesPerPolygon[polygonindex] = p.vertices.length;
			p.vertices.map(function(v) {
				var vertextag = v.getTag();
				var vertexindex = vertexmap[vertextag];
				polygonVertices[polygonVerticesIndex++] = vertexindex;
			});
			var planetag = p.plane.getTag();
			var planeindex = planemap[planetag];
			polygonPlaneIndexes[polygonindex] = planeindex;
			var sharedtag = p.shared.getTag();
			var sharedindex = sharedmap[sharedtag];
			polygonSharedIndexes[polygonindex] = sharedindex;
		}
		var verticesArrayIndex = 0;
		vertices.map(function(v) {
			var pos = v.pos;
			vertexData[verticesArrayIndex++] = pos._x;
			vertexData[verticesArrayIndex++] = pos._y;
			vertexData[verticesArrayIndex++] = pos._z;
		});
		var planesArrayIndex = 0;
		planes.map(function(p) {
			var normal = p.normal;
			planeData[planesArrayIndex++] = normal._x;
			planeData[planesArrayIndex++] = normal._y;
			planeData[planesArrayIndex++] = normal._z;
			planeData[planesArrayIndex++] = p.w;
		});
		var result = {
			"class": "CSG",
			numPolygons: numpolygons,
			numVerticesPerPolygon: numVerticesPerPolygon,
			polygonPlaneIndexes: polygonPlaneIndexes,
			polygonSharedIndexes: polygonSharedIndexes,
			polygonVertices: polygonVertices,
			vertexData: vertexData,
			planeData: planeData,
			shared: shareds
		};
		return result;
	},

	// For debugging
	// Creates a new solid with a tiny cube at every vertex of the source solid
	toPointCloud: function(cuberadius) {
		var csg = this.reTesselated();

		var result = new CSG();

		// make a list of all unique vertices
		// For each vertex we also collect the list of normals of the planes touching the vertices
		var vertexmap = {};
		csg.polygons.map(function(polygon) {
			polygon.vertices.map(function(vertex) {
				vertexmap[vertex.getTag()] = vertex.pos;
			});
		});

		for(var vertextag in vertexmap) {
			var pos = vertexmap[vertextag];
			var cube = CSG.cube({
				center: pos,
				radius: cuberadius
			});
			result = result.unionSub(cube, false, false);
		}
		result = result.reTesselated();
		return result;
	},

	// Get the transformation that transforms this CSG such that it is lying on the z=0 plane,
	// as flat as possible (i.e. the least z-height).
	// So that it is in an orientation suitable for CNC milling
	getTransformationToFlatLying: function() {
		if(this.polygons.length === 0) {
			return new CSG.Matrix4x4(); // unity
		} else {
			// get a list of unique planes in the CSG:
			var csg = this.canonicalized();
			var planemap = {};
			csg.polygons.map(function(polygon) {
				planemap[polygon.plane.getTag()] = polygon.plane;
			});
			// try each plane in the CSG and find the plane that, when we align it flat onto z=0,
			// gives the least height in z-direction.
			// If two planes give the same height, pick the plane that originally had a normal closest
			// to [0,0,-1].
			var xvector = new CSG.Vector3D(1, 0, 0);
			var yvector = new CSG.Vector3D(0, 1, 0);
			var zvector = new CSG.Vector3D(0, 0, 1);
			var z0connectorx = new CSG.Connector([0, 0, 0], [0, 0, -1], xvector);
			var z0connectory = new CSG.Connector([0, 0, 0], [0, 0, -1], yvector);
			var isfirst = true;
			var minheight = 0;
			var maxdotz = 0;
			var besttransformation;
			for(var planetag in planemap) {
				var plane = planemap[planetag];
				var pointonplane = plane.normal.times(plane.w);
				var transformation;
				// We need a normal vecrtor for the transformation
				// determine which is more perpendicular to the plane normal: x or y?
				// we will align this as much as possible to the x or y axis vector
				var xorthogonality = plane.normal.cross(xvector).length();
				var yorthogonality = plane.normal.cross(yvector).length();
				if(xorthogonality > yorthogonality) {
					// x is better:
					var planeconnector = new CSG.Connector(pointonplane, plane.normal, xvector);
					transformation = planeconnector.getTransformationTo(z0connectorx, false, 0);
				} else {
					// y is better:
					var planeconnector = new CSG.Connector(pointonplane, plane.normal, yvector);
					transformation = planeconnector.getTransformationTo(z0connectory, false, 0);
				}
				var transformedcsg = csg.transform(transformation);
				var dotz = -plane.normal.dot(zvector);
				var bounds = transformedcsg.getBounds();
				var zheight = bounds[1].z - bounds[0].z;
				var isbetter = isfirst;
				if(!isbetter) {
					if(zheight < minheight) {
						isbetter = true;
					} else if(zheight == minheight) {
						if(dotz > maxdotz) isbetter = true;
					}
				}
				if(isbetter) {
					// translate the transformation around the z-axis and onto the z plane:
					var translation = [
						-0.5 * (bounds[1].x + bounds[0].x),
						-0.5 * (bounds[1].y + bounds[0].y),
						-bounds[0].z];
					transformation = transformation.multiply(CSG.Matrix4x4.translation(translation));
					minheight = zheight;
					maxdotz = dotz;
					besttransformation = transformation;
				}
				isfirst = false;
			}
			return besttransformation;
		}
	},

	lieFlat: function() {
		var transformation = this.getTransformationToFlatLying();
		return this.transform(transformation);
	},

	// project the 3D CSG onto a plane
	// This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the
	// plane represented by the orthonormal basis
	projectToOrthoNormalBasis: function(orthobasis) {
		var cags = [];
		this.polygons.map(function(polygon) {
			var cag = polygon.projectToOrthoNormalBasis(orthobasis);
			if(cag.sides.length > 0) {
				cags.push(cag);
			}
		});
		var result = new CAG().union(cags);
		return result;
	},

	sectionCut: function(orthobasis) {
		var plane1 = orthobasis.plane;
		var plane2 = orthobasis.plane.flipped();
		plane1 = new CSG.Plane(plane1.normal, plane1.w + 1e-4);
		plane2 = new CSG.Plane(plane2.normal, plane2.w + 1e-4);
		var cut3d = this.cutByPlane(plane1);
		cut3d = cut3d.cutByPlane(plane2);
		return cut3d.projectToOrthoNormalBasis(orthobasis);
	},

	/*
  fixTJunctions:

  Suppose we have two polygons ACDB and EDGF:

   A-----B
   |     |
   |     E--F
   |     |  |
   C-----D--G

  Note that vertex E forms a T-junction on the side BD. In this case some STL slicers will complain
  that the solid is not watertight. This is because the watertightness check is done by checking if
  each side DE is matched by another side ED.

  This function will return a new solid with ACDB replaced by ACDEB

  Note that this can create polygons that are slightly non-convex (due to rounding errors). Therefore the result should
  not be used for further CSG operations!
  */
	fixTJunctions: function() {
		var csg = this.canonicalized();
		var sidemap = {};
		for(var polygonindex = 0; polygonindex < csg.polygons.length; polygonindex++) {
			var polygon = csg.polygons[polygonindex];
			var numvertices = polygon.vertices.length;
			if(numvertices >= 3) // should be true
			{
				var vertex = polygon.vertices[0];
				var vertextag = vertex.getTag();
				for(var vertexindex = 0; vertexindex < numvertices; vertexindex++) {
					var nextvertexindex = vertexindex + 1;
					if(nextvertexindex == numvertices) nextvertexindex = 0;
					var nextvertex = polygon.vertices[nextvertexindex];
					var nextvertextag = nextvertex.getTag();
					var sidetag = vertextag + "/" + nextvertextag;
					var reversesidetag = nextvertextag + "/" + vertextag;
					if(reversesidetag in sidemap) {
						// this side matches the same side in another polygon. Remove from sidemap:
						var ar = sidemap[reversesidetag];
						ar.splice(-1, 1);
						if(ar.length === 0) {
							delete sidemap[reversesidetag];
						}
					} else {
						var sideobj = {
							vertex0: vertex,
							vertex1: nextvertex,
							polygonindex: polygonindex
						};
						if(!(sidetag in sidemap)) {
							sidemap[sidetag] = [sideobj];
						} else {
							sidemap[sidetag].push(sideobj);
						}
					}
					vertex = nextvertex;
					vertextag = nextvertextag;
				}
			}
		}
		// now sidemap contains 'unmatched' sides
		// i.e. side AB in one polygon does not have a matching side BA in another polygon
		var vertextag2sidestart = {};
		var vertextag2sideend = {};
		var sidestocheck = {};
		var sidemapisempty = true;
		for(var sidetag in sidemap) {
			sidemapisempty = false;
			sidestocheck[sidetag] = true;
			sidemap[sidetag].map(function(sideobj) {
				var starttag = sideobj.vertex0.getTag();
				var endtag = sideobj.vertex1.getTag();
				if(starttag in vertextag2sidestart) {
					vertextag2sidestart[starttag].push(sidetag);
				} else {
					vertextag2sidestart[starttag] = [sidetag];
				}
				if(endtag in vertextag2sideend) {
					vertextag2sideend[endtag].push(sidetag);
				} else {
					vertextag2sideend[endtag] = [sidetag];
				}
			});
		}

		if(!sidemapisempty) {
			// make a copy of the polygons array, since we are going to modify it:
			var polygons = csg.polygons.slice(0);

			function addSide (vertex0, vertex1, polygonindex) {
				var starttag = vertex0.getTag();
				var endtag = vertex1.getTag();
				if(starttag == endtag) throw new Error("Assertion failed");
				var newsidetag = starttag + "/" + endtag;
				var reversesidetag = endtag + "/" + starttag;
				if(reversesidetag in sidemap) {
					// we have a matching reverse oriented side.
					// Instead of adding the new side, cancel out the reverse side:
					// console.log("addSide("+newsidetag+") has reverse side:");
					deleteSide(vertex1, vertex0, null);
					return null;
				}
				//  console.log("addSide("+newsidetag+")");
				var newsideobj = {
					vertex0: vertex0,
					vertex1: vertex1,
					polygonindex: polygonindex
				};
				if(!(newsidetag in sidemap)) {
					sidemap[newsidetag] = [newsideobj];
				} else {
					sidemap[newsidetag].push(newsideobj);
				}
				if(starttag in vertextag2sidestart) {
					vertextag2sidestart[starttag].push(newsidetag);
				} else {
					vertextag2sidestart[starttag] = [newsidetag];
				}
				if(endtag in vertextag2sideend) {
					vertextag2sideend[endtag].push(newsidetag);
				} else {
					vertextag2sideend[endtag] = [newsidetag];
				}
				return newsidetag;
			}

			function deleteSide (vertex0, vertex1, polygonindex) {
				var starttag = vertex0.getTag();
				var endtag = vertex1.getTag();
				var sidetag = starttag + "/" + endtag;
				// console.log("deleteSide("+sidetag+")");
				if(!(sidetag in sidemap)) throw new Error("Assertion failed");
				var idx = -1;
				var sideobjs = sidemap[sidetag];
				for(var i = 0; i < sideobjs.length; i++) {
					var sideobj = sideobjs[i];
					if(sideobj.vertex0 != vertex0) continue;
					if(sideobj.vertex1 != vertex1) continue;
					if(polygonindex !== null) {
						if(sideobj.polygonindex != polygonindex) continue;
					}
					idx = i;
					break;
				}
				if(idx < 0) throw new Error("Assertion failed");
				sideobjs.splice(idx, 1);
				if(sideobjs.length === 0) {
					delete sidemap[sidetag];
				}
				idx = vertextag2sidestart[starttag].indexOf(sidetag);
				if(idx < 0) throw new Error("Assertion failed");
				vertextag2sidestart[starttag].splice(idx, 1);
				if(vertextag2sidestart[starttag].length === 0) {
					delete vertextag2sidestart[starttag];
				}

				idx = vertextag2sideend[endtag].indexOf(sidetag);
				if(idx < 0) throw new Error("Assertion failed");
				vertextag2sideend[endtag].splice(idx, 1);
				if(vertextag2sideend[endtag].length === 0) {
					delete vertextag2sideend[endtag];
				}
			}


			while(true) {
				var sidemapisempty = true;
				for(var sidetag in sidemap) {
					sidemapisempty = false;
					sidestocheck[sidetag] = true;
				}
				if(sidemapisempty) break;
				var donesomething = false;
				while(true) {
					var sidetagtocheck = null;
					for(var sidetag in sidestocheck) {
						sidetagtocheck = sidetag;
						break;
					}
					if(sidetagtocheck === null) break; // sidestocheck is empty, we're done!
					var donewithside = true;
					if(sidetagtocheck in sidemap) {
						var sideobjs = sidemap[sidetagtocheck];
						if(sideobjs.length === 0) throw new Error("Assertion failed");
						var sideobj = sideobjs[0];
						for(var directionindex = 0; directionindex < 2; directionindex++) {
							var startvertex = (directionindex === 0) ? sideobj.vertex0 : sideobj.vertex1;
							var endvertex = (directionindex === 0) ? sideobj.vertex1 : sideobj.vertex0;
							var startvertextag = startvertex.getTag();
							var endvertextag = endvertex.getTag();
							var matchingsides = [];
							if(directionindex === 0) {
								if(startvertextag in vertextag2sideend) {
									matchingsides = vertextag2sideend[startvertextag];
								}
							} else {
								if(startvertextag in vertextag2sidestart) {
									matchingsides = vertextag2sidestart[startvertextag];
								}
							}
							for(var matchingsideindex = 0; matchingsideindex < matchingsides.length; matchingsideindex++) {
								var matchingsidetag = matchingsides[matchingsideindex];
								var matchingside = sidemap[matchingsidetag][0];
								var matchingsidestartvertex = (directionindex === 0) ? matchingside.vertex0 : matchingside.vertex1;
								var matchingsideendvertex = (directionindex === 0) ? matchingside.vertex1 : matchingside.vertex0;
								var matchingsidestartvertextag = matchingsidestartvertex.getTag();
								var matchingsideendvertextag = matchingsideendvertex.getTag();
								if(matchingsideendvertextag != startvertextag) throw new Error("Assertion failed");
								if(matchingsidestartvertextag == endvertextag) {
									// matchingside cancels sidetagtocheck
									deleteSide(startvertex, endvertex, null);
									deleteSide(endvertex, startvertex, null);
									donewithside = false;
									directionindex = 2; // skip reverse direction check
									donesomething = true;
									break;
								} else {
									var startpos = startvertex.pos;
									var endpos = endvertex.pos;
									var checkpos = matchingsidestartvertex.pos;
									var direction = checkpos.minus(startpos);
									// Now we need to check if endpos is on the line startpos-checkpos:
									var t = endpos.minus(startpos).dot(direction) / direction.dot(direction);
									if((t > 0) && (t < 1)) {
										var closestpoint = startpos.plus(direction.times(t));
										var distancesquared = closestpoint.distanceToSquared(endpos);
										if(distancesquared < 1e-10) {
											// Yes it's a t-junction! We need to split matchingside in two:
											var polygonindex = matchingside.polygonindex;
											var polygon = polygons[polygonindex];
											// find the index of startvertextag in polygon:
											var insertionvertextag = matchingside.vertex1.getTag();
											var insertionvertextagindex = -1;
											for(var i = 0; i < polygon.vertices.length; i++) {
												if(polygon.vertices[i].getTag() == insertionvertextag) {
													insertionvertextagindex = i;
													break;
												}
											}
											if(insertionvertextagindex < 0) throw new Error("Assertion failed");
											// split the side by inserting the vertex:
											var newvertices = polygon.vertices.slice(0);
											newvertices.splice(insertionvertextagindex, 0, endvertex);
											var newpolygon = new CSG.Polygon(newvertices, polygon.shared /*polygon.plane*/ );
											polygons[polygonindex] = newpolygon;

											// remove the original sides from our maps:
											// deleteSide(sideobj.vertex0, sideobj.vertex1, null);
											deleteSide(matchingside.vertex0, matchingside.vertex1, polygonindex);
											var newsidetag1 = addSide(matchingside.vertex0, endvertex, polygonindex);
											var newsidetag2 = addSide(endvertex, matchingside.vertex1, polygonindex);
											if(newsidetag1 !== null) sidestocheck[newsidetag1] = true;
											if(newsidetag2 !== null) sidestocheck[newsidetag2] = true;
											donewithside = false;
											directionindex = 2; // skip reverse direction check
											donesomething = true;
											break;
										} // if(distancesquared < 1e-10)
									} // if( (t > 0) && (t < 1) )
								} // if(endingstidestartvertextag == endvertextag)
							} // for matchingsideindex
						} // for directionindex
					} // if(sidetagtocheck in sidemap)
					if(donewithside) {
						delete sidestocheck[sidetag];
					}
				}
				if(!donesomething) break;
			}
			var newcsg = CSG.fromPolygons(polygons);
			newcsg.properties = csg.properties;
			newcsg.isCanonicalized = true;
			newcsg.isRetesselated = true;
			csg = newcsg;
		} // if(!sidemapisempty)
		var sidemapisempty = true;
		for(var sidetag in sidemap) {
			sidemapisempty = false;
			break;
		}
		if(!sidemapisempty) {
			throw new Error("!sidemapisempty");
		}
		return csg;
	}
};

// Parse an option from the options object
// If the option is not present, return the default value
CSG.parseOption = function(options, optionname, defaultvalue) {
	var result = defaultvalue;
	if(options) {
		if(optionname in options) {
			result = options[optionname];
		}
	}
	return result;
};

// Parse an option and force into a CSG.Vector3D. If a scalar is passed it is converted
// into a vector with equal x,y,z
CSG.parseOptionAs3DVector = function(options, optionname, defaultvalue) {
	var result = CSG.parseOption(options, optionname, defaultvalue);
	result = new CSG.Vector3D(result);
	return result;
};

// Parse an option and force into a CSG.Vector2D. If a scalar is passed it is converted
// into a vector with equal x,y
CSG.parseOptionAs2DVector = function(options, optionname, defaultvalue) {
	var result = CSG.parseOption(options, optionname, defaultvalue);
	result = new CSG.Vector2D(result);
	return result;
};

CSG.parseOptionAsFloat = function(options, optionname, defaultvalue) {
	var result = CSG.parseOption(options, optionname, defaultvalue);
	if(typeof(result) == "string") {
		result = Number(result);
	}
	if(isNaN(result) || typeof(result) != "number") {
		throw new Error("Parameter " + optionname + " should be a number");
	}
	return result;
};

CSG.parseOptionAsInt = function(options, optionname, defaultvalue) {
	var result = CSG.parseOption(options, optionname, defaultvalue);
	result = Number(Math.floor(result));
	if (isNaN(result)) {
		throw new Error("Parameter " + optionname + " should be a number");
	}
	return result;
};

CSG.parseOptionAsBool = function(options, optionname, defaultvalue) {
	var result = CSG.parseOption(options, optionname, defaultvalue);
	if(typeof(result) == "string") {
		if(result == "true") result = true;
		else if(result == "false") result = false;
		else if(result == 0) result = false;
	}
	result = !! result;
	return result;
};

// Construct an axis-aligned solid cuboid.
// Parameters:
//   center: center of cube (default [0,0,0])
//   radius: radius of cube (default [1,1,1]), can be specified as scalar or as 3D vector
//
// Example code:
//
//     var cube = CSG.cube({
//       center: [0, 0, 0],
//       radius: 1
//     });
CSG.cube = function(options) {
	var c = CSG.parseOptionAs3DVector(options, "center", [0, 0, 0]);
	var r = CSG.parseOptionAs3DVector(options, "radius", [1, 1, 1]);
	var result = CSG.fromPolygons([
		[
			[0, 4, 6, 2],
			[-1, 0, 0]
		],
		[
			[1, 3, 7, 5],
			[+1, 0, 0]
		],
		[
			[0, 1, 5, 4],
			[0, -1, 0]
		],
		[
			[2, 6, 7, 3],
			[0, +1, 0]
		],
		[
			[0, 2, 3, 1],
			[0, 0, -1]
		],
		[
			[4, 5, 7, 6],
			[0, 0, +1]
		]
	].map(function(info) {
		//var normal = new CSG.Vector3D(info[1]);
		//var plane = new CSG.Plane(normal, 1);
		var vertices = info[0].map(function(i) {
			var pos = new CSG.Vector3D(
			c.x + r.x * (2 * !! (i & 1) - 1), c.y + r.y * (2 * !! (i & 2) - 1), c.z + r.z * (2 * !! (i & 4) - 1));
			return new CSG.Vertex(pos);
		});
		return new CSG.Polygon(vertices, null /* , plane */ );
	}));
	result.properties.cube = new CSG.Properties();
	result.properties.cube.center = new CSG.Vector3D(c);
	// add 6 connectors, at the centers of each face:
	result.properties.cube.facecenters = [
		new CSG.Connector(new CSG.Vector3D([r.x, 0, 0]).plus(c), [1, 0, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([-r.x, 0, 0]).plus(c), [-1, 0, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([0, r.y, 0]).plus(c), [0, 1, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([0, -r.y, 0]).plus(c), [0, -1, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([0, 0, r.z]).plus(c), [0, 0, 1], [1, 0, 0]),
		new CSG.Connector(new CSG.Vector3D([0, 0, -r.z]).plus(c), [0, 0, -1], [1, 0, 0])
	];
	return result;
};

// Construct a solid sphere
//
// Parameters:
//   center: center of sphere (default [0,0,0])
//   radius: radius of sphere (default 1), must be a scalar
//   resolution: determines the number of polygons per 360 degree revolution (default 12)
//   axes: (optional) an array with 3 vectors for the x, y and z base vectors
//
// Example usage:
//
//     var sphere = CSG.sphere({
//       center: [0, 0, 0],
//       radius: 2,
//       resolution: 32,
//     });
CSG.sphere = function(options) {
	options = options || {};
	var center = CSG.parseOptionAs3DVector(options, "center", [0, 0, 0]);
	var radius = CSG.parseOptionAsFloat(options, "radius", 1);
	var resolution = CSG.parseOptionAsInt(options, "resolution", CSG.defaultResolution3D);
	var xvector, yvector, zvector;
	if('axes' in options) {
		xvector = options.axes[0].unit().times(radius);
		yvector = options.axes[1].unit().times(radius);
		zvector = options.axes[2].unit().times(radius);
	} else {
		xvector = new CSG.Vector3D([1, 0, 0]).times(radius);
		yvector = new CSG.Vector3D([0, -1, 0]).times(radius);
		zvector = new CSG.Vector3D([0, 0, 1]).times(radius);
	}
	if(resolution < 4) resolution = 4;
	var qresolution = Math.round(resolution / 4);
	var prevcylinderpoint;
	var polygons = [];
	for(var slice1 = 0; slice1 <= resolution; slice1++) {
		var angle = Math.PI * 2.0 * slice1 / resolution;
		var cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));
		if(slice1 > 0) {
			// cylinder vertices:
			var vertices = [];
			var prevcospitch, prevsinpitch;
			for(var slice2 = 0; slice2 <= qresolution; slice2++) {
				var pitch = 0.5 * Math.PI * slice2 / qresolution;
				var cospitch = Math.cos(pitch);
				var sinpitch = Math.sin(pitch);
				if(slice2 > 0) {
					vertices = [];
					vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
					vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
					if(slice2 < qresolution) {
						vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
					}
					vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
					polygons.push(new CSG.Polygon(vertices));
					vertices = [];
					vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
					vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
					if(slice2 < qresolution) {
						vertices.push(new CSG.Vertex(center.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
					}
					vertices.push(new CSG.Vertex(center.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
					vertices.reverse();
					polygons.push(new CSG.Polygon(vertices));
				}
				prevcospitch = cospitch;
				prevsinpitch = sinpitch;
			}
		}
		prevcylinderpoint = cylinderpoint;
	}
	var result = CSG.fromPolygons(polygons);
	result.properties.sphere = new CSG.Properties();
	result.properties.sphere.center = new CSG.Vector3D(center);
	result.properties.sphere.facepoint = center.plus(xvector);
	return result;
};

// Construct a solid cylinder.
//
// Parameters:
//   start: start point of cylinder (default [0, -1, 0])
//   end: end point of cylinder (default [0, 1, 0])
//   radius: radius of cylinder (default 1), must be a scalar
//   resolution: determines the number of polygons per 360 degree revolution (default 12)
//
// Example usage:
//
//     var cylinder = CSG.cylinder({
//       start: [0, -1, 0],
//       end: [0, 1, 0],
//       radius: 1,
//       resolution: 16
//     });
CSG.cylinder = function(options) {
	var s = CSG.parseOptionAs3DVector(options, "start", [0, -1, 0]);
	var e = CSG.parseOptionAs3DVector(options, "end", [0, 1, 0]);
	var r = CSG.parseOptionAsFloat(options, "radius", 1);
	var rEnd = CSG.parseOptionAsFloat(options, "radiusEnd", r);
	var rStart = CSG.parseOptionAsFloat(options, "radiusStart", r);

	if((rEnd < 0) || (rStart < 0)) {
		throw new Error("Radius should be non-negative");
	}
	if((rEnd === 0) && (rStart === 0)) {
		throw new Error("Either radiusStart or radiusEnd should be positive");
	}

	var slices = CSG.parseOptionAsInt(options, "resolution", CSG.defaultResolution2D);
	var ray = e.minus(s);
	var axisZ = ray.unit(); //, isY = (Math.abs(axisZ.y) > 0.5);
	var axisX = axisZ.randomNonParallelVector().unit();

	//  var axisX = new CSG.Vector3D(isY, !isY, 0).cross(axisZ).unit();
	var axisY = axisX.cross(axisZ).unit();
	var start = new CSG.Vertex(s);
	var end = new CSG.Vertex(e);
	var polygons = [];

	function point(stack, slice, radius) {
		var angle = slice * Math.PI * 2;
		var out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));
		var pos = s.plus(ray.times(stack)).plus(out.times(radius));
		return new CSG.Vertex(pos);
	}
	for(var i = 0; i < slices; i++) {
		var t0 = i / slices,
			t1 = (i + 1) / slices;
		if(rEnd == rStart) {
			polygons.push(new CSG.Polygon([start, point(0, t0, rEnd), point(0, t1, rEnd)]));
			polygons.push(new CSG.Polygon([point(0, t1, rEnd), point(0, t0, rEnd), point(1, t0, rEnd), point(1, t1, rEnd)]));
			polygons.push(new CSG.Polygon([end, point(1, t1, rEnd), point(1, t0, rEnd)]));
		} else {
			if(rStart > 0) {
				polygons.push(new CSG.Polygon([start, point(0, t0, rStart), point(0, t1, rStart)]));
				polygons.push(new CSG.Polygon([point(0, t0, rStart), point(1, t0, rEnd), point(0, t1, rStart)]));
			}
			if(rEnd > 0) {
				polygons.push(new CSG.Polygon([end, point(1, t1, rEnd), point(1, t0, rEnd)]));
				polygons.push(new CSG.Polygon([point(1, t0, rEnd), point(1, t1, rEnd), point(0, t1, rStart)]));
			}
		}
	}
	var result = CSG.fromPolygons(polygons);
	result.properties.cylinder = new CSG.Properties();
	result.properties.cylinder.start = new CSG.Connector(s, axisZ.negated(), axisX);
	result.properties.cylinder.end = new CSG.Connector(e, axisZ, axisX);
	result.properties.cylinder.facepoint = s.plus(axisX.times(rStart));
	return result;
};

// Like a cylinder, but with rounded ends instead of flat
//
// Parameters:
//   start: start point of cylinder (default [0, -1, 0])
//   end: end point of cylinder (default [0, 1, 0])
//   radius: radius of cylinder (default 1), must be a scalar
//   resolution: determines the number of polygons per 360 degree revolution (default 12)
//   normal: a vector determining the starting angle for tesselation. Should be non-parallel to start.minus(end)
//
// Example usage:
//
//     var cylinder = CSG.roundedCylinder({
//       start: [0, -1, 0],
//       end: [0, 1, 0],
//       radius: 1,
//       resolution: 16
//     });
CSG.roundedCylinder = function(options) {
	var p1 = CSG.parseOptionAs3DVector(options, "start", [0, -1, 0]);
	var p2 = CSG.parseOptionAs3DVector(options, "end", [0, 1, 0]);
	var radius = CSG.parseOptionAsFloat(options, "radius", 1);
	var direction = p2.minus(p1);
	var defaultnormal;
	if(Math.abs(direction.x) > Math.abs(direction.y)) {
		defaultnormal = new CSG.Vector3D(0, 1, 0);
	} else {
		defaultnormal = new CSG.Vector3D(1, 0, 0);
	}
	var normal = CSG.parseOptionAs3DVector(options, "normal", defaultnormal);
	var resolution = CSG.parseOptionAsInt(options, "resolution", CSG.defaultResolution3D);
	if(resolution < 4) resolution = 4;
	var polygons = [];
	var qresolution = Math.floor(0.25 * resolution);
	var length = direction.length();
	if(length < 1e-10) {
		return CSG.sphere({
			center: p1,
			radius: radius,
			resolution: resolution
		});
	}
	var zvector = direction.unit().times(radius);
	var xvector = zvector.cross(normal).unit().times(radius);
	var yvector = xvector.cross(zvector).unit().times(radius);
	var prevcylinderpoint;
	for(var slice1 = 0; slice1 <= resolution; slice1++) {
		var angle = Math.PI * 2.0 * slice1 / resolution;
		var cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));
		if(slice1 > 0) {
			// cylinder vertices:
			var vertices = [];
			vertices.push(new CSG.Vertex(p1.plus(cylinderpoint)));
			vertices.push(new CSG.Vertex(p1.plus(prevcylinderpoint)));
			vertices.push(new CSG.Vertex(p2.plus(prevcylinderpoint)));
			vertices.push(new CSG.Vertex(p2.plus(cylinderpoint)));
			polygons.push(new CSG.Polygon(vertices));
			var prevcospitch, prevsinpitch;
			for(var slice2 = 0; slice2 <= qresolution; slice2++) {
				var pitch = 0.5 * Math.PI * slice2 / qresolution;
				//var pitch = Math.asin(slice2/qresolution);
				var cospitch = Math.cos(pitch);
				var sinpitch = Math.sin(pitch);
				if(slice2 > 0) {
					vertices = [];
					vertices.push(new CSG.Vertex(p1.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
					vertices.push(new CSG.Vertex(p1.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));
					if(slice2 < qresolution) {
						vertices.push(new CSG.Vertex(p1.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
					}
					vertices.push(new CSG.Vertex(p1.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));
					polygons.push(new CSG.Polygon(vertices));
					vertices = [];
					vertices.push(new CSG.Vertex(p2.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
					vertices.push(new CSG.Vertex(p2.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));
					if(slice2 < qresolution) {
						vertices.push(new CSG.Vertex(p2.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
					}
					vertices.push(new CSG.Vertex(p2.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));
					vertices.reverse();
					polygons.push(new CSG.Polygon(vertices));
				}
				prevcospitch = cospitch;
				prevsinpitch = sinpitch;
			}
		}
		prevcylinderpoint = cylinderpoint;
	}
	var result = CSG.fromPolygons(polygons);
	var ray = zvector.unit();
	var axisX = xvector.unit();
	result.properties.roundedCylinder = new CSG.Properties();
	result.properties.roundedCylinder.start = new CSG.Connector(p1, ray.negated(), axisX);
	result.properties.roundedCylinder.end = new CSG.Connector(p2, ray, axisX);
	result.properties.roundedCylinder.facepoint = p1.plus(xvector);
	return result;
};

// Construct an axis-aligned solid rounded cuboid.
// Parameters:
//   center: center of cube (default [0,0,0])
//   radius: radius of cube (default [1,1,1]), can be specified as scalar or as 3D vector
//   roundradius: radius of rounded corners (default 0.2), must be a scalar
//   resolution: determines the number of polygons per 360 degree revolution (default 8)
//
// Example code:
//
//     var cube = CSG.roundedCube({
//       center: [0, 0, 0],
//       radius: 1,
//       roundradius: 0.2,
//       resolution: 8,
//     });
CSG.roundedCube = function(options) {
	var center = CSG.parseOptionAs3DVector(options, "center", [0, 0, 0]);
	var cuberadius = CSG.parseOptionAs3DVector(options, "radius", [1, 1, 1]);
	var resolution = CSG.parseOptionAsInt(options, "resolution", CSG.defaultResolution3D);
	if(resolution < 4) resolution = 4;
	var roundradius = CSG.parseOptionAsFloat(options, "roundradius", 0.2);
	var innercuberadius = cuberadius;
	innercuberadius = innercuberadius.minus(new CSG.Vector3D(roundradius));
	var result = CSG.cube({
		center: center,
		radius: [cuberadius.x, innercuberadius.y, innercuberadius.z]
	});
	result = result.unionSub(CSG.cube({
		center: center,
		radius: [innercuberadius.x, cuberadius.y, innercuberadius.z]
	}), false, false);
	result = result.unionSub(CSG.cube({
		center: center,
		radius: [innercuberadius.x, innercuberadius.y, cuberadius.z]
	}), false, false);
	for(var level = 0; level < 2; level++) {
		var z = innercuberadius.z;
		if(level == 1) z = -z;
		var p1 = new CSG.Vector3D(innercuberadius.x, innercuberadius.y, z).plus(center);
		var p2 = new CSG.Vector3D(innercuberadius.x, -innercuberadius.y, z).plus(center);
		var p3 = new CSG.Vector3D(-innercuberadius.x, -innercuberadius.y, z).plus(center);
		var p4 = new CSG.Vector3D(-innercuberadius.x, innercuberadius.y, z).plus(center);
		var sphere = CSG.sphere({
			center: p1,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(sphere, false, false);
		sphere = CSG.sphere({
			center: p2,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(sphere, false, false);
		sphere = CSG.sphere({
			center: p3,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(sphere, false, false);
		sphere = CSG.sphere({
			center: p4,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(sphere, false, true);
		var cylinder = CSG.cylinder({
			start: p1,
			end: p2,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(cylinder, false, false);
		cylinder = CSG.cylinder({
			start: p2,
			end: p3,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(cylinder, false, false);
		cylinder = CSG.cylinder({
			start: p3,
			end: p4,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(cylinder, false, false);
		cylinder = CSG.cylinder({
			start: p4,
			end: p1,
			radius: roundradius,
			resolution: resolution
		});
		result = result.unionSub(cylinder, false, false);
		if(level === 0) {
			var d = new CSG.Vector3D(0, 0, -2 * z);
			cylinder = CSG.cylinder({
				start: p1,
				end: p1.plus(d),
				radius: roundradius,
				resolution: resolution
			});
			result = result.unionSub(cylinder);
			cylinder = CSG.cylinder({
				start: p2,
				end: p2.plus(d),
				radius: roundradius,
				resolution: resolution
			});
			result = result.unionSub(cylinder);
			cylinder = CSG.cylinder({
				start: p3,
				end: p3.plus(d),
				radius: roundradius,
				resolution: resolution
			});
			result = result.unionSub(cylinder);
			cylinder = CSG.cylinder({
				start: p4,
				end: p4.plus(d),
				radius: roundradius,
				resolution: resolution
			});
			result = result.unionSub(cylinder, false, true);
		}
	}
	result = result.reTesselated();
	result.properties.roundedCube = new CSG.Properties();
	result.properties.roundedCube.center = new CSG.Vertex(center);
	result.properties.roundedCube.facecenters = [
		new CSG.Connector(new CSG.Vector3D([cuberadius.x, 0, 0]).plus(center), [1, 0, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([-cuberadius.x, 0, 0]).plus(center), [-1, 0, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([0, cuberadius.y, 0]).plus(center), [0, 1, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([0, -cuberadius.y, 0]).plus(center), [0, -1, 0], [0, 0, 1]),
		new CSG.Connector(new CSG.Vector3D([0, 0, cuberadius.z]).plus(center), [0, 0, 1], [1, 0, 0]),
		new CSG.Connector(new CSG.Vector3D([0, 0, -cuberadius.z]).plus(center), [0, 0, -1], [1, 0, 0])];
	return result;
};

CSG.IsFloat = function(n) {
	return(!isNaN(n)) || (n === Infinity) || (n === -Infinity);
};

// solve 2x2 linear equation:
// [ab][x] = [u]
// [cd][y]   [v]
CSG.solve2Linear = function(a, b, c, d, u, v) {
	var det = a * d - b * c;
	var invdet = 1.0 / det;
	var x = u * d - b * v;
	var y = -u * c + a * v;
	x *= invdet;
	y *= invdet;
	return [x, y];
};

// # class Vector3D
// Represents a 3D vector.
//
// Example usage:
//
//     new CSG.Vector3D(1, 2, 3);
//     new CSG.Vector3D([1, 2, 3]);
//     new CSG.Vector3D({ x: 1, y: 2, z: 3 });
//     new CSG.Vector3D(1, 2); // assumes z=0
//     new CSG.Vector3D([1, 2]); // assumes z=0
CSG.Vector3D = function(x, y, z) {
	if(arguments.length == 3) {
		this._x = parseFloat(x);
		this._y = parseFloat(y);
		this._z = parseFloat(z);
	} else if(arguments.length == 2) {
		this._x = parseFloat(x);
		this._y = parseFloat(y);
		this._z = 0;
	} else {
		var ok = true;
		if(arguments.length == 1) {
			if(typeof(x) == "object") {
				if(x instanceof CSG.Vector3D) {
					this._x = x._x;
					this._y = x._y;
					this._z = x._z;
				} else if(x instanceof CSG.Vector2D) {
					this._x = x._x;
					this._y = x._y;
					this._z = 0;
				} else if(x instanceof Array) {
					if((x.length < 2) || (x.length > 3)) {
						ok = false;
					} else {
						this._x = parseFloat(x[0]);
						this._y = parseFloat(x[1]);
						if(x.length == 3) {
							this._z = parseFloat(x[2]);
						} else {
							this._z = 0;
						}
					}
				} else if(('x' in x) && ('y' in x)) {
					this._x = parseFloat(x.x);
					this._y = parseFloat(x.y);
					if('z' in x) {
						this._z = parseFloat(x.z);
					} else {
						this._z = 0;
					}
				} else ok = false;
			} else {
				var v = parseFloat(x);
				this._x = v;
				this._y = v;
				this._z = v;
			}
		} else ok = false;
		if(ok) {
			if((!CSG.IsFloat(this._x)) || (!CSG.IsFloat(this._y)) || (!CSG.IsFloat(this._z))) ok = false;
		}
		if(!ok) {
			throw new Error("wrong arguments");
		}
	}
};

CSG.Vector3D.prototype = {
	get x() {
		return this._x;
	}, get y() {
		return this._y;
	}, get z() {
		return this._z;
	},

	set x(v) {
		throw new Error("Vector3D is immutable");
	}, set y(v) {
		throw new Error("Vector3D is immutable");
	}, set z(v) {
		throw new Error("Vector3D is immutable");
	},

	clone: function() {
		return new CSG.Vector3D(this);
	},

	negated: function() {
		return new CSG.Vector3D(-this._x, -this._y, -this._z);
	},

	abs: function() {
		return new CSG.Vector3D(Math.abs(this._x), Math.abs(this._y), Math.abs(this._z));
	},

	plus: function(a) {
		return new CSG.Vector3D(this._x + a._x, this._y + a._y, this._z + a._z);
	},

	minus: function(a) {
		return new CSG.Vector3D(this._x - a._x, this._y - a._y, this._z - a._z);
	},

	times: function(a) {
		return new CSG.Vector3D(this._x * a, this._y * a, this._z * a);
	},

	dividedBy: function(a) {
		return new CSG.Vector3D(this._x / a, this._y / a, this._z / a);
	},

	dot: function(a) {
		return this._x * a._x + this._y * a._y + this._z * a._z;
	},

	lerp: function(a, t) {
		return this.plus(a.minus(this).times(t));
	},

	lengthSquared: function() {
		return this.dot(this);
	},

	length: function() {
		return Math.sqrt(this.lengthSquared());
	},

	unit: function() {
		return this.dividedBy(this.length());
	},

	cross: function(a) {
		return new CSG.Vector3D(
		this._y * a._z - this._z * a._y, this._z * a._x - this._x * a._z, this._x * a._y - this._y * a._x);
	},

	distanceTo: function(a) {
		return this.minus(a).length();
	},

	distanceToSquared: function(a) {
		return this.minus(a).lengthSquared();
	},

	equals: function(a) {
		return(this._x == a._x) && (this._y == a._y) && (this._z == a._z);
	},

	// Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)
	// Returns a new CSG.Vector3D
	multiply4x4: function(matrix4x4) {
		return matrix4x4.leftMultiply1x3Vector(this);
	},

	transform: function(matrix4x4) {
		return matrix4x4.leftMultiply1x3Vector(this);
	},

	toStlString: function() {
		return this._x + " " + this._y + " " + this._z;
	},

	toAMFString: function() {
		return "<x>" + this._x + "</x><y>" + this._y + "</y><z>" + this._z + "</z>";
	},

	toString: function() {
		return "(" + this._x.toFixed(2) + ", " + this._y.toFixed(2) + ", " + this._z.toFixed(2) + ")";
	},

	// find a vector that is somewhat perpendicular to this one
	randomNonParallelVector: function() {
		var abs = this.abs();
		if((abs._x <= abs._y) && (abs._x <= abs._z)) {
			return new CSG.Vector3D(1, 0, 0);
		} else if((abs._y <= abs._x) && (abs._y <= abs._z)) {
			return new CSG.Vector3D(0, 1, 0);
		} else {
			return new CSG.Vector3D(0, 0, 1);
		}
	},

	min: function(p) {
		return new CSG.Vector3D(
		Math.min(this._x, p._x), Math.min(this._y, p._y), Math.min(this._z, p._z));
	},

	max: function(p) {
		return new CSG.Vector3D(
		Math.max(this._x, p._x), Math.max(this._y, p._y), Math.max(this._z, p._z));
	}
};

// # class Vertex
// Represents a vertex of a polygon. Use your own vertex class instead of this
// one to provide additional features like texture coordinates and vertex
// colors. Custom vertex classes need to provide a `pos` property
// `flipped()`, and `interpolate()` methods that behave analogous to the ones
// defined by `CSG.Vertex`.
CSG.Vertex = function(pos) {
	this.pos = pos;
};

// create from an untyped object with identical property names:
CSG.Vertex.fromObject = function(obj) {
	var pos = new CSG.Vector3D(obj.pos);
	return new CSG.Vertex(pos);
};

CSG.Vertex.prototype = {
	// Return a vertex with all orientation-specific data (e.g. vertex normal) flipped. Called when the
	// orientation of a polygon is flipped.
	flipped: function() {
		return this;
	},

	getTag: function() {
		var result = this.tag;
		if(!result) {
			result = CSG.getTag();
			this.tag = result;
		}
		return result;
	},

	// Create a new vertex between this vertex and `other` by linearly
	// interpolating all properties using a parameter of `t`. Subclasses should
	// override this to interpolate additional properties.
	interpolate: function(other, t) {
		var newpos = this.pos.lerp(other.pos, t);
		return new CSG.Vertex(newpos);
	},

	// Affine transformation of vertex. Returns a new CSG.Vertex
	transform: function(matrix4x4) {
		var newpos = this.pos.multiply4x4(matrix4x4);
		return new CSG.Vertex(newpos);
	},

	toStlString: function() {
		return "vertex " + this.pos.toStlString() + "\n";
	},

	toAMFString: function() {
		return "<vertex><coordinates>" + this.pos.toAMFString() + "</coordinates></vertex>\n";
	},

	toString: function() {
		return this.pos.toString();
	}
};

// # class Plane
// Represents a plane in 3D space.
CSG.Plane = function(normal, w) {
	this.normal = normal;
	this.w = w;
};

// create from an untyped object with identical property names:
CSG.Plane.fromObject = function(obj) {
	var normal = new CSG.Vector3D(obj.normal);
	var w = parseFloat(obj.w);
	return new CSG.Plane(normal, w);
};

// `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a
// point is on the plane.
CSG.Plane.EPSILON = 1e-5;

CSG.Plane.fromVector3Ds = function(a, b, c) {
	var n = b.minus(a).cross(c.minus(a)).unit();
	return new CSG.Plane(n, n.dot(a));
};

// like fromVector3Ds, but allow the vectors to be on one point or one line
// in such a case a random plane through the given points is constructed
CSG.Plane.anyPlaneFromVector3Ds = function(a, b, c) {
	var v1 = b.minus(a);
	var v2 = c.minus(a);
	if(v1.length() < 1e-5) {
		v1 = v2.randomNonParallelVector();
	}
	if(v2.length() < 1e-5) {
		v2 = v1.randomNonParallelVector();
	}
	var normal = v1.cross(v2);
	if(normal.length() < 1e-5) {
		// this would mean that v1 == v2.negated()
		v2 = v1.randomNonParallelVector();
		normal = v1.cross(v2);
	}
	normal = normal.unit();
	return new CSG.Plane(normal, normal.dot(a));
};

CSG.Plane.fromPoints = function(a, b, c) {
	a = new CSG.Vector3D(a);
	b = new CSG.Vector3D(b);
	c = new CSG.Vector3D(c);
	return CSG.Plane.fromVector3Ds(a, b, c);
};

CSG.Plane.fromNormalAndPoint = function(normal, point) {
	normal = new CSG.Vector3D(normal);
	point = new CSG.Vector3D(point);
	normal = normal.unit();
	var w = point.dot(normal);
	return new CSG.Plane(normal, w);
};

CSG.Plane.prototype = {
	flipped: function() {
		return new CSG.Plane(this.normal.negated(), -this.w);
	},

	getTag: function() {
		var result = this.tag;
		if(!result) {
			result = CSG.getTag();
			this.tag = result;
		}
		return result;
	},

	equals: function(n) {
		return this.normal.equals(n.normal) && this.w == n.w;
	},

	transform: function(matrix4x4) {
		var ismirror = matrix4x4.isMirroring();
		// get two vectors in the plane:
		var r = this.normal.randomNonParallelVector();
		var u = this.normal.cross(r);
		var v = this.normal.cross(u);
		// get 3 points in the plane:
		var point1 = this.normal.times(this.w);
		var point2 = point1.plus(u);
		var point3 = point1.plus(v);
		// transform the points:
		point1 = point1.multiply4x4(matrix4x4);
		point2 = point2.multiply4x4(matrix4x4);
		point3 = point3.multiply4x4(matrix4x4);
		// and create a new plane from the transformed points:
		var newplane = CSG.Plane.fromVector3Ds(point1, point2, point3);
		if(ismirror) {
			// the transform is mirroring
			// We should mirror the plane:
			newplane = newplane.flipped();
		}
		return newplane;
	},

	// Returns object:
	// .type:
	//   0: coplanar-front
	//   1: coplanar-back
	//   2: front
	//   3: back
	//   4: spanning
	// In case the polygon is spanning, returns:
	// .front: a CSG.Polygon of the front part
	// .back: a CSG.Polygon of the back part
	splitPolygon: function(polygon) {
		var result = {
			type: null,
			front: null,
			back: null
		};
		// cache in local vars (speedup):
		var planenormal = this.normal;
		var vertices = polygon.vertices;
		var numvertices = vertices.length;
		if(polygon.plane.equals(this)) {
			result.type = 0;
		} else {
			var EPS = CSG.Plane.EPSILON;
			var thisw = this.w;
			var hasfront = false;
			var hasback = false;
			var vertexIsBack = [];
			var MINEPS = -EPS;
			for(var i = 0; i < numvertices; i++) {
				var t = planenormal.dot(vertices[i].pos) - thisw;
				var isback = (t < 0);
				vertexIsBack.push(isback);
				if(t > EPS) hasfront = true;
				if(t < MINEPS) hasback = true;
			}
			if((!hasfront) && (!hasback)) {
				// all points coplanar
				var t = planenormal.dot(polygon.plane.normal);
				result.type = (t >= 0) ? 0 : 1;
			} else if(!hasback) {
				result.type = 2;
			} else if(!hasfront) {
				result.type = 3;
			} else {
				// spanning
				result.type = 4;
				var frontvertices = [],
					backvertices = [];
				var isback = vertexIsBack[0];
				for(var vertexindex = 0; vertexindex < numvertices; vertexindex++) {
					var vertex = vertices[vertexindex];
					var nextvertexindex = vertexindex + 1;
					if(nextvertexindex >= numvertices) nextvertexindex = 0;
					var nextisback = vertexIsBack[nextvertexindex];
					if(isback == nextisback) {
						// line segment is on one side of the plane:
						if(isback) {
							backvertices.push(vertex);
						} else {
							frontvertices.push(vertex);
						}
					} else {
						// line segment intersects plane:
						var point = vertex.pos;
						var nextpoint = vertices[nextvertexindex].pos;
						var intersectionpoint = this.splitLineBetweenPoints(point, nextpoint);
						var intersectionvertex = new CSG.Vertex(intersectionpoint);
						if(isback) {
							backvertices.push(vertex);
							backvertices.push(intersectionvertex);
							frontvertices.push(intersectionvertex);
						} else {
							frontvertices.push(vertex);
							frontvertices.push(intersectionvertex);
							backvertices.push(intersectionvertex);
						}
					}
					isback = nextisback;
				} // for vertexindex
				// remove duplicate vertices:
				var EPS_SQUARED = CSG.Plane.EPSILON * CSG.Plane.EPSILON;
				if(backvertices.length >= 3) {
					var prevvertex = backvertices[backvertices.length - 1];
					for(var vertexindex = 0; vertexindex < backvertices.length; vertexindex++) {
						var vertex = backvertices[vertexindex];
						if(vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {
							backvertices.splice(vertexindex, 1);
							vertexindex--;
						}
						prevvertex = vertex;
					}
				}
				if(frontvertices.length >= 3) {
					var prevvertex = frontvertices[frontvertices.length - 1];
					for(var vertexindex = 0; vertexindex < frontvertices.length; vertexindex++) {
						var vertex = frontvertices[vertexindex];
						if(vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {
							frontvertices.splice(vertexindex, 1);
							vertexindex--;
						}
						prevvertex = vertex;
					}
				}
				if(frontvertices.length >= 3) {
					result.front = new CSG.Polygon(frontvertices, polygon.shared, polygon.plane);
				}
				if(backvertices.length >= 3) {
					result.back = new CSG.Polygon(backvertices, polygon.shared, polygon.plane);
				}
			}
		}
		return result;
	},

	// robust splitting of a line by a plane
	// will work even if the line is parallel to the plane
	splitLineBetweenPoints: function(p1, p2) {
		var direction = p2.minus(p1);
		var labda = (this.w - this.normal.dot(p1)) / this.normal.dot(direction);
		if(isNaN(labda)) labda = 0;
		if(labda > 1) labda = 1;
		if(labda < 0) labda = 0;
		var result = p1.plus(direction.times(labda));
		return result;
	},

	// returns CSG.Vector3D
	intersectWithLine: function(line3d) {
		return line3d.intersectWithPlane(this);
	},

	// intersection of two planes
	intersectWithPlane: function(plane) {
		return CSG.Line3D.fromPlanes(this, plane);
	},

	signedDistanceToPoint: function(point) {
		var t = this.normal.dot(point) - this.w;
		return t;
	},

	toString: function() {
		return "[normal: " + this.normal.toString() + ", w: " + this.w + "]";
	},

	mirrorPoint: function(point3d) {
		var distance = this.signedDistanceToPoint(point3d);
		var mirrored = point3d.minus(this.normal.times(distance * 2.0));
		return mirrored;
	}
};


// # class Polygon
// Represents a convex polygon. The vertices used to initialize a polygon must
// be coplanar and form a convex loop. They do not have to be `CSG.Vertex`
// instances but they must behave similarly (duck typing can be used for
// customization).
//
// Each convex polygon has a `shared` property, which is shared between all
// polygons that are clones of each other or were split from the same polygon.
// This can be used to define per-polygon properties (such as surface color).
//
// The plane of the polygon is calculated from the vertex coordinates
// To avoid unnecessary recalculation, the plane can alternatively be
// passed as the third argument
CSG.Polygon = function(vertices, shared, plane) {
	this.vertices = vertices;
	if(!shared) shared = CSG.Polygon.defaultShared;
	this.shared = shared;
	//var numvertices = vertices.length;

	if(arguments.length >= 3) {
		this.plane = plane;
	} else {
		this.plane = CSG.Plane.fromVector3Ds(vertices[0].pos, vertices[1].pos, vertices[2].pos);
	}

	if(_CSGDEBUG) {
		this.checkIfConvex();
	}
};

// create from an untyped object with identical property names:
CSG.Polygon.fromObject = function(obj) {
	var vertices = obj.vertices.map(function(v) {
		return CSG.Vertex.fromObject(v);
	});
	var shared = CSG.Polygon.Shared.fromObject(obj.shared);
	var plane = CSG.Plane.fromObject(obj.plane);
	return new CSG.Polygon(vertices, shared, plane);
};

CSG.Polygon.prototype = {
	// check whether the polygon is convex (it should be, otherwise we will get unexpected results)
	checkIfConvex: function() {
		if(!CSG.Polygon.verticesConvex(this.vertices, this.plane.normal)) {
			CSG.Polygon.verticesConvex(this.vertices, this.plane.normal);
			throw new Error("Not convex!");
		}
	},

	/**
	 * @param {Array} color [red, green, blue, alpha] color values are float numbers 0..1
	 * @return {CSG.Polygon} The current polygon
	 */
	setColor: function(red, green, blue, alpha) {
		var color = red instanceof Array ? red : [red||0, green||0, blue||0, isNaN(alpha) ? 1. : alpha];
		this.shared = new CSG.Polygon.Shared(color);
		return this;
	},

	// Extrude a polygon into the direction offsetvector
	// Returns a CSG object
	extrude: function(offsetvector) {
		var newpolygons = [];

		var polygon1 = this;
		var direction = polygon1.plane.normal.dot(offsetvector);
		if(direction > 0) {
			polygon1 = polygon1.flipped();
		}
		newpolygons.push(polygon1);
		var polygon2 = polygon1.translate(offsetvector);
		var numvertices = this.vertices.length;
		for(var i = 0; i < numvertices; i++) {
			var sidefacepoints = [];
			var nexti = (i < (numvertices - 1)) ? i + 1 : 0;
			sidefacepoints.push(polygon1.vertices[i].pos);
			sidefacepoints.push(polygon2.vertices[i].pos);
			sidefacepoints.push(polygon2.vertices[nexti].pos);
			sidefacepoints.push(polygon1.vertices[nexti].pos);
			var sidefacepolygon = CSG.Polygon.createFromPoints(sidefacepoints, this.shared);
			newpolygons.push(sidefacepolygon);
		}
		polygon2 = polygon2.flipped();
		newpolygons.push(polygon2);
		return CSG.fromPolygons(newpolygons);
	},

	translate: function(offset) {
		return this.transform(CSG.Matrix4x4.translation(offset));
	},

	// returns an array with a CSG.Vector3D (center point) and a radius
	boundingSphere: function() {
		if(!this.cachedBoundingSphere) {
			var box = this.boundingBox();
			var middle = box[0].plus(box[1]).times(0.5);
			var radius3 = box[1].minus(middle);
			var radius = radius3.length();
			this.cachedBoundingSphere = [middle, radius];
		}
		return this.cachedBoundingSphere;
	},

	// returns an array of two CSG.Vector3Ds (minimum coordinates and maximum coordinates)
	boundingBox: function() {
		if(!this.cachedBoundingBox) {
			var minpoint, maxpoint;
			var vertices = this.vertices;
			var numvertices = vertices.length;
			if(numvertices === 0) {
				minpoint = new CSG.Vector3D(0, 0, 0);
			} else {
				minpoint = vertices[0].pos;
			}
			maxpoint = minpoint;
			for(var i = 1; i < numvertices; i++) {
				var point = vertices[i].pos;
				minpoint = minpoint.min(point);
				maxpoint = maxpoint.max(point);
			}
			this.cachedBoundingBox = [minpoint, maxpoint];
		}
		return this.cachedBoundingBox;
	},

	flipped: function() {
		var newvertices = this.vertices.map(function(v) {
			return v.flipped();
		});
		newvertices.reverse();
		var newplane = this.plane.flipped();
		return new CSG.Polygon(newvertices, this.shared, newplane);
	},

	// Affine transformation of polygon. Returns a new CSG.Polygon
	transform: function(matrix4x4) {
		var newvertices = this.vertices.map(function(v) {
			return v.transform(matrix4x4);
		});
		var newplane = this.plane.transform(matrix4x4);
		var scalefactor = matrix4x4.elements[0] * matrix4x4.elements[5] * matrix4x4.elements[10];
		if(scalefactor < 0) {
			// the transformation includes mirroring. We need to reverse the vertex order
			// in order to preserve the inside/outside orientation:
			newvertices.reverse();
		}
		return new CSG.Polygon(newvertices, this.shared, newplane);
	},

	toStlString: function() {
		var result = "";
		if(this.vertices.length >= 3) // should be!
		{
			// STL requires triangular polygons. If our polygon has more vertices, create
			// multiple triangles:
			var firstVertexStl = this.vertices[0].toStlString();
			for(var i = 0; i < this.vertices.length - 2; i++) {
				result += "facet normal " + this.plane.normal.toStlString() + "\nouter loop\n";
				result += firstVertexStl;
				result += this.vertices[i + 1].toStlString();
				result += this.vertices[i + 2].toStlString();
				result += "endloop\nendfacet\n";
			}
		}
		return result;
	},

	toString: function() {
		var result = "Polygon plane: " + this.plane.toString() + "\n";
		this.vertices.map(function(vertex) {
			result += "  " + vertex.toString() + "\n";
		});
		return result;
	},

	// project the 3D polygon onto a plane
	projectToOrthoNormalBasis: function(orthobasis) {
		var points2d = this.vertices.map(function(vertex) {
			return orthobasis.to2D(vertex.pos);
		});
		var result = CAG.fromPointsNoCheck(points2d);
		var area = result.area();
		if(Math.abs(area) < 1e-5) {
			// the polygon was perpendicular to the orthnormal plane. The resulting 2D polygon would be degenerate
			// return an empty area instead:
			result = new CAG();
		} else if(area < 0) {
			result = result.flipped();
		}
		return result;
	},

	/**
	 * Creates solid from slices (CSG.Polygon) by generating walls
	 * @param {Object} options Solid generating options
	 *	- numslices {Number} Number of slices to be generated
	 *	- callback(t, slice) {Function} Callback function generating slices.
	 *			arguments: t = [0..1], slice = [0..numslices - 1]
	 *			return: CSG.Polygon or null to skip
	 *	- loop {Boolean} no flats, only walls, it's used to generate solids like a tor
	 *
	 *	by Eduard Bespalov AKA tedbeer (2013)
	 */
	solidFromSlices: function(options) {
		var polygons = [],
			csg = null,
			prev = null,
			bottom = null,
			top = null,
			numSlices = 2,
			bLoop = false,
			fnCallback,
			flipped = null;

		if (options) {
			bLoop = Boolean(options['loop']);

			if (options.numslices)
				numSlices = options.numslices;

			if (options.callback)
				fnCallback = options.callback;
		}
		if (!fnCallback) {
			var square = new CSG.Polygon.createFromPoints([
						[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]
					]);
			fnCallback = function(t, slice) {
				return t == 0 || t == 1 ? square.translate([0,0,t]) : null;
			}
		}
		for(var i = 0, iMax = numSlices - 1; i <= iMax; i++) {
			csg = fnCallback.call(this, i / iMax, i);
			if (csg) {
				if (!(csg instanceof CSG.Polygon)) {
					throw new Error("CSG.Polygon.solidFromSlices callback error: CSG.Polygon expected");
				}
				csg.checkIfConvex();

				if (prev) {//generate walls
					if (flipped === null) {//not generated yet
						flipped = prev.plane.signedDistanceToPoint(csg.vertices[0].pos) < 0;
					}
					this._addWalls(polygons, prev, csg, flipped);

				} else {//the first - will be a bottom
					bottom = csg;
				}
				prev = csg;
			} //callback can return null to skip that slice
		}
		top = csg;

		if (bLoop) {
			var bSameTopBottom = bottom.vertices.length == top.vertices.length &&
								bottom.vertices.every(function(v, index){
									return v.pos.equals(top.vertices[index].pos)
								});
			//if top and bottom are not the same -
			//generate walls between them
			if (!bSameTopBottom) {
				this._addWalls(polygons, top, bottom, flipped);
			} //else - already generated
		} else {
			//save top and bottom
			//TODO: flip if necessary
			polygons.unshift(flipped ? bottom : bottom.flipped());
			polygons.push(flipped ? top.flipped() : top);
		}
		return CSG.fromPolygons(polygons);
	},
	/**
	 *
	 * @param walls Array of wall polygons
	 * @param bottom Bottom polygon
	 * @param top Top polygon
	 */
	_addWalls: function(walls, bottom, top, bFlipped) {
		var bottomPoints = bottom.vertices.slice(0),//make a copy
			topPoints = top.vertices.slice(0),//make a copy
			color = top.shared || null;

		//check if bottom perimeter is closed
		if (!bottomPoints[0].pos.equals(bottomPoints[bottomPoints.length - 1].pos)) {
			bottomPoints.push(bottomPoints[0]);
		}

		//check if top perimeter is closed
		if (!topPoints[0].pos.equals(topPoints[topPoints.length - 1].pos)) {
			topPoints.push(topPoints[0]);
		}
		if (bFlipped) {
			bottomPoints = bottomPoints.reverse();
			topPoints = topPoints.reverse();
		}

		var iTopLen = topPoints.length - 1,
			iBotLen = bottomPoints.length - 1,
			iExtra = iTopLen - iBotLen, //how many extra triangles we need
			bMoreTops = iExtra > 0,
			bMoreBottoms = iExtra < 0;

		var aMin = []; //indexes to start extra triangles (polygon with minimal square)
		//init - we need exactly /iExtra/ small triangles
		for (var i = Math.abs(iExtra); i > 0; i--) {
			aMin.push({len: Infinity, index: -1});
		}

		var len;
		if (bMoreBottoms) {
			for (var i = 0; i < iBotLen; i++) {
				len = bottomPoints[i].pos.distanceToSquared(bottomPoints[i+1].pos);
				//find the element to replace
				for (var j = aMin.length - 1; j >= 0; j--) {
					if (aMin[j].len > len) {
						aMin[j].len = len;
						aMin.index = j;
						break;
					}
				}//for
			}
		} else if (bMoreTops) {
			for (var i = 0; i < iTopLen; i++) {
				len = topPoints[i].pos.distanceToSquared(topPoints[i+1].pos);
				//find the element to replace
				for (var j = aMin.length - 1; j >= 0; j--) {
					if (aMin[j].len > len) {
						aMin[j].len = len;
						aMin.index = j;
						break;
					}
				}//for
			}
		}//if
		//sort by index
		aMin.sort(fnSortByIndex);
		var getTriangle = function addWallsPutTriangle (pointA, pointB, pointC, color) {
			return new CSG.Polygon([pointA, pointB, pointC], color);
			//return bFlipped ? triangle.flipped() : triangle;
		};

		var bpoint = bottomPoints[0],
			tpoint = topPoints[0],
			secondPoint,
			nBotFacet, nTopFacet; //length of triangle facet side
		for (var iB = 0, iT = 0, iMax = iTopLen + iBotLen; iB + iT < iMax;) {
			if (aMin.length) {
				if (bMoreTops && iT == aMin[0].index) {//one vertex is on the bottom, 2 - on the top
					secondPoint = topPoints[++iT];
					//console.log('<<< extra top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);
					walls.push(getTriangle(
						secondPoint, tpoint, bpoint, color
					));
					tpoint = secondPoint;
					aMin.shift();
					continue;
				} else if (bMoreBottoms && iB == aMin[0].index) {
					secondPoint = bottomPoints[++iB];
					walls.push(getTriangle(
						tpoint, bpoint, secondPoint, color
					));
					bpoint = secondPoint;
					aMin.shift();
					continue;
				}
			}
			//choose the shortest path
			if (iB < iBotLen) { //one vertex is on the top, 2 - on the bottom
				nBotFacet = tpoint.pos.distanceToSquared(bottomPoints[iB+1].pos);
			} else {
				nBotFacet = Infinity;
			}
			if (iT < iTopLen) { //one vertex is on the bottom, 2 - on the top
				nTopFacet = bpoint.pos.distanceToSquared(topPoints[iT+1].pos);
			} else {
				nTopFacet = Infinity;
			}
			if (nBotFacet <= nTopFacet) {
				secondPoint = bottomPoints[++iB];
				walls.push(getTriangle(
					tpoint, bpoint, secondPoint, color
				));
				bpoint = secondPoint;
			} else if (iT < iTopLen) { //nTopFacet < Infinity
				secondPoint = topPoints[++iT];
				//console.log('<<< top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);
				walls.push(getTriangle(
					secondPoint, tpoint, bpoint, color
				));
				tpoint = secondPoint;
			};
		}
		return walls;
	}
};

CSG.Polygon.verticesConvex = function(vertices, planenormal) {
	var numvertices = vertices.length;
	if(numvertices > 2) {
		var prevprevpos = vertices[numvertices - 2].pos;
		var prevpos = vertices[numvertices - 1].pos;
		for(var i = 0; i < numvertices; i++) {
			var pos = vertices[i].pos;
			if(!CSG.Polygon.isConvexPoint(prevprevpos, prevpos, pos, planenormal)) {
				return false;
			}
			prevprevpos = prevpos;
			prevpos = pos;
		}
	}
	return true;
};

// Create a polygon from the given points
CSG.Polygon.createFromPoints = function(points, shared, plane) {
	var normal;
	if(arguments.length < 3) {
		// initially set a dummy vertex normal:
		normal = new CSG.Vector3D(0, 0, 0);
	} else {
		normal = plane.normal;
	}
	var vertices = [];
	points.map(function(p) {
		var vec = new CSG.Vector3D(p);
		var vertex = new CSG.Vertex(vec);
		vertices.push(vertex);
	});
	var polygon;
	if(arguments.length < 3) {
		polygon = new CSG.Polygon(vertices, shared);
	} else {
		polygon = new CSG.Polygon(vertices, shared, plane);
	}
	return polygon;
};

// calculate whether three points form a convex corner
//  prevpoint, point, nextpoint: the 3 coordinates (CSG.Vector3D instances)
//  normal: the normal vector of the plane
CSG.Polygon.isConvexPoint = function(prevpoint, point, nextpoint, normal) {
	var crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));
	var crossdotnormal = crossproduct.dot(normal);
	return(crossdotnormal >= 0);
};

CSG.Polygon.isStrictlyConvexPoint = function(prevpoint, point, nextpoint, normal) {
	var crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));
	var crossdotnormal = crossproduct.dot(normal);
	return(crossdotnormal >= 1e-5);
};

// # class CSG.Polygon.Shared
// Holds the shared properties for each polygon (currently only color)
CSG.Polygon.Shared = function(color) {
	this.color = color;
};

CSG.Polygon.Shared.fromObject = function(obj) {
	return new CSG.Polygon.Shared(obj.color);
};

CSG.Polygon.Shared.prototype = {
	getTag: function() {
		var result = this.tag;
		if(!result) {
			result = CSG.getTag();
			this.tag = result;
		}
		return result;
	},
	// get a string uniquely identifying this object
	getHash: function() {
		if(!this.color) return "null";
		return "" + this.color[0] + "/" + this.color[1] + "/" + this.color[2] + "/" + this.color[3];
	}
};

CSG.Polygon.defaultShared = new CSG.Polygon.Shared(null);

// # class PolygonTreeNode
// This class manages hierarchical splits of polygons
// At the top is a root node which doesn hold a polygon, only child PolygonTreeNodes
// Below that are zero or more 'top' nodes; each holds a polygon. The polygons can be in different planes
// splitByPlane() splits a node by a plane. If the plane intersects the polygon, two new child nodes
// are created holding the splitted polygon.
// getPolygons() retrieves the polygon from the tree. If for PolygonTreeNode the polygon is split but
// the two split parts (child nodes) are still intact, then the unsplit polygon is returned.
// This ensures that we can safely split a polygon into many fragments. If the fragments are untouched,
//  getPolygons() will return the original unsplit polygon instead of the fragments.
// remove() removes a polygon from the tree. Once a polygon is removed, the parent polygons are invalidated
// since they are no longer intact.
// constructor creates the root node:
CSG.PolygonTreeNode = function() {
	this.parent = null;
	this.children = [];
	this.polygon = null;
	this.removed = false;
};

CSG.PolygonTreeNode.prototype = {
	// fill the tree with polygons. Should be called on the root node only; child nodes must
	// always be a derivate (split) of the parent node.
	addPolygons: function(polygons) {
		if(!this.isRootNode())
			// new polygons can only be added to root node; children can only be splitted polygons
			throw new Error("Assertion failed");
		var _this = this;
		polygons.map(function(polygon) {
			_this.addChild(polygon);
		});
	},

	// remove a node
	// - the siblings become toplevel nodes
	// - the parent is removed recursively
	remove: function() {
		if(!this.removed) {
			this.removed = true;

			if(_CSGDEBUG) {
				if(this.isRootNode()) throw new Error("Assertion failed"); // can't remove root node
				if(this.children.length) throw new Error("Assertion failed"); // we shouldn't remove nodes with children
			}

			// remove ourselves from the parent's children list:
			var parentschildren = this.parent.children;
			var i = parentschildren.indexOf(this);
			if(i < 0) throw new Error("Assertion failed");
			parentschildren.splice(i, 1);

			// invalidate the parent's polygon, and of all parents above it:
			this.parent.recursivelyInvalidatePolygon();
		}
	},

	isRemoved: function() {
		return this.removed;
	},

	isRootNode: function() {
		return !this.parent;
	},

	// invert all polygons in the tree. Call on the root node
	invert: function() {
		if(!this.isRootNode()) throw new Error("Assertion failed"); // can only call this on the root node
		this.invertSub();
	},

	getPolygon: function() {
		if(!this.polygon) throw new Error("Assertion failed"); // doesn't have a polygon, which means that it has been broken down
		return this.polygon;
	},

	getPolygons: function(result) {
		if(this.polygon) {
			// the polygon hasn't been broken yet. We can ignore the children and return our polygon:
			result.push(this.polygon);
		} else {
			// our polygon has been split up and broken, so gather all subpolygons from the children:
			var childpolygons = [];
			this.children.map(function(child) {
				child.getPolygons(childpolygons);
			});
			childpolygons.map(function(p) {
				result.push(p);
			});
		}
	},

	// split the node by a plane; add the resulting nodes to the frontnodes and backnodes array
	// If the plane doesn't intersect the polygon, the 'this' object is added to one of the arrays
	// If the plane does intersect the polygon, two new child nodes are created for the front and back fragments,
	//  and added to both arrays.
	splitByPlane: function(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {
		var children = this.children;
		var numchildren = children.length;
		if(numchildren > 0) {
			// if we have children, split the children
			for(var i = 0; i < numchildren; i++) {
				children[i].splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);
			}
		} else {
			// no children. Split the polygon:
			var polygon = this.polygon;
			if(polygon) {
				var bound = polygon.boundingSphere();
				var sphereradius = bound[1] + 1e-4;
				var planenormal = plane.normal;
				var spherecenter = bound[0];
				var d = planenormal.dot(spherecenter) - plane.w;
				if(d > sphereradius) {
					frontnodes.push(this);
				} else if(d < -sphereradius) {
					backnodes.push(this);
				} else {
					var splitresult = plane.splitPolygon(polygon);
					switch(splitresult.type) {
					case 0:
						// coplanar front:
						coplanarfrontnodes.push(this);
						break;

					case 1:
						// coplanar back:
						coplanarbacknodes.push(this);
						break;

					case 2:
						// front:
						frontnodes.push(this);
						break;

					case 3:
						// back:
						backnodes.push(this);
						break;

					case 4:
						// spanning:
						if(splitresult.front) {
							var frontnode = this.addChild(splitresult.front);
							frontnodes.push(frontnode);
						}
						if(splitresult.back) {
							var backnode = this.addChild(splitresult.back);
							backnodes.push(backnode);
						}
						break;
					}
				}
			}
		}
	},


	// PRIVATE methods from here:
	// add child to a node
	// this should be called whenever the polygon is split
	// a child should be created for every fragment of the split polygon
	// returns the newly created child
	addChild: function(polygon) {
		var newchild = new CSG.PolygonTreeNode();
		newchild.parent = this;
		newchild.polygon = polygon;
		this.children.push(newchild);
		return newchild;
	},

	invertSub: function() {
		if(this.polygon) {
			this.polygon = this.polygon.flipped();
		}
		this.children.map(function(child) {
			child.invertSub();
		});
	},

	recursivelyInvalidatePolygon: function() {
		if(this.polygon) {
			this.polygon = null;
			if(this.parent) {
				this.parent.recursivelyInvalidatePolygon();
			}
		}
	}
};



// # class Tree
// This is the root of a BSP tree
// We are using this separate class for the root of the tree, to hold the PolygonTreeNode root
// The actual tree is kept in this.rootnode
CSG.Tree = function(polygons) {
	this.polygonTree = new CSG.PolygonTreeNode();
	this.rootnode = new CSG.Node(null);
	if(polygons) this.addPolygons(polygons);
};

CSG.Tree.prototype = {
	invert: function() {
		this.polygonTree.invert();
		this.rootnode.invert();
	},

	// Remove all polygons in this BSP tree that are inside the other BSP tree
	// `tree`.
	clipTo: function(tree, alsoRemovecoplanarFront) {
		alsoRemovecoplanarFront = alsoRemovecoplanarFront ? true : false;
		this.rootnode.clipTo(tree, alsoRemovecoplanarFront);
	},

	allPolygons: function() {
		var result = [];
		this.polygonTree.getPolygons(result);
		return result;
	},

	addPolygons: function(polygons) {
		var _this = this;
		var polygontreenodes = polygons.map(function(p) {
			return _this.polygonTree.addChild(p);
		});
		this.rootnode.addPolygonTreeNodes(polygontreenodes);
	}
};

// # class Node
// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons
// by picking a polygon to split along.
// Polygons are not stored directly in the tree, but in PolygonTreeNodes, stored in
// this.polygontreenodes. Those PolygonTreeNodes are children of the owning
// CSG.Tree.polygonTree
// This is not a leafy BSP tree since there is
// no distinction between internal and leaf nodes.
CSG.Node = function(parent) {
	this.plane = null;
	this.front = null;
	this.back = null;
	this.polygontreenodes = [];
	this.parent = parent;
};

CSG.Node.prototype = {
	// Convert solid space to empty space and empty space to solid space.
	invert: function() {
		if(this.plane) this.plane = this.plane.flipped();
		if(this.front) this.front.invert();
		if(this.back) this.back.invert();
		var temp = this.front;
		this.front = this.back;
		this.back = temp;
	},

	// clip polygontreenodes to our plane
	// calls remove() for all clipped PolygonTreeNodes
	clipPolygons: function(polygontreenodes, alsoRemovecoplanarFront) {
		if(this.plane) {
			var backnodes = [];
			var frontnodes = [];
			var coplanarfrontnodes = alsoRemovecoplanarFront ? backnodes : frontnodes;
			var plane = this.plane;
			var numpolygontreenodes = polygontreenodes.length;
			for(var i = 0; i < numpolygontreenodes; i++) {
				var node = polygontreenodes[i];
				if(!node.isRemoved()) {
					node.splitByPlane(plane, coplanarfrontnodes, backnodes, frontnodes, backnodes);
				}
			}
			if(this.front && (frontnodes.length > 0)) {
				this.front.clipPolygons(frontnodes, alsoRemovecoplanarFront);
			}
			var numbacknodes = backnodes.length;
			if(this.back && (numbacknodes > 0)) {
				this.back.clipPolygons(backnodes, alsoRemovecoplanarFront);
			} else {
				// there's nothing behind this plane. Delete the nodes behind this plane:
				for(var i = 0; i < numbacknodes; i++) {
					backnodes[i].remove();
				}
			}
		}
	},

	// Remove all polygons in this BSP tree that are inside the other BSP tree
	// `tree`.
	clipTo: function(tree, alsoRemovecoplanarFront) {
		if(this.polygontreenodes.length > 0) {
			tree.rootnode.clipPolygons(this.polygontreenodes, alsoRemovecoplanarFront);
		}
		if(this.front) this.front.clipTo(tree, alsoRemovecoplanarFront);
		if(this.back) this.back.clipTo(tree, alsoRemovecoplanarFront);
	},

	addPolygonTreeNodes: function(polygontreenodes) {
		if(polygontreenodes.length === 0) return;
		var _this = this;
		if(!this.plane) {
			var bestplane = polygontreenodes[0].getPolygon().plane;
			/*
	  var parentnormals = [];
	  this.getParentPlaneNormals(parentnormals, 6);
//parentnormals = [];
	  var numparentnormals = parentnormals.length;
	  var minmaxnormal = 1.0;
	  polygontreenodes.map(function(polygontreenode){
		var plane = polygontreenodes[0].getPolygon().plane;
		var planenormal = plane.normal;
		var maxnormaldot = -1.0;
		parentnormals.map(function(parentnormal){
		  var dot = parentnormal.dot(planenormal);
		  if(dot > maxnormaldot) maxnormaldot = dot;
		});
		if(maxnormaldot < minmaxnormal)
		{
		  minmaxnormal = maxnormaldot;
		  bestplane = plane;
		}
	  });
*/
			this.plane = bestplane;
		}
		var frontnodes = [];
		var backnodes = [];
		polygontreenodes.map(function(polygontreenode) {
			polygontreenode.splitByPlane(_this.plane, _this.polygontreenodes, backnodes, frontnodes, backnodes);
		});
		if(frontnodes.length > 0) {
			if(!this.front) this.front = new CSG.Node(this);
			this.front.addPolygonTreeNodes(frontnodes);
		}
		if(backnodes.length > 0) {
			if(!this.back) this.back = new CSG.Node(this);
			this.back.addPolygonTreeNodes(backnodes);
		}
	},

	getParentPlaneNormals: function(normals, maxdepth) {
		if(maxdepth > 0) {
			if(this.parent) {
				normals.push(this.parent.plane.normal);
				this.parent.getParentPlaneNormals(normals, maxdepth - 1);
			}
		}
	}
};

//////////
// # class Matrix4x4:
// Represents a 4x4 matrix. Elements are specified in row order
CSG.Matrix4x4 = function(elements) {
	if(arguments.length >= 1) {
		this.elements = elements;
	} else {
		// if no arguments passed: create unity matrix
		this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	}
};

CSG.Matrix4x4.prototype = {
	plus: function(m) {
		var r = [];
		for(var i = 0; i < 16; i++) {
			r[i] = this.elements[i] + m.elements[i];
		}
		return new CSG.Matrix4x4(r);
	},

	minus: function(m) {
		var r = [];
		for(var i = 0; i < 16; i++) {
			r[i] = this.elements[i] - m.elements[i];
		}
		return new CSG.Matrix4x4(r);
	},

	// right multiply by another 4x4 matrix:
	multiply: function(m) {
		// cache elements in local variables, for speedup:
		var this0 = this.elements[0];
		var this1 = this.elements[1];
		var this2 = this.elements[2];
		var this3 = this.elements[3];
		var this4 = this.elements[4];
		var this5 = this.elements[5];
		var this6 = this.elements[6];
		var this7 = this.elements[7];
		var this8 = this.elements[8];
		var this9 = this.elements[9];
		var this10 = this.elements[10];
		var this11 = this.elements[11];
		var this12 = this.elements[12];
		var this13 = this.elements[13];
		var this14 = this.elements[14];
		var this15 = this.elements[15];
		var m0 = m.elements[0];
		var m1 = m.elements[1];
		var m2 = m.elements[2];
		var m3 = m.elements[3];
		var m4 = m.elements[4];
		var m5 = m.elements[5];
		var m6 = m.elements[6];
		var m7 = m.elements[7];
		var m8 = m.elements[8];
		var m9 = m.elements[9];
		var m10 = m.elements[10];
		var m11 = m.elements[11];
		var m12 = m.elements[12];
		var m13 = m.elements[13];
		var m14 = m.elements[14];
		var m15 = m.elements[15];

		var result = [];
		result[0] = this0 * m0 + this1 * m4 + this2 * m8 + this3 * m12;
		result[1] = this0 * m1 + this1 * m5 + this2 * m9 + this3 * m13;
		result[2] = this0 * m2 + this1 * m6 + this2 * m10 + this3 * m14;
		result[3] = this0 * m3 + this1 * m7 + this2 * m11 + this3 * m15;
		result[4] = this4 * m0 + this5 * m4 + this6 * m8 + this7 * m12;
		result[5] = this4 * m1 + this5 * m5 + this6 * m9 + this7 * m13;
		result[6] = this4 * m2 + this5 * m6 + this6 * m10 + this7 * m14;
		result[7] = this4 * m3 + this5 * m7 + this6 * m11 + this7 * m15;
		result[8] = this8 * m0 + this9 * m4 + this10 * m8 + this11 * m12;
		result[9] = this8 * m1 + this9 * m5 + this10 * m9 + this11 * m13;
		result[10] = this8 * m2 + this9 * m6 + this10 * m10 + this11 * m14;
		result[11] = this8 * m3 + this9 * m7 + this10 * m11 + this11 * m15;
		result[12] = this12 * m0 + this13 * m4 + this14 * m8 + this15 * m12;
		result[13] = this12 * m1 + this13 * m5 + this14 * m9 + this15 * m13;
		result[14] = this12 * m2 + this13 * m6 + this14 * m10 + this15 * m14;
		result[15] = this12 * m3 + this13 * m7 + this14 * m11 + this15 * m15;
		return new CSG.Matrix4x4(result);
	},

	clone: function() {
		var elements = this.elements.map(function(p) {
			return p;
		});
		return new CSG.Matrix4x4(elements);
	},

	// Right multiply the matrix by a CSG.Vector3D (interpreted as 3 row, 1 column)
	// (result = M*v)
	// Fourth element is taken as 1
	rightMultiply1x3Vector: function(v) {
		var v0 = v._x;
		var v1 = v._y;
		var v2 = v._z;
		var v3 = 1;
		var x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];
		var y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];
		var z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];
		var w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];
		// scale such that fourth element becomes 1:
		if(w != 1) {
			var invw = 1.0 / w;
			x *= invw;
			y *= invw;
			z *= invw;
		}
		return new CSG.Vector3D(x, y, z);
	},

	// Multiply a CSG.Vector3D (interpreted as 3 column, 1 row) by this matrix
	// (result = v*M)
	// Fourth element is taken as 1
	leftMultiply1x3Vector: function(v) {
		var v0 = v._x;
		var v1 = v._y;
		var v2 = v._z;
		var v3 = 1;
		var x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];
		var y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];
		var z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];
		var w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];
		// scale such that fourth element becomes 1:
		if(w != 1) {
			var invw = 1.0 / w;
			x *= invw;
			y *= invw;
			z *= invw;
		}
		return new CSG.Vector3D(x, y, z);
	},

	// Right multiply the matrix by a CSG.Vector2D (interpreted as 2 row, 1 column)
	// (result = M*v)
	// Fourth element is taken as 1
	rightMultiply1x2Vector: function(v) {
		var v0 = v.x;
		var v1 = v.y;
		var v2 = 0;
		var v3 = 1;
		var x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];
		var y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];
		var z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];
		var w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];
		// scale such that fourth element becomes 1:
		if(w != 1) {
			var invw = 1.0 / w;
			x *= invw;
			y *= invw;
			z *= invw;
		}
		return new CSG.Vector2D(x, y);
	},

	// Multiply a CSG.Vector2D (interpreted as 2 column, 1 row) by this matrix
	// (result = v*M)
	// Fourth element is taken as 1
	leftMultiply1x2Vector: function(v) {
		var v0 = v.x;
		var v1 = v.y;
		var v2 = 0;
		var v3 = 1;
		var x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];
		var y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];
		var z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];
		var w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];
		// scale such that fourth element becomes 1:
		if(w != 1) {
			var invw = 1.0 / w;
			x *= invw;
			y *= invw;
			z *= invw;
		}
		return new CSG.Vector2D(x, y);
	},

	// determine whether this matrix is a mirroring transformation
	isMirroring: function() {
		var u = new CSG.Vector3D(this.elements[0], this.elements[4], this.elements[8]);
		var v = new CSG.Vector3D(this.elements[1], this.elements[5], this.elements[9]);
		var w = new CSG.Vector3D(this.elements[2], this.elements[6], this.elements[10]);

		// for a true orthogonal, non-mirrored base, u.cross(v) == w
		// If they have an opposite direction then we are mirroring
		var mirrorvalue = u.cross(v).dot(w);
		var ismirror = (mirrorvalue < 0);
		return ismirror;
	}
};

// return the unity matrix
CSG.Matrix4x4.unity = function() {
	return new CSG.Matrix4x4();
};

// Create a rotation matrix for rotating around the x axis
CSG.Matrix4x4.rotationX = function(degrees) {
	var radians = degrees * Math.PI * (1.0 / 180.0);
	var cos = Math.cos(radians);
	var sin = Math.sin(radians);
	var els = [
	1, 0, 0, 0, 0, cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1];
	return new CSG.Matrix4x4(els);
};

// Create a rotation matrix for rotating around the y axis
CSG.Matrix4x4.rotationY = function(degrees) {
	var radians = degrees * Math.PI * (1.0 / 180.0);
	var cos = Math.cos(radians);
	var sin = Math.sin(radians);
	var els = [
	cos, 0, -sin, 0, 0, 1, 0, 0, sin, 0, cos, 0, 0, 0, 0, 1];
	return new CSG.Matrix4x4(els);
};

// Create a rotation matrix for rotating around the z axis
CSG.Matrix4x4.rotationZ = function(degrees) {
	var radians = degrees * Math.PI * (1.0 / 180.0);
	var cos = Math.cos(radians);
	var sin = Math.sin(radians);
	var els = [
	cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	return new CSG.Matrix4x4(els);
};

// Matrix for rotation about arbitrary point and axis
CSG.Matrix4x4.rotation = function(rotationCenter, rotationAxis, degrees) {
	rotationCenter = new CSG.Vector3D(rotationCenter);
	rotationAxis = new CSG.Vector3D(rotationAxis);
	var rotationPlane = CSG.Plane.fromNormalAndPoint(rotationAxis, rotationCenter);
	var orthobasis = new CSG.OrthoNormalBasis(rotationPlane);
	var transformation = CSG.Matrix4x4.translation(rotationCenter.negated());
	transformation = transformation.multiply(orthobasis.getProjectionMatrix());
	transformation = transformation.multiply(CSG.Matrix4x4.rotationZ(degrees));
	transformation = transformation.multiply(orthobasis.getInverseProjectionMatrix());
	transformation = transformation.multiply(CSG.Matrix4x4.translation(rotationCenter));
	return transformation;
};

// Create an affine matrix for translation:
CSG.Matrix4x4.translation = function(v) {
	// parse as CSG.Vector3D, so we can pass an array or a CSG.Vector3D
	var vec = new CSG.Vector3D(v);
	var els = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, vec.x, vec.y, vec.z, 1];
	return new CSG.Matrix4x4(els);
};

// Create an affine matrix for mirroring into an arbitrary plane:
CSG.Matrix4x4.mirroring = function(plane) {
	var nx = plane.normal.x;
	var ny = plane.normal.y;
	var nz = plane.normal.z;
	var w = plane.w;
	var els = [
		(1.0 - 2.0 * nx * nx), (-2.0 * ny * nx), (-2.0 * nz * nx), 0,
		(-2.0 * nx * ny), (1.0 - 2.0 * ny * ny), (-2.0 * nz * ny), 0,
		(-2.0 * nx * nz), (-2.0 * ny * nz), (1.0 - 2.0 * nz * nz), 0,
		(-2.0 * nx * w), (-2.0 * ny * w), (-2.0 * nz * w), 1
	];
	return new CSG.Matrix4x4(els);
};

// Create an affine matrix for scaling:
CSG.Matrix4x4.scaling = function(v) {
	// parse as CSG.Vector3D, so we can pass an array or a CSG.Vector3D
	var vec = new CSG.Vector3D(v);
	var els = [
	vec.x, 0, 0, 0, 0, vec.y, 0, 0, 0, 0, vec.z, 0, 0, 0, 0, 1];
	return new CSG.Matrix4x4(els);
};

///////////////////////////////////////////////////
// # class Vector2D:
// Represents a 2 element vector
CSG.Vector2D = function(x, y) {
	if(arguments.length == 2) {
		this._x = parseFloat(x);
		this._y = parseFloat(y);
	} else {
		var ok = true;
		if(arguments.length == 1) {
			if(typeof(x) == "object") {
				if(x instanceof CSG.Vector2D) {
					this._x = x._x;
					this._y = x._y;
				} else if(x instanceof Array) {
					this._x = parseFloat(x[0]);
					this._y = parseFloat(x[1]);
				} else if(('x' in x) && ('y' in x)) {
					this._x = parseFloat(x.x);
					this._y = parseFloat(x.y);
				} else ok = false;
			} else {
				var v = parseFloat(x);
				this._x = v;
				this._y = v;
			}
		} else ok = false;
		if(ok) {
			if((!CSG.IsFloat(this._x)) || (!CSG.IsFloat(this._y))) ok = false;
		}
		if(!ok) {
			throw new Error("wrong arguments");
		}
	}
};

CSG.Vector2D.fromAngle = function(radians) {
	return CSG.Vector2D.fromAngleRadians(radians);
};

CSG.Vector2D.fromAngleDegrees = function(degrees) {
	var radians = Math.PI * degrees / 180;
	return CSG.Vector2D.fromAngleRadians(radians);
};

CSG.Vector2D.fromAngleRadians = function(radians) {
	return new CSG.Vector2D(Math.cos(radians), Math.sin(radians));
};

CSG.Vector2D.prototype = {
	get x() {
		return this._x;
	}, get y() {
		return this._y;
	},

	set x(v) {
		throw new Error("Vector2D is immutable");
	}, set y(v) {
		throw new Error("Vector2D is immutable");
	},

	// extend to a 3D vector by adding a z coordinate:
	toVector3D: function(z) {
		return new CSG.Vector3D(this._x, this._y, z);
	},

	equals: function(a) {
		return(this._x == a._x) && (this._y == a._y);
	},

	clone: function() {
		return new CSG.Vector2D(this._x, this._y);
	},

	negated: function() {
		return new CSG.Vector2D(-this._x, -this._y);
	},

	plus: function(a) {
		return new CSG.Vector2D(this._x + a._x, this._y + a._y);
	},

	minus: function(a) {
		return new CSG.Vector2D(this._x - a._x, this._y - a._y);
	},

	times: function(a) {
		return new CSG.Vector2D(this._x * a, this._y * a);
	},

	dividedBy: function(a) {
		return new CSG.Vector2D(this._x / a, this._y / a);
	},

	dot: function(a) {
		return this._x * a._x + this._y * a._y;
	},

	lerp: function(a, t) {
		return this.plus(a.minus(this).times(t));
	},

	length: function() {
		return Math.sqrt(this.dot(this));
	},

	distanceTo: function(a) {
		return this.minus(a).length();
	},

	distanceToSquared: function(a) {
		return this.minus(a).lengthSquared();
	},

	lengthSquared: function() {
		return this.dot(this);
	},

	unit: function() {
		return this.dividedBy(this.length());
	},

	cross: function(a) {
		return this._x * a._y - this._y * a._x;
	},

	// returns the vector rotated by 90 degrees clockwise
	normal: function() {
		return new CSG.Vector2D(this._y, -this._x);
	},

	// Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)
	// Returns a new CSG.Vector2D
	multiply4x4: function(matrix4x4) {
		return matrix4x4.leftMultiply1x2Vector(this);
	},

	transform: function(matrix4x4) {
		return matrix4x4.leftMultiply1x2Vector(this);
	},

	angle: function() {
		return this.angleRadians();
	},

	angleDegrees: function() {
		var radians = this.angleRadians();
		return 180 * radians / Math.PI;
	},

	angleRadians: function() {
		// y=sin, x=cos
		return Math.atan2(this._y, this._x);
	},

	min: function(p) {
		return new CSG.Vector2D(
		Math.min(this._x, p._x), Math.min(this._y, p._y));
	},

	max: function(p) {
		return new CSG.Vector2D(
		Math.max(this._x, p._x), Math.max(this._y, p._y));
	},

	toString: function() {
		return "("+this._x.toFixed(2)+", "+this._y.toFixed(2)+")";
	}
};


// # class Line2D
// Represents a directional line in 2D space
// A line is parametrized by its normal vector (perpendicular to the line, rotated 90 degrees counter clockwise)
// and w. The line passes through the point <normal>.times(w).
// normal must be a unit vector!
// Equation: p is on line if normal.dot(p)==w
CSG.Line2D = function(normal, w) {
	normal = new CSG.Vector2D(normal);
	w = parseFloat(w);
	var l = normal.length();
	// normalize:
	w *= l;
	normal = normal.times(1.0 / l);
	this.normal = normal;
	this.w = w;
};

CSG.Line2D.fromPoints = function(p1, p2) {
	p1 = new CSG.Vector2D(p1);
	p2 = new CSG.Vector2D(p2);
	var direction = p2.minus(p1);
	var normal = direction.normal().negated().unit();
	var w = p1.dot(normal);
	return new CSG.Line2D(normal, w);
};

CSG.Line2D.prototype = {
	// same line but opposite direction:
	reverse: function() {
		return new CSG.Line2D(this.normal.negated(), -this.w);
	},

	equals: function(l) {
		return(l.normal.equals(this.normal) && (l.w == this.w));
	},

	origin: function() {
		return this.normal.times(this.w);
	},

	direction: function() {
		return this.normal.normal();
	},

	xAtY: function(y) {
		// (py == y) && (normal * p == w)
		// -> px = (w - normal._y * y) / normal.x
		var x = (this.w - this.normal._y * y) / this.normal.x;
		return x;
	},

	absDistanceToPoint: function(point) {
		point = new CSG.Vector2D(point);
		var point_projected = point.dot(this.normal);
		var distance = Math.abs(point_projected - this.w);
		return distance;
	},
	/*FIXME: has error - origin is not defined, the method is never used
	closestPoint: function(point) {
		point = new CSG.Vector2D(point);
		var vector = point.dot(this.direction());
		return origin.plus(vector);
	},
	*/

	// intersection between two lines, returns point as Vector2D
	intersectWithLine: function(line2d) {
		var point = CSG.solve2Linear(this.normal.x, this.normal.y, line2d.normal.x, line2d.normal.y, this.w, line2d.w);
		point = new CSG.Vector2D(point); // make  vector2d
		return point;
	},

	transform: function(matrix4x4) {
		var origin = new CSG.Vector2D(0, 0);
		var pointOnPlane = this.normal.times(this.w);
		var neworigin = origin.multiply4x4(matrix4x4);
		var neworiginPlusNormal = this.normal.multiply4x4(matrix4x4);
		var newnormal = neworiginPlusNormal.minus(neworigin);
		var newpointOnPlane = pointOnPlane.multiply4x4(matrix4x4);
		var neww = newnormal.dot(newpointOnPlane);
		return new CSG.Line2D(newnormal, neww);
	}
};

// # class Line3D
// Represents a line in 3D space
// direction must be a unit vector
// point is a random point on the line
CSG.Line3D = function(point, direction) {
	point = new CSG.Vector3D(point);
	direction = new CSG.Vector3D(direction);
	this.point = point;
	this.direction = direction.unit();
};

CSG.Line3D.fromPoints = function(p1, p2) {
	p1 = new CSG.Vector3D(p1);
	p2 = new CSG.Vector3D(p2);
	var direction = p2.minus(p1).unit();
	return new CSG.Line3D(p1, direction);
};

CSG.Line3D.fromPlanes = function(p1, p2) {
	var direction = p1.normal.cross(p2.normal);
	var l = direction.length();
	if(l < 1e-10) {
		throw new Error("Parallel planes");
	}
	direction = direction.times(1.0 / l);

	var mabsx = Math.abs(direction.x);
	var mabsy = Math.abs(direction.y);
	var mabsz = Math.abs(direction.z);
	var origin;
	if((mabsx >= mabsy) && (mabsx >= mabsz)) {
		// direction vector is mostly pointing towards x
		// find a point p for which x is zero:
		var r = CSG.solve2Linear(p1.normal.y, p1.normal.z, p2.normal.y, p2.normal.z, p1.w, p2.w);
		origin = new CSG.Vector3D(0, r[0], r[1]);
	} else if((mabsy >= mabsx) && (mabsy >= mabsz)) {
		// find a point p for which y is zero:
		var r = CSG.solve2Linear(p1.normal.x, p1.normal.z, p2.normal.x, p2.normal.z, p1.w, p2.w);
		origin = new CSG.Vector3D(r[0], 0, r[1]);
	} else {
		// find a point p for which z is zero:
		var r = CSG.solve2Linear(p1.normal.x, p1.normal.y, p2.normal.x, p2.normal.y, p1.w, p2.w);
		origin = new CSG.Vector3D(r[0], r[1], 0);
	}
	return new CSG.Line3D(origin, direction);
};


CSG.Line3D.prototype = {
	intersectWithPlane: function(plane) {
		// plane: plane.normal * p = plane.w
		// line: p=line.point + labda * line.direction
		var labda = (plane.w - plane.normal.dot(this.point)) / plane.normal.dot(this.direction);
		var point = this.point.plus(this.direction.times(labda));
		return point;
	},

	clone: function(line) {
		return new CSG.Line3D(this.point.clone(), this.direction.clone());
	},

	reverse: function() {
		return new CSG.Line3D(this.point.clone(), this.direction.negated());
	},

	transform: function(matrix4x4) {
		var newpoint = this.point.multiply4x4(matrix4x4);
		var pointPlusDirection = this.point.plus(this.direction);
		var newPointPlusDirection = pointPlusDirection.multiply4x4(matrix4x4);
		var newdirection = newPointPlusDirection.minus(newpoint);
		return new CSG.Line3D(newpoint, newdirection);
	},

	closestPointOnLine: function(point) {
		point = new CSG.Vector3D(point);
		var t = point.minus(this.point).dot(this.direction) / this.direction.dot(this.direction);
		var closestpoint = this.point.plus(this.direction.times(t));
		return closestpoint;
	},

	distanceToPoint: function(point) {
		point = new CSG.Vector3D(point);
		var closestpoint = this.closestPointOnLine(point);
		var distancevector = point.minus(closestpoint);
		var distance = distancevector.length();
		return distance;
	},

	equals: function(line3d) {
		if(!this.direction.equals(line3d.direction)) return false;
		var distance = this.distanceToPoint(line3d.point);
		if(distance > 1e-8) return false;
		return true;
	}
};


// # class OrthoNormalBasis
// Reprojects points on a 3D plane onto a 2D plane
// or from a 2D plane back onto the 3D plane
CSG.OrthoNormalBasis = function(plane, rightvector) {
	if(arguments.length < 2) {
		// choose an arbitrary right hand vector, making sure it is somewhat orthogonal to the plane normal:
		rightvector = plane.normal.randomNonParallelVector();
	} else {
		rightvector = new CSG.Vector3D(rightvector);
	}
	this.v = plane.normal.cross(rightvector).unit();
	this.u = this.v.cross(plane.normal);
	this.plane = plane;
	this.planeorigin = plane.normal.times(plane.w);
};

// The z=0 plane, with the 3D x and y vectors mapped to the 2D x and y vector
CSG.OrthoNormalBasis.Z0Plane = function() {
	var plane = new CSG.Plane(new CSG.Vector3D([0, 0, 1]), 0);
	return new CSG.OrthoNormalBasis(plane, new CSG.Vector3D([1, 0, 0]));
};

CSG.OrthoNormalBasis.prototype = {
	getProjectionMatrix: function() {
		return new CSG.Matrix4x4([
			this.u.x, this.v.x, this.plane.normal.x, 0,
			this.u.y, this.v.y, this.plane.normal.y, 0,
			this.u.z, this.v.z, this.plane.normal.z, 0,
			0, 0, -this.plane.w, 1]);
	},

	getInverseProjectionMatrix: function() {
		var p = this.plane.normal.times(this.plane.w);
		return new CSG.Matrix4x4([
			this.u.x, this.u.y, this.u.z, 0,
			this.v.x, this.v.y, this.v.z, 0,
			this.plane.normal.x, this.plane.normal.y, this.plane.normal.z, 0,
			p.x, p.y, p.z, 1]);
	},

	to2D: function(vec3) {
		return new CSG.Vector2D(vec3.dot(this.u), vec3.dot(this.v));
	},

	to3D: function(vec2) {
		return this.planeorigin.plus(this.u.times(vec2.x)).plus(this.v.times(vec2.y));
	},

	line3Dto2D: function(line3d) {
		var a = line3d.point;
		var b = line3d.direction.plus(a);
		var a2d = this.to2D(a);
		var b2d = this.to2D(b);
		return CSG.Line2D.fromPoints(a2d, b2d);
	},

	line2Dto3D: function(line2d) {
		var a = line2d.origin();
		var b = line2d.direction().plus(a);
		var a3d = this.to3D(a);
		var b3d = this.to3D(b);
		return CSG.Line3D.fromPoints(a3d, b3d);
	},

	transform: function(matrix4x4) {
		// todo: this may not work properly in case of mirroring
		var newplane = this.plane.transform(matrix4x4);
		var rightpoint_transformed = this.u.transform(matrix4x4);
		var origin_transformed = new CSG.Vector3D(0, 0, 0).transform(matrix4x4);
		var newrighthandvector = rightpoint_transformed.minus(origin_transformed);
		var newbasis = new CSG.OrthoNormalBasis(newplane, newrighthandvector);
		return newbasis;
	}
};

function insertSorted(array, element, comparefunc) {
	var leftbound = 0;
	var rightbound = array.length;
	while(rightbound > leftbound) {
		var testindex = Math.floor((leftbound + rightbound) / 2);
		var testelement = array[testindex];
		var compareresult = comparefunc(element, testelement);
		if(compareresult > 0) // element > testelement
		{
			leftbound = testindex + 1;
		} else {
			rightbound = testindex;
		}
	}
	array.splice(leftbound, 0, element);
}

// Get the x coordinate of a point with a certain y coordinate, interpolated between two
// points (CSG.Vector2D).
// Interpolation is robust even if the points have the same y coordinate
CSG.interpolateBetween2DPointsForY = function(point1, point2, y) {
	var f1 = y - point1.y;
	var f2 = point2.y - point1.y;
	if(f2 < 0) {
		f1 = -f1;
		f2 = -f2;
	}
	var t;
	if(f1 <= 0) {
		t = 0.0;
	} else if(f1 >= f2) {
		t = 1.0;
	} else if(f2 < 1e-10) {
		t = 0.5;
	} else {
		t = f1 / f2;
	}
	var result = point1.x + t * (point2.x - point1.x);
	return result;
};

// Retesselation function for a set of coplanar polygons. See the introduction at the top of
// this file.
CSG.reTesselateCoplanarPolygons = function(sourcepolygons, destpolygons) {
	var EPS = 1e-5;

	var numpolygons = sourcepolygons.length;
	if(numpolygons > 0) {
		var plane = sourcepolygons[0].plane;
		var shared = sourcepolygons[0].shared;
		var orthobasis = new CSG.OrthoNormalBasis(plane);
		var polygonvertices2d = []; // array of array of CSG.Vector2D
		var polygontopvertexindexes = []; // array of indexes of topmost vertex per polygon
		var topy2polygonindexes = {};
		var ycoordinatetopolygonindexes = {};

		var xcoordinatebins = {};
		var ycoordinatebins = {};

		// convert all polygon vertices to 2D
		// Make a list of all encountered y coordinates
		// And build a map of all polygons that have a vertex at a certain y coordinate:
		var ycoordinateBinningFactor = 1.0 / EPS * 10;
		for(var polygonindex = 0; polygonindex < numpolygons; polygonindex++) {
			var poly3d = sourcepolygons[polygonindex];
			var vertices2d = [];
			var numvertices = poly3d.vertices.length;
			var minindex = -1;
			if(numvertices > 0) {
				var miny, maxy, maxindex;
				for(var i = 0; i < numvertices; i++) {
					var pos2d = orthobasis.to2D(poly3d.vertices[i].pos);
					// perform binning of y coordinates: If we have multiple vertices very
					// close to each other, give them the same y coordinate:
					var ycoordinatebin = Math.floor(pos2d.y * ycoordinateBinningFactor);
					var newy;
					if(ycoordinatebin in ycoordinatebins) {
						newy = ycoordinatebins[ycoordinatebin];
					} else if(ycoordinatebin + 1 in ycoordinatebins) {
						newy = ycoordinatebins[ycoordinatebin + 1];
					} else if(ycoordinatebin - 1 in ycoordinatebins) {
						newy = ycoordinatebins[ycoordinatebin - 1];
					} else {
						newy = pos2d.y;
						ycoordinatebins[ycoordinatebin] = pos2d.y;
					}
					pos2d = new CSG.Vector2D(pos2d.x, newy);
					vertices2d.push(pos2d);
					var y = pos2d.y;
					if((i === 0) || (y < miny)) {
						miny = y;
						minindex = i;
					}
					if((i === 0) || (y > maxy)) {
						maxy = y;
						maxindex = i;
					}
					if(!(y in ycoordinatetopolygonindexes)) {
						ycoordinatetopolygonindexes[y] = {};
					}
					ycoordinatetopolygonindexes[y][polygonindex] = true;
				}
				if(miny >= maxy) {
					// degenerate polygon, all vertices have same y coordinate. Just ignore it from now:
					vertices2d = [];
				} else {
					if(!(miny in topy2polygonindexes)) {
						topy2polygonindexes[miny] = [];
					}
					topy2polygonindexes[miny].push(polygonindex);
				}
			} // if(numvertices > 0)
			// reverse the vertex order:
			vertices2d.reverse();
			minindex = numvertices - minindex - 1;
			polygonvertices2d.push(vertices2d);
			polygontopvertexindexes.push(minindex);
		}
		var ycoordinates = [];
		for(var ycoordinate in ycoordinatetopolygonindexes) ycoordinates.push(ycoordinate);
		ycoordinates.sort(fnNumberSort);

		// Now we will iterate over all y coordinates, from lowest to highest y coordinate
		// activepolygons: source polygons that are 'active', i.e. intersect with our y coordinate
		//   Is sorted so the polygons are in left to right order
		// Each element in activepolygons has these properties:
		//        polygonindex: the index of the source polygon (i.e. an index into the sourcepolygons
		//                      and polygonvertices2d arrays)
		//        leftvertexindex: the index of the vertex at the left side of the polygon (lowest x)
		//                         that is at or just above the current y coordinate
		//        rightvertexindex: dito at right hand side of polygon
		//        topleft, bottomleft: coordinates of the left side of the polygon crossing the current y coordinate
		//        topright, bottomright: coordinates of the right hand side of the polygon crossing the current y coordinate
		var activepolygons = [];
		var prevoutpolygonrow = [];
		for(var yindex = 0; yindex < ycoordinates.length; yindex++) {
			var newoutpolygonrow = [];
			var ycoordinate_as_string = ycoordinates[yindex];
			var ycoordinate = Number(ycoordinate_as_string);

			// update activepolygons for this y coordinate:
			// - Remove any polygons that end at this y coordinate
			// - update leftvertexindex and rightvertexindex (which point to the current vertex index
			//   at the the left and right side of the polygon
			// Iterate over all polygons that have a corner at this y coordinate:
			var polygonindexeswithcorner = ycoordinatetopolygonindexes[ycoordinate_as_string];
			for(var activepolygonindex = 0; activepolygonindex < activepolygons.length; ++activepolygonindex) {
				var activepolygon = activepolygons[activepolygonindex];
				var polygonindex = activepolygon.polygonindex;
				if(polygonindexeswithcorner[polygonindex]) {
					// this active polygon has a corner at this y coordinate:
					var vertices2d = polygonvertices2d[polygonindex];
					var numvertices = vertices2d.length;
					var newleftvertexindex = activepolygon.leftvertexindex;
					var newrightvertexindex = activepolygon.rightvertexindex;
					// See if we need to increase leftvertexindex or decrease rightvertexindex:
					while(true) {
						var nextleftvertexindex = newleftvertexindex + 1;
						if(nextleftvertexindex >= numvertices) nextleftvertexindex = 0;
						if(vertices2d[nextleftvertexindex].y != ycoordinate) break;
						newleftvertexindex = nextleftvertexindex;
					}
					var nextrightvertexindex = newrightvertexindex - 1;
					if(nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;
					if(vertices2d[nextrightvertexindex].y == ycoordinate) {
						newrightvertexindex = nextrightvertexindex;
					}
					if((newleftvertexindex != activepolygon.leftvertexindex) && (newleftvertexindex == newrightvertexindex)) {
						// We have increased leftvertexindex or decreased rightvertexindex, and now they point to the same vertex
						// This means that this is the bottom point of the polygon. We'll remove it:
						activepolygons.splice(activepolygonindex, 1);
						--activepolygonindex;
					} else {
						activepolygon.leftvertexindex = newleftvertexindex;
						activepolygon.rightvertexindex = newrightvertexindex;
						activepolygon.topleft = vertices2d[newleftvertexindex];
						activepolygon.topright = vertices2d[newrightvertexindex];
						var nextleftvertexindex = newleftvertexindex + 1;
						if(nextleftvertexindex >= numvertices) nextleftvertexindex = 0;
						activepolygon.bottomleft = vertices2d[nextleftvertexindex];
						var nextrightvertexindex = newrightvertexindex - 1;
						if(nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;
						activepolygon.bottomright = vertices2d[nextrightvertexindex];
					}
				} // if polygon has corner here
			} // for activepolygonindex
			var nextycoordinate;
			if(yindex >= ycoordinates.length - 1) {
				// last row, all polygons must be finished here:
				activepolygons = [];
				nextycoordinate = null;
			} else // yindex < ycoordinates.length-1
			{
				nextycoordinate = Number(ycoordinates[yindex + 1]);
				var middleycoordinate = 0.5 * (ycoordinate + nextycoordinate);
				// update activepolygons by adding any polygons that start here:
				var startingpolygonindexes = topy2polygonindexes[ycoordinate_as_string];
				for(var polygonindex_key in startingpolygonindexes) {
					var polygonindex = startingpolygonindexes[polygonindex_key];
					var vertices2d = polygonvertices2d[polygonindex];
					var numvertices = vertices2d.length;
					var topvertexindex = polygontopvertexindexes[polygonindex];
					// the top of the polygon may be a horizontal line. In that case topvertexindex can point to any point on this line.
					// Find the left and right topmost vertices which have the current y coordinate:
					var topleftvertexindex = topvertexindex;
					while(true) {
						var i = topleftvertexindex + 1;
						if(i >= numvertices) i = 0;
						if(vertices2d[i].y != ycoordinate) break;
						if(i == topvertexindex) break; // should not happen, but just to prevent endless loops
						topleftvertexindex = i;
					}
					var toprightvertexindex = topvertexindex;
					while(true) {
						var i = toprightvertexindex - 1;
						if(i < 0) i = numvertices - 1;
						if(vertices2d[i].y != ycoordinate) break;
						if(i == topleftvertexindex) break; // should not happen, but just to prevent endless loops
						toprightvertexindex = i;
					}
					var nextleftvertexindex = topleftvertexindex + 1;
					if(nextleftvertexindex >= numvertices) nextleftvertexindex = 0;
					var nextrightvertexindex = toprightvertexindex - 1;
					if(nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;
					var newactivepolygon = {
						polygonindex: polygonindex,
						leftvertexindex: topleftvertexindex,
						rightvertexindex: toprightvertexindex,
						topleft: vertices2d[topleftvertexindex],
						topright: vertices2d[toprightvertexindex],
						bottomleft: vertices2d[nextleftvertexindex],
						bottomright: vertices2d[nextrightvertexindex],
					};
					insertSorted(activepolygons, newactivepolygon, function(el1, el2) {
						var x1 = CSG.interpolateBetween2DPointsForY(
									el1.topleft, el1.bottomleft, middleycoordinate);
						var x2 = CSG.interpolateBetween2DPointsForY(
									el2.topleft, el2.bottomleft, middleycoordinate);
						if(x1 > x2) return 1;
						if(x1 < x2) return -1;
						return 0;
					});
				} // for(var polygonindex in startingpolygonindexes)
			} //  yindex < ycoordinates.length-1
			//if( (yindex == ycoordinates.length-1) || (nextycoordinate - ycoordinate > EPS) )
			if(true) {
				// Now activepolygons is up to date
				// Build the output polygons for the next row in newoutpolygonrow:
				for(var activepolygon_key in activepolygons) {
					var activepolygon = activepolygons[activepolygon_key];
					var polygonindex = activepolygon.polygonindex;
					var vertices2d = polygonvertices2d[polygonindex];
					var numvertices = vertices2d.length;

					var x = CSG.interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, ycoordinate);
					var topleft = new CSG.Vector2D(x, ycoordinate);
					x = CSG.interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, ycoordinate);
					var topright = new CSG.Vector2D(x, ycoordinate);
					x = CSG.interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, nextycoordinate);
					var bottomleft = new CSG.Vector2D(x, nextycoordinate);
					x = CSG.interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, nextycoordinate);
					var bottomright = new CSG.Vector2D(x, nextycoordinate);
					var outpolygon = {
						topleft: topleft,
						topright: topright,
						bottomleft: bottomleft,
						bottomright: bottomright,
						leftline: CSG.Line2D.fromPoints(topleft, bottomleft),
						rightline: CSG.Line2D.fromPoints(bottomright, topright)
					};
					if(newoutpolygonrow.length > 0) {
						var prevoutpolygon = newoutpolygonrow[newoutpolygonrow.length - 1];
						var d1 = outpolygon.topleft.distanceTo(prevoutpolygon.topright);
						var d2 = outpolygon.bottomleft.distanceTo(prevoutpolygon.bottomright);
						if((d1 < EPS) && (d2 < EPS)) {
							// we can join this polygon with the one to the left:
							outpolygon.topleft = prevoutpolygon.topleft;
							outpolygon.leftline = prevoutpolygon.leftline;
							outpolygon.bottomleft = prevoutpolygon.bottomleft;
							newoutpolygonrow.splice(newoutpolygonrow.length - 1, 1);
						}
					}
					newoutpolygonrow.push(outpolygon);
				} // for(activepolygon in activepolygons)
				if(yindex > 0) {
					// try to match the new polygons against the previous row:
					var prevcontinuedindexes = {};
					var matchedindexes = {};
					for(var i = 0; i < newoutpolygonrow.length; i++) {
						var thispolygon = newoutpolygonrow[i];
						for(var ii = 0; ii < prevoutpolygonrow.length; ii++) {
							if(!matchedindexes[ii]) // not already processed?
							{
								// We have a match if the sidelines are equal or if the top coordinates
								// are on the sidelines of the previous polygon
								var prevpolygon = prevoutpolygonrow[ii];
								if(prevpolygon.bottomleft.distanceTo(thispolygon.topleft) < EPS) {
									if(prevpolygon.bottomright.distanceTo(thispolygon.topright) < EPS) {
										// Yes, the top of this polygon matches the bottom of the previous:
										matchedindexes[ii] = true;
										// Now check if the joined polygon would remain convex:
										var d1 = thispolygon.leftline.direction().x - prevpolygon.leftline.direction().x;
										var d2 = thispolygon.rightline.direction().x - prevpolygon.rightline.direction().x;
										var leftlinecontinues = Math.abs(d1) < EPS;
										var rightlinecontinues = Math.abs(d2) < EPS;
										var leftlineisconvex = leftlinecontinues || (d1 >= 0);
										var rightlineisconvex = rightlinecontinues || (d2 >= 0);
										if(leftlineisconvex && rightlineisconvex) {
											// yes, both sides have convex corners:
											// This polygon will continue the previous polygon
											thispolygon.outpolygon = prevpolygon.outpolygon;
											thispolygon.leftlinecontinues = leftlinecontinues;
											thispolygon.rightlinecontinues = rightlinecontinues;
											prevcontinuedindexes[ii] = true;
										}
										break;
									}
								}
							} // if(!prevcontinuedindexes[ii])
						} // for ii
					} // for i
					for(var ii = 0; ii < prevoutpolygonrow.length; ii++) {
						if(!prevcontinuedindexes[ii]) {
							// polygon ends here
							// Finish the polygon with the last point(s):
							var prevpolygon = prevoutpolygonrow[ii];
							prevpolygon.outpolygon.rightpoints.push(prevpolygon.bottomright);
							if(prevpolygon.bottomright.distanceTo(prevpolygon.bottomleft) > EPS) {
								// polygon ends with a horizontal line:
								prevpolygon.outpolygon.leftpoints.push(prevpolygon.bottomleft);
							}
							// reverse the left half so we get a counterclockwise circle:
							prevpolygon.outpolygon.leftpoints.reverse();
							var points2d = prevpolygon.outpolygon.rightpoints.concat(prevpolygon.outpolygon.leftpoints);
							var vertices3d = [];
							points2d.map(function(point2d) {
								var point3d = orthobasis.to3D(point2d);
								var vertex3d = new CSG.Vertex(point3d);
								vertices3d.push(vertex3d);
							});
							var polygon = new CSG.Polygon(vertices3d, shared, plane);
							destpolygons.push(polygon);
						}
					}
				} // if(yindex > 0)
				for(var i = 0; i < newoutpolygonrow.length; i++) {
					var thispolygon = newoutpolygonrow[i];
					if(!thispolygon.outpolygon) {
						// polygon starts here:
						thispolygon.outpolygon = {
							leftpoints: [],
							rightpoints: []
						};
						thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);
						if(thispolygon.topleft.distanceTo(thispolygon.topright) > EPS) {
							// we have a horizontal line at the top:
							thispolygon.outpolygon.rightpoints.push(thispolygon.topright);
						}
					} else {
						// continuation of a previous row
						if(!thispolygon.leftlinecontinues) {
							thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);
						}
						if(!thispolygon.rightlinecontinues) {
							thispolygon.outpolygon.rightpoints.push(thispolygon.topright);
						}
					}
				}
				prevoutpolygonrow = newoutpolygonrow;
			}
		} // for yindex
	} // if(numpolygons > 0)
};

////////////////////////////////
// ## class fuzzyFactory
// This class acts as a factory for objects. We can search for an object with approximately
// the desired properties (say a rectangle with width 2 and height 1)
// The lookupOrCreate() method looks for an existing object (for example it may find an existing rectangle
// with width 2.0001 and height 0.999. If no object is found, the user supplied callback is
// called, which should generate a new object. The new object is inserted into the database
// so it can be found by future lookupOrCreate() calls.
// Constructor:
//   numdimensions: the number of parameters for each object
//     for example for a 2D rectangle this would be 2
//   tolerance: The maximum difference for each parameter allowed to be considered a match
CSG.fuzzyFactory = function(numdimensions, tolerance) {
	var lookuptable = [];
	for(var i = 0; i < numdimensions; i++) {
		lookuptable.push({});
	}
	this.lookuptable = lookuptable;
	this.nextElementId = 1;
	this.multiplier = 1.0 / tolerance;
	this.objectTable = {};
};

CSG.fuzzyFactory.prototype = {
	// var obj = f.lookupOrCreate([el1, el2, el3], function(elements) {/* create the new object */});
	// Performs a fuzzy lookup of the object with the specified elements.
	// If found, returns the existing object
	// If not found, calls the supplied callback function which should create a new object with
	// the specified properties. This object is inserted in the lookup database.
	lookupOrCreate: function(els, creatorCallback) {
		var object;
		var key = this.lookupKey(els);
		if(key === null) {
			object = creatorCallback(els);
			key = this.nextElementId++;
			this.objectTable[key] = object;
			for(var dimension = 0; dimension < els.length; dimension++) {
				var elementLookupTable = this.lookuptable[dimension];
				var value = els[dimension];
				var valueMultiplied = value * this.multiplier;
				var valueQuantized1 = Math.floor(valueMultiplied);
				var valueQuantized2 = Math.ceil(valueMultiplied);
				CSG.fuzzyFactory.insertKey(key, elementLookupTable, valueQuantized1);
				CSG.fuzzyFactory.insertKey(key, elementLookupTable, valueQuantized2);
			}
		} else {
			object = this.objectTable[key];
		}
		return object;
	},

	// ----------- PRIVATE METHODS:
	lookupKey: function(els) {
		var keyset = {};
		for(var dimension = 0; dimension < els.length; dimension++) {
			var elementLookupTable = this.lookuptable[dimension];
			var value = els[dimension];
			var valueQuantized = Math.round(value * this.multiplier);
			valueQuantized += "";
			if(valueQuantized in elementLookupTable) {
				if(dimension === 0) {
					keyset = elementLookupTable[valueQuantized];
				} else {
					keyset = CSG.fuzzyFactory.intersectSets(keyset, elementLookupTable[valueQuantized]);
				}
			} else {
				return null;
			}
			if(CSG.fuzzyFactory.isEmptySet(keyset)) return null;
		}
		// return first matching key:
		for(var key in keyset) return key;
		return null;
	},

	lookupKeySetForDimension: function(dimension, value) {
		var result;
		var elementLookupTable = this.lookuptable[dimension];
		var valueMultiplied = value * this.multiplier;
		var valueQuantized = Math.floor(value * this.multiplier);
		if(valueQuantized in elementLookupTable) {
			result = elementLookupTable[valueQuantized];
		} else {
			result = {};
		}
		return result;
	}
};

CSG.fuzzyFactory.insertKey = function(key, lookuptable, quantizedvalue) {
	if(quantizedvalue in lookuptable) {
		lookuptable[quantizedvalue][key] = true;
	} else {
		var newset = {};
		newset[key] = true;
		lookuptable[quantizedvalue] = newset;
	}
};

CSG.fuzzyFactory.isEmptySet = function(obj) {
	for(var key in obj) return false;
	return true;
};

CSG.fuzzyFactory.intersectSets = function(set1, set2) {
	var result = {};
	for(var key in set1) {
		if(key in set2) {
			result[key] = true;
		}
	}
	return result;
};

CSG.fuzzyFactory.joinSets = function(set1, set2) {
	var result = {}, key;
	for(key in set1) {
		result[key] = true;
	}
	for(key in set2) {
		result[key] = true;
	}
	return result;
};

//////////////////////////////////////
CSG.fuzzyCSGFactory = function() {
	this.vertexfactory = new CSG.fuzzyFactory(3, 1e-5);
	this.planefactory = new CSG.fuzzyFactory(4, 1e-5);
	this.polygonsharedfactory = {};
};

CSG.fuzzyCSGFactory.prototype = {
	getPolygonShared: function(sourceshared) {
		var hash = sourceshared.getHash();
		if(hash in this.polygonsharedfactory) {
			return this.polygonsharedfactory[hash];
		} else {
			this.polygonsharedfactory[hash] = sourceshared;
			return sourceshared;
		}
	},

	getVertex: function(sourcevertex) {
		var elements = [sourcevertex.pos._x, sourcevertex.pos._y, sourcevertex.pos._z];
		var result = this.vertexfactory.lookupOrCreate(elements, function(els) {
			return sourcevertex;
		});
		return result;
	},

	getPlane: function(sourceplane) {
		var elements = [sourceplane.normal._x, sourceplane.normal._y, sourceplane.normal._z, sourceplane.w];
		var result = this.planefactory.lookupOrCreate(elements, function(els) {
			return sourceplane;
		});
		return result;
	},

	getPolygon: function(sourcepolygon) {
		var newplane = this.getPlane(sourcepolygon.plane);
		var newshared = this.getPolygonShared(sourcepolygon.shared);
		var _this = this;
		var newvertices = sourcepolygon.vertices.map(function(vertex) {
			return _this.getVertex(vertex);
		});
		return new CSG.Polygon(newvertices, newshared, newplane);
	},

	getCSG: function(sourcecsg) {
		var _this = this;
		var newpolygons = sourcecsg.polygons.map(function(polygon) {
			return _this.getPolygon(polygon);
		});
		return CSG.fromPolygons(newpolygons);
	}
};

//////////////////////////////////////
// Tag factory: we can request a unique tag through CSG.getTag()
CSG.staticTag = 1;

CSG.getTag = function() {
	return CSG.staticTag++;
};

//////////////////////////////////////
// # Class Properties
// This class is used to store properties of a solid
// A property can for example be a CSG.Vertex, a CSG.Plane or a CSG.Line3D
// Whenever an affine transform is applied to the CSG solid, all its properties are
// transformed as well.
// The properties can be stored in a complex nested structure (using arrays and objects)
CSG.Properties = function() {};

CSG.Properties.prototype = {
	_transform: function(matrix4x4) {
		var result = new CSG.Properties();
		CSG.Properties.transformObj(this, result, matrix4x4);
		return result;
	},
	_merge: function(otherproperties) {
		var result = new CSG.Properties();
		CSG.Properties.cloneObj(this, result);
		CSG.Properties.addFrom(result, otherproperties);
		return result;
	}
};

CSG.Properties.transformObj = function(source, result, matrix4x4) {
	for(var propertyname in source) {
		if(propertyname == "_transform") continue;
		if(propertyname == "_merge") continue;
		var propertyvalue = source[propertyname];
		var transformed = propertyvalue;
		if(typeof(propertyvalue) == "object") {
			if(('transform' in propertyvalue) && (typeof(propertyvalue.transform) == "function")) {
				transformed = propertyvalue.transform(matrix4x4);
			} else if(propertyvalue instanceof Array) {
				transformed = [];
				CSG.Properties.transformObj(propertyvalue, transformed, matrix4x4);
			} else if(propertyvalue instanceof CSG.Properties) {
				transformed = new CSG.Properties();
				CSG.Properties.transformObj(propertyvalue, transformed, matrix4x4);
			}
		}
		result[propertyname] = transformed;
	}
};

CSG.Properties.cloneObj = function(source, result) {
	for(var propertyname in source) {
		if(propertyname == "_transform") continue;
		if(propertyname == "_merge") continue;
		var propertyvalue = source[propertyname];
		var cloned = propertyvalue;
		if(typeof(propertyvalue) == "object") {
			if(propertyvalue instanceof Array) {
				cloned = [];
				for(var i = 0; i < propertyvalue.length; i++) {
					cloned.push(propertyvalue[i]);
				}
			} else if(propertyvalue instanceof CSG.Properties) {
				cloned = new CSG.Properties();
				CSG.Properties.cloneObj(propertyvalue, cloned);
			}
		}
		result[propertyname] = cloned;
	}
};

CSG.Properties.addFrom = function(result, otherproperties) {
	for(var propertyname in otherproperties) {
		if(propertyname == "_transform") continue;
		if(propertyname == "_merge") continue;
		if((propertyname in result) &&
				(typeof(result[propertyname]) == "object") &&
				(result[propertyname] instanceof CSG.Properties) &&
				(typeof(otherproperties[propertyname]) == "object") &&
				(otherproperties[propertyname] instanceof CSG.Properties)) {
			CSG.Properties.addFrom(result[propertyname], otherproperties[propertyname]);
		} else if(!(propertyname in result)) {
			result[propertyname] = otherproperties[propertyname];
		}
	}
};

//////////////////////////////////////
// # class Connector
// A connector allows to attach two objects at predefined positions
// For example a servo motor and a servo horn:
// Both can have a Connector called 'shaft'
// The horn can be moved and rotated such that the two connectors match
// and the horn is attached to the servo motor at the proper position.
// Connectors are stored in the properties of a CSG solid so they are
// ge the same transformations applied as the solid
CSG.Connector = function(point, axisvector, normalvector) {
	this.point = new CSG.Vector3D(point);
	this.axisvector = new CSG.Vector3D(axisvector).unit();
	this.normalvector = new CSG.Vector3D(normalvector).unit();
};

CSG.Connector.prototype = {
	normalized: function() {
		var axisvector = this.axisvector.unit();
		// make the normal vector truly normal:
		var n = this.normalvector.cross(axisvector).unit();
		var normalvector = axisvector.cross(n);
		return new CSG.Connector(this.point, axisvector, normalvector);
	},

	transform: function(matrix4x4) {
		var point = this.point.multiply4x4(matrix4x4);
		var axisvector = this.point.plus(this.axisvector).multiply4x4(matrix4x4).minus(point);
		var normalvector = this.point.plus(this.normalvector).multiply4x4(matrix4x4).minus(point);
		return new CSG.Connector(point, axisvector, normalvector);
	},

	// Get the transformation matrix to connect this Connector to another connector
	//   other: a CSG.Connector to which this connector should be connected
	//   mirror: false: the 'axis' vectors of the connectors should point in the same direction
	//           true: the 'axis' vectors of the connectors should point in opposite direction
	//   normalrotation: degrees of rotation between the 'normal' vectors of the two
	//                   connectors
	getTransformationTo: function(other, mirror, normalrotation) {
		mirror = mirror ? true : false;
		normalrotation = normalrotation ? Number(normalrotation) : 0;
		var us = this.normalized();
		other = other.normalized();
		// shift to the origin:
		var transformation = CSG.Matrix4x4.translation(this.point.negated());
		// construct the plane crossing through the origin and the two axes:
		var axesplane = CSG.Plane.anyPlaneFromVector3Ds(
		new CSG.Vector3D(0, 0, 0), us.axisvector, other.axisvector);
		var axesbasis = new CSG.OrthoNormalBasis(axesplane);
		var angle1 = axesbasis.to2D(us.axisvector).angle();
		var angle2 = axesbasis.to2D(other.axisvector).angle();
		var rotation = 180.0 * (angle2 - angle1) / Math.PI;
		if(mirror) rotation += 180.0;
		transformation = transformation.multiply(axesbasis.getProjectionMatrix());
		transformation = transformation.multiply(CSG.Matrix4x4.rotationZ(rotation));
		transformation = transformation.multiply(axesbasis.getInverseProjectionMatrix());
		var usAxesAligned = us.transform(transformation);
		// Now we have done the transformation for aligning the axes.
		// We still need to align the normals:
		var normalsplane = CSG.Plane.fromNormalAndPoint(other.axisvector, new CSG.Vector3D(0, 0, 0));
		var normalsbasis = new CSG.OrthoNormalBasis(normalsplane);
		angle1 = normalsbasis.to2D(usAxesAligned.normalvector).angle();
		angle2 = normalsbasis.to2D(other.normalvector).angle();
		rotation = 180.0 * (angle2 - angle1) / Math.PI;
		rotation += normalrotation;
		transformation = transformation.multiply(normalsbasis.getProjectionMatrix());
		transformation = transformation.multiply(CSG.Matrix4x4.rotationZ(rotation));
		transformation = transformation.multiply(normalsbasis.getInverseProjectionMatrix());
		// and translate to the destination point:
		transformation = transformation.multiply(CSG.Matrix4x4.translation(other.point));
		var usAligned = us.transform(transformation);
		return transformation;
	},

	axisLine: function() {
		return new CSG.Line3D(this.point, this.axisvector);
	},

	// creates a new Connector, with the connection point moved in the direction of the axisvector
	extend: function(distance) {
		var newpoint = this.point.plus(this.axisvector.unit().times(distance));
		return new CSG.Connector(newpoint, this.axisvector, this.normalvector);
	}
};


//////////////////////////////////////
// # Class Path2D
CSG.Path2D = function(points, closed) {
	closed = !! closed;
	points = points || [];
	// re-parse the points into CSG.Vector2D
	// and remove any duplicate points
	var prevpoint = null;
	if(closed && (points.length > 0)) {
		prevpoint = new CSG.Vector2D(points[points.length - 1]);
	}
	var newpoints = [];
	points.map(function(point) {
		point = new CSG.Vector2D(point);
		var skip = false;
		if(prevpoint !== null) {
			var distance = point.distanceTo(prevpoint);
			skip = distance < 1e-5;
		}
		if(!skip) newpoints.push(point);
		prevpoint = point;
	});
	this.points = newpoints;
	this.closed = closed;
};

/*
Construct a (part of a) circle. Parameters:
  options.center: the center point of the arc (CSG.Vector2D or array [x,y])
  options.radius: the circle radius (float)
  options.startangle: the starting angle of the arc, in degrees
	0 degrees corresponds to [1,0]
	90 degrees to [0,1]
	and so on
  options.endangle: the ending angle of the arc, in degrees
  options.resolution: number of points per 360 degree of rotation
  options.maketangent: adds two extra tiny line segments at both ends of the circle
	this ensures that the gradients at the edges are tangent to the circle
Returns a CSG.Path2D. The path is not closed (even if it is a 360 degree arc).
close() the resultin path if you want to create a true circle.
*/
CSG.Path2D.arc = function(options) {
	var center = CSG.parseOptionAs2DVector(options, "center", 0);
	var radius = CSG.parseOptionAsFloat(options, "radius", 1);
	var startangle = CSG.parseOptionAsFloat(options, "startangle", 0);
	var endangle = CSG.parseOptionAsFloat(options, "endangle", 360);
	var resolution = CSG.parseOptionAsInt(options, "resolution", CSG.defaultResolution2D);
	var maketangent = CSG.parseOptionAsBool(options, "maketangent", false);
	// no need to make multiple turns:
	while(endangle - startangle >= 720) {
		endangle -= 360;
	}
	while(endangle - startangle <= -720) {
		endangle += 360;
	}
	var points = [], point;
	var absangledif = Math.abs(endangle - startangle);
	if(absangledif < 1e-5) {
		point = CSG.Vector2D.fromAngle(startangle / 180.0 * Math.PI).times(radius);
		points.push(point.plus(center));
	} else {
		var numsteps = Math.floor(resolution * absangledif / 360) + 1;
		var edgestepsize = numsteps * 0.5 / absangledif; // step size for half a degree
		if(edgestepsize > 0.25) edgestepsize = 0.25;
		var numsteps_mod = maketangent ? (numsteps + 2) : numsteps;
		for(var i = 0; i <= numsteps_mod; i++) {
			var step = i;
			if(maketangent) {
				step = (i - 1) * (numsteps - 2 * edgestepsize) / numsteps + edgestepsize;
				if(step < 0) step = 0;
				if(step > numsteps) step = numsteps;
			}
			var angle = startangle + step * (endangle - startangle) / numsteps;
			point = CSG.Vector2D.fromAngle(angle / 180.0 * Math.PI).times(radius);
			points.push(point.plus(center));
		}
	}
	return new CSG.Path2D(points, false);
};

CSG.Path2D.prototype = {
	concat: function(otherpath) {
		if(this.closed || otherpath.closed) {
			throw new Error("Paths must not be closed");
		}
		var newpoints = this.points.concat(otherpath.points);
		return new CSG.Path2D(newpoints);
	},

	appendPoint: function(point) {
		if(this.closed) {
			throw new Error("Paths must not be closed");
		}
		var newpoints = this.points.concat([point]);
		return new CSG.Path2D(newpoints);
	},

	close: function() {
		return new CSG.Path2D(this.points, true);
	},

	// Extrude the path by following it with a rectangle (upright, perpendicular to the path direction)
	// Returns a CSG solid
	//   width: width of the extrusion, in the z=0 plane
	//   height: height of the extrusion in the z direction
	//   resolution: number of segments per 360 degrees for the curve in a corner
	rectangularExtrude: function(width, height, resolution) {
		var cag = this.expandToCAG(width / 2, resolution);
		var result = cag.extrude({
			offset: [0, 0, height]
		});
		return result;
	},

	// Expand the path to a CAG
	// This traces the path with a circle with radius pathradius
	expandToCAG: function(pathradius, resolution) {
		var sides = [];
		var numpoints = this.points.length;
		var startindex = 0;
		if(this.closed && (numpoints > 2)) startindex = -1;
		var prevvertex;
		for(var i = startindex; i < numpoints; i++) {
			var pointindex = i;
			if(pointindex < 0) pointindex = numpoints - 1;
			var point = this.points[pointindex];
			var vertex = new CAG.Vertex(point);
			if(i > startindex) {
				var side = new CAG.Side(prevvertex, vertex);
				sides.push(side);
			}
			prevvertex = vertex;
		}
		var shellcag = CAG.fromSides(sides);
		var expanded = shellcag.expandedShell(pathradius, resolution);
		return expanded;
	},

	innerToCAG: function() {
		if(!this.closed) throw new Error("The path should be closed!");
		return CAG.fromPoints(this.points);
	},

	transform: function(matrix4x4) {
		var newpoints = this.points.map(function(point) {
			return point.multiply4x4(matrix4x4);
		});
		return new CSG.Path2D(newpoints, this.closed);
	}
};

// Add several convenience methods to the classes that support a transform() method:
CSG.addTransformationMethodsToPrototype = function(prot) {
	prot.mirrored = function(plane) {
		return this.transform(CSG.Matrix4x4.mirroring(plane));
	};

	prot.mirroredX = function() {
		var plane = new CSG.Plane(new CSG.Vector3D(1, 0, 0), 0);
		return this.mirrored(plane);
	};

	prot.mirroredY = function() {
		var plane = new CSG.Plane(new CSG.Vector3D(0, 1, 0), 0);
		return this.mirrored(plane);
	};

	prot.mirroredZ = function() {
		var plane = new CSG.Plane(new CSG.Vector3D(0, 0, 1), 0);
		return this.mirrored(plane);
	};

	prot.translate = function(v) {
		return this.transform(CSG.Matrix4x4.translation(v));
	};

	prot.scale = function(f) {
		return this.transform(CSG.Matrix4x4.scaling(f));
	};

	prot.rotateX = function(deg) {
		return this.transform(CSG.Matrix4x4.rotationX(deg));
	};

	prot.rotateY = function(deg) {
		return this.transform(CSG.Matrix4x4.rotationY(deg));
	};

	prot.rotateZ = function(deg) {
		return this.transform(CSG.Matrix4x4.rotationZ(deg));
	};

	prot.rotate = function(rotationCenter, rotationAxis, degrees) {
		return this.transform(CSG.Matrix4x4.rotation(rotationCenter, rotationAxis, degrees));
	};
};

//////////////////
// CAG: solid area geometry: like CSG but 2D
// Each area consists of a number of sides
// Each side is a line between 2 points
var CAG = function() {
	this.sides = [];
};

// Construct a CAG from a list of `CAG.Side` instances.
CAG.fromSides = function(sides) {
	var cag = new CAG();
	cag.sides = sides;
	return cag;
};

// Construct a CAG from a list of points (a polygon)
// Rotation direction of the points is not relevant. Points can be a convex or concave polygon.
// Polygon must not self intersect
CAG.fromPoints = function(points) {
	var numpoints = points.length;
	if(numpoints < 3) throw new Error("CAG shape needs at least 3 points");
	var sides = [];
	var prevpoint = new CSG.Vector2D(points[numpoints - 1]);
	var prevvertex = new CAG.Vertex(prevpoint);
	points.map(function(p) {
		var point = new CSG.Vector2D(p);
		var vertex = new CAG.Vertex(point);
		var side = new CAG.Side(prevvertex, vertex);
		sides.push(side);
		prevvertex = vertex;
	});
	var result = CAG.fromSides(sides);
	if(result.isSelfIntersecting()) {
		throw new Error("Polygon is self intersecting!");
	}
	var area = result.area();
	if(Math.abs(area) < 1e-5) {
		throw new Error("Degenerate polygon!");
	}
	if(area < 0) {
		result = result.flipped();
	}
	result = result.canonicalized();
	return result;
};

// Like CAG.fromPoints but does not check if it's a valid polygon.
// Points should rotate counter clockwise
CAG.fromPointsNoCheck = function(points) {
	var sides = [];
	var prevpoint = new CSG.Vector2D(points[points.length - 1]);
	var prevvertex = new CAG.Vertex(prevpoint);
	points.map(function(p) {
		var point = new CSG.Vector2D(p);
		var vertex = new CAG.Vertex(point);
		var side = new CAG.Side(prevvertex, vertex);
		sides.push(side);
		prevvertex = vertex;
	});
	return CAG.fromSides(sides);
};

// Converts a CSG to a CAG. The CSG must consist of polygons with only z coordinates +1 and -1
// as constructed by CAG.toCSG(-1, 1). This is so we can use the 3D union(), intersect() etc
CAG.fromFakeCSG = function(csg) {
	var sides = csg.polygons.map(function(p) {
		return CAG.Side.fromFakePolygon(p);
	});
	return CAG.fromSides(sides);
};

// see if the line between p0start and p0end intersects with the line between p1start and p1end
// returns true if the lines strictly intersect, the end points are not counted!
CAG.linesIntersect = function(p0start, p0end, p1start, p1end) {
	if(p0end.equals(p1start) || p1end.equals(p0start)) {
		var d = p1end.minus(p1start).unit().plus(p0end.minus(p0start).unit()).length();
		if(d < 1e-5) {
			return true;
		}
	} else {
		var d0 = p0end.minus(p0start);
		var d1 = p1end.minus(p1start);
		if(Math.abs(d0.cross(d1)) < 1e-9) return false; // lines are parallel
		var alphas = CSG.solve2Linear(-d0.x, d1.x, -d0.y, d1.y, p0start.x - p1start.x, p0start.y - p1start.y);
		if((alphas[0] > 1e-6) && (alphas[0] < 0.999999) && (alphas[1] > 1e-5) && (alphas[1] < 0.999999)) return true;
		//    if( (alphas[0] >= 0) && (alphas[0] <= 1) && (alphas[1] >= 0) && (alphas[1] <= 1) ) return true;
	}
	return false;
};

/* Construct a circle
   options:
	 center: a 2D center point
	 radius: a scalar
	 resolution: number of sides per 360 degree rotation
   returns a CAG object
*/
CAG.circle = function(options) {
	options = options || {};
	var center = CSG.parseOptionAs2DVector(options, "center", [0, 0]);
	var radius = CSG.parseOptionAsFloat(options, "radius", 1);
	var resolution = CSG.parseOptionAsInt(options, "resolution", CSG.defaultResolution2D);
	var sides = [];
	var prevvertex;
	for(var i = 0; i <= resolution; i++) {
		var radians = 2 * Math.PI * i / resolution;
		var point = CSG.Vector2D.fromAngleRadians(radians).times(radius).plus(center);
		var vertex = new CAG.Vertex(point);
		if(i > 0) {
			sides.push(new CAG.Side(prevvertex, vertex));
		}
		prevvertex = vertex;
	}
	return CAG.fromSides(sides);
};

/* Construct a rectangle
   options:
	 center: a 2D center point
	 radius: a 2D vector with width and height
   returns a CAG object
*/
CAG.rectangle = function(options) {
	options = options || {};
	var c = CSG.parseOptionAs2DVector(options, "center", [0, 0]);
	var r = CSG.parseOptionAs2DVector(options, "radius", [1, 1]);
	var rswap = new CSG.Vector2D(r.x, -r.y);
	var points = [
	c.plus(r), c.plus(rswap), c.minus(r), c.minus(rswap)];
	return CAG.fromPoints(points);
};

//     var r = CSG.roundedRectangle({
//       center: [0, 0],
//       radius: [2, 1],
//       roundradius: 0.2,
//       resolution: 8,
//     });
CAG.roundedRectangle = function(options) {
	options = options || {};
	var center = CSG.parseOptionAs2DVector(options, "center", [0, 0]);
	var radius = CSG.parseOptionAs2DVector(options, "radius", [1, 1]);
	var roundradius = CSG.parseOptionAsFloat(options, "roundradius", 0.2);
	var resolution = CSG.parseOptionAsInt(options, "resolution", CSG.defaultResolution2D);
	var maxroundradius = Math.min(radius.x, radius.y);
	maxroundradius -= 0.1;
	roundradius = Math.min(roundradius, maxroundradius);
	roundradius = Math.max(0, roundradius);
	radius = new CSG.Vector2D(radius.x - roundradius, radius.y - roundradius);
	var rect = CAG.rectangle({
		center: center,
		radius: radius
	});
	if(roundradius > 0) {
		rect = rect.expand(roundradius, resolution);
	}
	return rect;
};

// Reconstruct a CAG from the output of toCompactBinary()
CAG.fromCompactBinary = function(bin) {
	if(bin['class'] != "CAG") throw new Error("Not a CAG");
	var vertices = [];
	var vertexData = bin.vertexData;
	var numvertices = vertexData.length / 2;
	var arrayindex = 0;
	for(var vertexindex = 0; vertexindex < numvertices; vertexindex++) {
		var x = vertexData[arrayindex++];
		var y = vertexData[arrayindex++];
		var pos = new CSG.Vector2D(x, y);
		var vertex = new CAG.Vertex(pos);
		vertices.push(vertex);
	}

	var sides = [];
	var numsides = bin.sideVertexIndices.length / 2;
	arrayindex = 0;
	for(var sideindex = 0; sideindex < numsides; sideindex++) {
		var vertexindex0 = bin.sideVertexIndices[arrayindex++];
		var vertexindex1 = bin.sideVertexIndices[arrayindex++];
		var side = new CAG.Side(vertices[vertexindex0], vertices[vertexindex1]);
		sides.push(side);
	}
	var cag = CAG.fromSides(sides);
	cag.isCanonicalized = true;
	return cag;
};

function fnSortByIndex(a, b) {
	return a.index - b.index;
}

CAG.prototype = {
	toString: function() {
		var result = "CAG (" + this.sides.length + " sides):\n";
		this.sides.map(function(side) {
			result += "  " + side.toString() + "\n";
		});
		return result;
	},

	toCSG: function(z0, z1) {
		var polygons = this.sides.map(function(side) {
			return side.toPolygon3D(z0, z1);
		});
		return CSG.fromPolygons(polygons);
	},

	toDebugString1: function() {
		this.sides.sort(function(a, b) {
			return a.vertex0.pos.x - b.vertex0.pos.x;
		});
		var str = "";
		this.sides.map(function(side) {
			str += "(" + side.vertex0.pos.x + "," + side.vertex0.pos.y + ") - (" + side.vertex1.pos.x + "," + side.vertex1.pos.y + ")\n";
		});
		return str;
	},

	toDebugString: function() {
		//    this.sides.sort(function(a,b){
		//      return a.vertex0.pos.x - b.vertex0.pos.x;
		//    });
		var str = "CAG.fromSides([\n";
		this.sides.map(function(side) {
			str += "  new CAG.Side(new CAG.Vertex(new CSG.Vector2D(" +
					side.vertex0.pos.x + "," + side.vertex0.pos.y +
				")), new CAG.Vertex(new CSG.Vector2D(" +
					side.vertex1.pos.x + "," + side.vertex1.pos.y + "))),\n";
		});
		str += "]);\n";
		return str;
	},

	union: function(cag) {
		var cags;
		if(cag instanceof Array) {
			cags = cag;
		} else {
			cags = [cag];
		}
		var r = this.toCSG(-1, 1);
		cags.map(function(cag) {
			r = r.unionSub(cag.toCSG(-1, 1), false, false);
		});
		r = r.reTesselated();
		r = r.canonicalized();
		cag = CAG.fromFakeCSG(r);
		var cag_canonicalized = cag.canonicalized();
		return cag_canonicalized;
	},

	subtract: function(cag) {
		var cags;
		if(cag instanceof Array) {
			cags = cag;
		} else {
			cags = [cag];
		}
		var r = this.toCSG(-1, 1);
		cags.map(function(cag) {
			r = r.subtractSub(cag.toCSG(-1, 1), false, false);
		});
		r = r.reTesselated();
		r = r.canonicalized();
		r = CAG.fromFakeCSG(r);
		r = r.canonicalized();
		return r;
	},

	intersect: function(cag) {
		var cags;
		if(cag instanceof Array) {
			cags = cag;
		} else {
			cags = [cag];
		}
		var r = this.toCSG(-1, 1);
		cags.map(function(cag) {
			r = r.intersectSub(cag.toCSG(-1, 1), false, false);
		});
		r = r.reTesselated();
		r = r.canonicalized();
		r = CAG.fromFakeCSG(r);
		r = r.canonicalized();
		return r;
	},

	transform: function(matrix4x4) {
		var ismirror = matrix4x4.isMirroring();
		var newsides = this.sides.map(function(side) {
			return side.transform(matrix4x4);
		});
		var result = CAG.fromSides(newsides);
		if(ismirror) {
			result = result.flipped();
		}
		return result;
	},

	// see http://local.wasp.uwa.edu.au/~pbourke/geometry/polyarea/ :
	// Area of the polygon. For a counter clockwise rotating polygon the area is positive, otherwise negative
	area: function() {
		var polygonArea = 0;
		this.sides.map(function(side) {
			polygonArea += side.vertex0.pos.cross(side.vertex1.pos);
		});
		polygonArea *= 0.5;
		return polygonArea;
	},

	flipped: function() {
		var newsides = this.sides.map(function(side) {
			return side.flipped();
		});
		newsides.reverse();
		return CAG.fromSides(newsides);
	},

	getBounds: function() {
		var minpoint;
		if(this.sides.length === 0) {
			minpoint = new CSG.Vector2D(0, 0);
		} else {
			minpoint = this.sides[0].vertex0.pos;
		}
		var maxpoint = minpoint;
		this.sides.map(function(side) {
			minpoint = minpoint.min(side.vertex0.pos);
			minpoint = minpoint.min(side.vertex1.pos);
			maxpoint = maxpoint.max(side.vertex0.pos);
			maxpoint = maxpoint.max(side.vertex1.pos);
		});
		return [minpoint, maxpoint];
	},

   center: function(c) {
      if(!c.length) c = [c,c];
      var b = this.getBounds();
      return this.translate([
         c[0]?-(b[1].x-b[0].x)/2-b[0].x:0,
         c[1]?-(b[1].y-b[0].y)/2-b[0].y:0]);
   },

	isSelfIntersecting: function() {
		var numsides = this.sides.length;
		for(var i = 0; i < numsides; i++) {
			var side0 = this.sides[i];
			for(var ii = i + 1; ii < numsides; ii++) {
				var side1 = this.sides[ii];
				if(CAG.linesIntersect(side0.vertex0.pos, side0.vertex1.pos, side1.vertex0.pos, side1.vertex1.pos)) {
					return true;
				}
			}
		}
		return false;
	},

	expandedShell: function(radius, resolution) {
		resolution = resolution || 8;
		if(resolution < 4) resolution = 4;
		var cags = [];
		var pointmap = {};
		var cag = this.canonicalized();
		cag.sides.map(function(side) {
			var d = side.vertex1.pos.minus(side.vertex0.pos);
			var dl = d.length();
			if(dl > 1e-5) {
				d = d.times(1.0 / dl);
				var normal = d.normal().times(radius);
				var shellpoints = [
					side.vertex1.pos.plus(normal),
					side.vertex1.pos.minus(normal),
					side.vertex0.pos.minus(normal),
					side.vertex0.pos.plus(normal)
				];
				//      var newcag = CAG.fromPointsNoCheck(shellpoints);
				var newcag = CAG.fromPoints(shellpoints);
				cags.push(newcag);
				for(var step = 0; step < 2; step++) {
					var p1 = (step === 0) ? side.vertex0.pos : side.vertex1.pos;
					var p2 = (step === 0) ? side.vertex1.pos : side.vertex0.pos;
					var tag = p1.x + " " + p1.y;
					if(!(tag in pointmap)) {
						pointmap[tag] = [];
					}
					pointmap[tag].push({
						"p1": p1,
						"p2": p2
					});
				}
			}
		});
		for(var tag in pointmap) {
			var m = pointmap[tag];
			var angle1, angle2;
			var pcenter = m[0].p1;
			if(m.length == 2) {
				var end1 = m[0].p2;
				var end2 = m[1].p2;
				angle1 = end1.minus(pcenter).angleDegrees();
				angle2 = end2.minus(pcenter).angleDegrees();
				if(angle2 < angle1) angle2 += 360;
				if(angle2 >= (angle1 + 360)) angle2 -= 360;
				if(angle2 < angle1 + 180) {
					var t = angle2;
					angle2 = angle1 + 360;
					angle1 = t;
				}
				angle1 += 90;
				angle2 -= 90;
			} else {
				angle1 = 0;
				angle2 = 360;
			}
			var fullcircle = (angle2 > angle1 + 359.999);
			if(fullcircle) {
				angle1 = 0;
				angle2 = 360;
			}
			if(angle2 > (angle1 + 1e-5)) {
				var points = [];
				if(!fullcircle) {
					points.push(pcenter);
				}
				var numsteps = Math.round(resolution * (angle2 - angle1) / 360);
				if(numsteps < 1) numsteps = 1;
				for(var step = 0; step <= numsteps; step++) {
					var angle = angle1 + step / numsteps * (angle2 - angle1);
					if(step == numsteps) angle = angle2; // prevent rounding errors
					var point = pcenter.plus(CSG.Vector2D.fromAngleDegrees(angle).times(radius));
					if((!fullcircle) || (step > 0)) {
						points.push(point);
					}
				}
				var newcag = CAG.fromPointsNoCheck(points);
				cags.push(newcag);
			}
		}
		var result = new CAG();
		result = result.union(cags);
		return result;
	},

	expand: function(radius, resolution) {
		var result = this.union(this.expandedShell(radius, resolution));
		return result;
	},

	contract: function(radius, resolution) {
		var result = this.subtract(this.expandedShell(radius, resolution));
		return result;
	},

	// extruded=cag.extrude({offset: [0,0,10], twistangle: 360, twiststeps: 100});
	// linear extrusion of 2D shape, with optional twist
	// The 2d shape is placed in in z=0 plane and extruded into direction <offset> (a CSG.Vector3D)
	// The final face is rotated <twistangle> degrees. Rotation is done around the origin of the 2d shape (i.e. x=0, y=0)
	// twiststeps determines the resolution of the twist (should be >= 1)
	// returns a CSG object
	extrude: function(options) {
		if(this.sides.length == 0) {
		// empty!
		return new CSG();
	}
	var offsetvector = CSG.parseOptionAs3DVector(options, "offset", [0,0,1]);
	var twistangle = CSG.parseOptionAsFloat(options, "twistangle", 0);
	var twiststeps = CSG.parseOptionAsInt(options, "twiststeps", 10);

	if(twistangle == 0) twiststeps = 1;
	if(twiststeps < 1) twiststeps = 1;

	var newpolygons = [];
	var prevtransformedcag;
	var prevstepz;
	for(var step=0; step <= twiststeps; step++) {
		var stepfraction = step / twiststeps;
		var transformedcag = this;
		var angle = twistangle * stepfraction;
		if(angle != 0) {
			transformedcag = transformedcag.rotateZ(angle);
		}
		var translatevector = new CSG.Vector2D(offsetvector.x, offsetvector.y).times(stepfraction);
		transformedcag = transformedcag.translate(translatevector);
		var bounds = transformedcag.getBounds();
		bounds[0] = bounds[0].minus(new CSG.Vector2D(1,1));
		bounds[1] = bounds[1].plus(new CSG.Vector2D(1,1));
		var stepz = offsetvector.z * stepfraction;
		if( (step == 0) || (step == twiststeps) ) {
			// bottom or top face:
			var csgshell = transformedcag.toCSG(stepz-1, stepz+1);
			var csgplane = CSG.fromPolygons([new CSG.Polygon([
				new CSG.Vertex(new CSG.Vector3D(bounds[0].x, bounds[0].y, stepz)),
				new CSG.Vertex(new CSG.Vector3D(bounds[1].x, bounds[0].y, stepz)),
				new CSG.Vertex(new CSG.Vector3D(bounds[1].x, bounds[1].y, stepz)),
				new CSG.Vertex(new CSG.Vector3D(bounds[0].x, bounds[1].y, stepz))
			])]);
			var flip = (step == 0);
			if(offsetvector.z < 0) flip = !flip;
			if(flip) {
				csgplane = csgplane.inverse();
			}
			csgplane = csgplane.intersect(csgshell);
			// only keep the polygons in the z plane:
			csgplane.polygons.map(function(polygon){
				if(Math.abs(polygon.plane.normal.z) > 0.99) {
					newpolygons.push(polygon);
				}
			});
		}
		if(step > 0) {
			var numsides = transformedcag.sides.length;
			for(var sideindex = 0; sideindex < numsides; sideindex++) {
				var thisside = transformedcag.sides[sideindex];
				var prevside = prevtransformedcag.sides[sideindex];
				var p1 = new CSG.Polygon([
					new CSG.Vertex(thisside.vertex1.pos.toVector3D(stepz)),
					new CSG.Vertex(thisside.vertex0.pos.toVector3D(stepz)),
					new CSG.Vertex(prevside.vertex0.pos.toVector3D(prevstepz))
				]);
				var p2 = new CSG.Polygon([
					new CSG.Vertex(thisside.vertex1.pos.toVector3D(stepz)),
					new CSG.Vertex(prevside.vertex0.pos.toVector3D(prevstepz)),
					new CSG.Vertex(prevside.vertex1.pos.toVector3D(prevstepz))
				]);
				if(offsetvector.z < 0) {
					p1 = p1.flipped();
					p2 = p2.flipped();
				}
				newpolygons.push(p1);
				newpolygons.push(p2);
			}
		}
		prevtransformedcag = transformedcag;
		prevstepz = stepz;
	} // for step
	return CSG.fromPolygons(newpolygons);
	},

	// check if we are a valid CAG (for debugging)
	check: function() {
		var errors = [];
		if(this.isSelfIntersecting()) {
			errors.push("Self intersects");
		}
		var pointcount = {};
		this.sides.map(function(side) {
			function mappoint(p) {
				var tag = p.x + " " + p.y;
				if(!(tag in pointcount)) pointcount[tag] = 0;
				pointcount[tag]++;
			}
			mappoint(side.vertex0.pos);
			mappoint(side.vertex1.pos);
		});
		for(var tag in pointcount) {
			var count = pointcount[tag];
			if(count & 1) {
				errors.push("Uneven number of sides (" + count + ") for point " + tag);
			}
		}
		var area = this.area();
		if(area < 1e-5) {
			errors.push("Area is " + area);
		}
		if(errors.length > 0) {
			var ertxt = "";
			errors.map(function(err) {
				ertxt += err + "\n";
			});
			throw new Error(ertxt);
		}
	},

	canonicalized: function() {
		if(this.isCanonicalized) {
			return this;
		} else {
			var factory = new CAG.fuzzyCAGFactory();
			var result = factory.getCAG(this);
			result.isCanonicalized = true;
			return result;
		}
	},

	toCompactBinary: function() {
		var cag = this.canonicalized();
		var numsides = cag.sides.length;
		var vertexmap = {};
		var vertices = [];
		var numvertices = 0;
		var sideVertexIndices = new Uint32Array(2 * numsides);
		var sidevertexindicesindex = 0;
		cag.sides.map(function(side) {
			[side.vertex0, side.vertex1].map(function(v) {
				var vertextag = v.getTag();
				var vertexindex;
				if(!(vertextag in vertexmap)) {
					vertexindex = numvertices++;
					vertexmap[vertextag] = vertexindex;
					vertices.push(v);
				} else {
					vertexindex = vertexmap[vertextag];
				}
				sideVertexIndices[sidevertexindicesindex++] = vertexindex;
			});
		});
		var vertexData = new Float64Array(numvertices * 2);
		var verticesArrayIndex = 0;
		vertices.map(function(v) {
			var pos = v.pos;
			vertexData[verticesArrayIndex++] = pos._x;
			vertexData[verticesArrayIndex++] = pos._y;
		});
		var result = {
			'class': "CAG",
			sideVertexIndices: sideVertexIndices,
			vertexData: vertexData
		};
		return result;
	},

	getOutlinePaths: function() {
		var cag = this.canonicalized();
		var sideTagToSideMap = {};
		var startVertexTagToSideTagMap = {};
		cag.sides.map(function(side) {
			var sidetag = side.getTag();
			sideTagToSideMap[sidetag] = side;
			var startvertextag = side.vertex0.getTag();
			if(!(startvertextag in startVertexTagToSideTagMap)) {
				startVertexTagToSideTagMap[startvertextag] = [];
			}
			startVertexTagToSideTagMap[startvertextag].push(sidetag);
		});
		var paths = [];
		while(true) {
			var startsidetag = null;
			for(var aVertexTag in startVertexTagToSideTagMap) {
				var sidesForThisVertex = startVertexTagToSideTagMap[aVertexTag];
				startsidetag = sidesForThisVertex[0];
				sidesForThisVertex.splice(0, 1);
				if(sidesForThisVertex.length === 0) {
					delete startVertexTagToSideTagMap[aVertexTag];
				}
				break;
			}
			if(startsidetag === null) break; // we've had all sides
			var connectedVertexPoints = [];
			var sidetag = startsidetag;
			var thisside = sideTagToSideMap[sidetag];
			var startvertextag = thisside.vertex0.getTag();
			while(true) {
				connectedVertexPoints.push(thisside.vertex0.pos);
				var nextvertextag = thisside.vertex1.getTag();
				if(nextvertextag == startvertextag) break; // we've closed the polygon
				if(!(nextvertextag in startVertexTagToSideTagMap)) {
					throw new Error("Area is not closed!");
				}
				var nextpossiblesidetags = startVertexTagToSideTagMap[nextvertextag];
				var nextsideindex = -1;
				if(nextpossiblesidetags.length == 1) {
					nextsideindex = 0;
				} else {
					// more than one side starting at the same vertex. This means we have
					// two shapes touching at the same corner
					var bestangle = null;
					var thisangle = thisside.direction().angleDegrees();
					for(var sideindex = 0; sideindex < nextpossiblesidetags.length; sideindex++) {
						var nextpossiblesidetag = nextpossiblesidetags[sideindex];
						var possibleside = sideTagToSideMap[nextpossiblesidetag];
						var angle = possibleside.direction().angleDegrees();
						var angledif = angle - thisangle;
						if(angledif < -180) angledif += 360;
						if(angledif >= 180) angledif -= 360;
						if((nextsideindex < 0) || (angledif > bestangle)) {
							nextsideindex = sideindex;
							bestangle = angledif;
						}
					}
				}
				var nextsidetag = nextpossiblesidetags[nextsideindex];
				nextpossiblesidetags.splice(nextsideindex, 1);
				if(nextpossiblesidetags.length === 0) {
					delete startVertexTagToSideTagMap[nextvertextag];
				}
				thisside = sideTagToSideMap[nextsidetag];
			} // inner loop
			var path = new CSG.Path2D(connectedVertexPoints, true);
			paths.push(path);
		} // outer loop
		return paths;
	},

	toDxfString: function() {
		var paths = this.getOutlinePaths();
		return CAG.PathsToDxfString(paths);
	},
	toDxf: function() {
		var paths = this.getOutlinePaths();
		return CAG.PathsToDxf(paths);
	}
};

CAG.PathsToDxfString = function(paths) {
	var str = "999\nDXF generated by OpenJsCad\n";
	str += "  0\nSECTION\n  2\nHEADER\n";
	str += "  0\nENDSEC\n";
	str += "  0\nSECTION\n  2\nTABLES\n";
	str += "  0\nTABLE\n  2\nLTYPE\n  70\n1\n";
	str += "  0\nLTYPE\n  2\nCONTINUOUS\n  3\nSolid Line\n  72\n65\n  73\n0\n  40\n0.0\n";
	str += "  0\nENDTAB\n";
	str += "  0\nTABLE\n  2\nLAYER\n  70\n1\n";
	str += "  0\nLAYER\n  2\nOpenJsCad\n  62\n7\n  6\ncontinuous\n";
	str += "  0\nENDTAB\n";
	str += "  0\nTABLE\n  2\nSTYLE\n  70\n0\n  0\nENDTAB\n";
	str += "  0\nTABLE\n  2\nVIEW\n  70\n0\n  0\nENDTAB\n";
	str += "  0\nENDSEC\n";
	str += "  0\nSECTION\n  2\nBLOCKS\n";
	str += "  0\nENDSEC\n";
	str += "  0\nSECTION\n  2\nENTITIES\n";
	paths.map(function(path) {
		var numpoints_closed = path.points.length + (path.closed ? 1 : 0);
		str += "  0\nLWPOLYLINE\n  8\nOpenJsCad\n  90\n" + numpoints_closed + "\n  70\n" + (path.closed ? 1 : 0) + "\n";
		for(var pointindex = 0; pointindex < numpoints_closed; pointindex++) {
			var pointindexwrapped = pointindex;
			if(pointindexwrapped >= path.points.length) pointindexwrapped -= path.points.length;
			var point = path.points[pointindexwrapped];
			str += " 10\n" + point.x + "\n 20\n" + point.y + "\n 30\n0.0\n";
		}
	});
	str += "  0\nENDSEC\n  0\nEOF\n";
    return str;
}

CAG.PathsToDxf = function(paths) {
    var str = CAG.PathsToDxfString(paths);

	return new Blob([str], {
		type: "application/dxf"
	});
};

CAG.Vertex = function(pos) {
	this.pos = pos;
};

CAG.Vertex.prototype = {
	toString: function() {
		return "("+this.pos.x.toFixed(2)+","+this.pos.y.toFixed(2)+")";
	},
	getTag: function() {
		var result = this.tag;
		if(!result) {
			result = CSG.getTag();
			this.tag = result;
		}
		return result;
	}
};

CAG.Side = function(vertex0, vertex1) {
	if(!(vertex0 instanceof CAG.Vertex)) throw new Error("Assertion failed");
	if(!(vertex1 instanceof CAG.Vertex)) throw new Error("Assertion failed");
	this.vertex0 = vertex0;
	this.vertex1 = vertex1;
};

CAG.Side.fromFakePolygon = function(polygon) {
	if(polygon.vertices.length != 4) {
		throw new Error("Assertion failed - 1");
	}
	var pointsZeroZ = [];
	var indicesZeroZ = [];
	for(var i = 0; i < 4; i++) {
		var pos = polygon.vertices[i].pos;
		if((pos.z >= -1.001) && (pos.z < -0.999)) {
		} else if((pos.z >= 0.999) && (pos.z < 1.001)) {
		} else {
			throw new Error("Assertion failed - 2");
		}
		if(pos.z > 0) {
			pointsZeroZ.push(new CSG.Vector2D(pos.x, pos.y));
			indicesZeroZ.push(i);
		}
	}
	if(pointsZeroZ.length != 2) {
		throw new Error("Assertion failed - 3");
	}
	var d = indicesZeroZ[1] - indicesZeroZ[0];
	var p1, p2;
	if(d == 1) {
		p1 = pointsZeroZ[1];
		p2 = pointsZeroZ[0];
	} else if(d == 3) {
		p1 = pointsZeroZ[0];
		p2 = pointsZeroZ[1];
	} else {
		throw new Error("Assertion failed - 4");
	}
	var result = new CAG.Side(new CAG.Vertex(p1), new CAG.Vertex(p2));
	return result;
};

CAG.Side.prototype = {
	toString: function() {
		return this.vertex0 + " -> "+ this.vertex1;
	},

	toPolygon3D: function(z0, z1) {
		var vertices = [
			new CSG.Vertex(this.vertex0.pos.toVector3D(z0)),
			new CSG.Vertex(this.vertex1.pos.toVector3D(z0)),
			new CSG.Vertex(this.vertex1.pos.toVector3D(z1)),
			new CSG.Vertex(this.vertex0.pos.toVector3D(z1))
		];
		return new CSG.Polygon(vertices);
	},

	transform: function(matrix4x4) {
		var newp1 = this.vertex0.pos.transform(matrix4x4);
		var newp2 = this.vertex1.pos.transform(matrix4x4);
		return new CAG.Side(new CAG.Vertex(newp1), new CAG.Vertex(newp2));
	},

	flipped: function() {
		return new CAG.Side(this.vertex1, this.vertex0);
	},

	direction: function() {
		return this.vertex1.pos.minus(this.vertex0.pos);
	},

	getTag: function() {
		var result = this.tag;
		if(!result) {
			result = CSG.getTag();
			this.tag = result;
		}
		return result;
	},

	lengthSquared: function() {
		var x = this.vertex1.pos.x - this.vertex0.pos.x,
		y = this.vertex1.pos.y - this.vertex0.pos.y;
		return x*x + y*y;
	},

	length: function() {
		return Math.sqrt(this.lengthSquared());
	}
};

//////////////////////////////////////
CAG.fuzzyCAGFactory = function() {
	this.vertexfactory = new CSG.fuzzyFactory(2, 1e-5);
};

CAG.fuzzyCAGFactory.prototype = {
	getVertex: function(sourcevertex) {
		var elements = [sourcevertex.pos._x, sourcevertex.pos._y];
		var result = this.vertexfactory.lookupOrCreate(elements, function(els) {
			return sourcevertex;
		});
		return result;
	},

	getSide: function(sourceside) {
		var vertex0 = this.getVertex(sourceside.vertex0);
		var vertex1 = this.getVertex(sourceside.vertex1);
		return new CAG.Side(vertex0, vertex1);
	},

	getCAG: function(sourcecag) {
		var _this = this;
		var newsides = sourcecag.sides.map(function(side) {
			return _this.getSide(side);
		});
		return CAG.fromSides(newsides);
	}
};

//////////////////////////////////////
CSG.addTransformationMethodsToPrototype(CSG.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Vector2D.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Vector3D.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Vertex.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Plane.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Polygon.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Line3D.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Connector.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Path2D.prototype);
CSG.addTransformationMethodsToPrototype(CSG.Line2D.prototype);
CSG.addTransformationMethodsToPrototype(CAG.prototype);
CSG.addTransformationMethodsToPrototype(CAG.Side.prototype);

/*
  2D polygons are now supported through the CAG class.
  With many improvements (see documentation):
	- shapes do no longer have to be convex
	- union/intersect/subtract is supported
	- expand / contract are supported

  But we'll keep CSG.Polygon2D as a stub for backwards compatibility
*/
CSG.Polygon2D = function(points) {
	var cag = CAG.fromPoints(points);
	this.sides = cag.sides;
};
CSG.Polygon2D.prototype = CAG.prototype;


module.CSG = CSG;
module.CAG = CAG;
})(toplevel); //module to export to

});
require.register("jonnor-noflo-cad/index.js", function(exports, require, module){
/*
 * This file can be used for general library features of noflo-cad.
 *
 * The library features can be made available as CommonJS modules that the
 * components in this project utilize.
 */

});
require.register("jonnor-noflo-cad/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-cad","description":"CAD components for NoFlo","author":"Jon Nordby <jononor@gmail.com>","repo":"jonnor/noflo-cad","version":"0.0.1","keywords":["CAD","CSG","CNC","solid modelling","3d printing"],"dependencies":{"noflo/noflo":"*","jonnor/OpenJSCADorg":"*"},"scripts":["components/Cube.coffee","components/RoundedRectangle.coffee","components/Rectangle.coffee","components/LinearExtrude.coffee","components/Translate.coffee","components/Subtract.coffee","components/Intersect.coffee","components/Union.coffee","components/ToSTL.coffee","components/ToDXF.coffee","components/ToOutlinePaths.coffee","components/Viewer.coffee","index.js"],"json":["component.json"],"noflo":{"icon":"comments","components":{"Cube":"components/Cube.coffee","Rectangle":"components/Rectangle.coffee","RoundedRectangle":"components/RoundedRectangle.coffee","LinearExtrude":"components/LinearExtrude.coffee","Translate":"components/Translate.coffee","Subtract":"components/Subtract.coffee","Intersect":"components/Intersect.coffee","Union":"components/Union.coffee","ToSTL":"components/ToSTL.coffee","ToDXF":"components/ToDXF.coffee","ToOutlinePaths":"components/ToOutlinePaths.coffee","Viewer":"components/Viewer.coffee"}}}');
});
require.register("jonnor-noflo-cad/components/Cube.js", function(exports, require, module){
var Cube, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

Cube = (function(_super) {
  __extends(Cube, _super);

  function Cube() {
    this.inPorts = {
      radius: new noflo.Port('number')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.radius.on('data', (function(_this) {
      return function(data) {
        var o;
        o = csg.CSG.cube({
          radius: data
        });
        return _this.outPorts.out.send(o);
      };
    })(this));
  }

  return Cube;

})(noflo.Component);

exports.getComponent = function() {
  return new Cube;
};

});
require.register("jonnor-noflo-cad/components/RoundedRectangle.js", function(exports, require, module){
var RoundedRectangle, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

RoundedRectangle = (function(_super) {
  __extends(RoundedRectangle, _super);

  function RoundedRectangle() {
    this.width = null;
    this.height = null;
    this.roundRadius = 1;
    this.inPorts = {
      width: new noflo.Port('number'),
      height: new noflo.Port('number'),
      roundradius: new noflo.Port('number')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.width.on('data', (function(_this) {
      return function(data) {
        _this.width = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.height.on('data', (function(_this) {
      return function(data) {
        _this.height = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.roundradius.on('data', (function(_this) {
      return function(data) {
        _this.roundRadius = data;
        return _this.compute();
      };
    })(this));
  }

  RoundedRectangle.prototype.compute = function() {
    var d, o;
    if ((this.width != null) && (this.height != null)) {
      d = {
        radius: [this.width / 2.0, this.height / 2.0],
        roundradius: this.roundRadius
      };
      o = csg.CAG.roundedRectangle(d);
      return this.outPorts.out.send(o);
    }
  };

  return RoundedRectangle;

})(noflo.Component);

exports.getComponent = function() {
  return new RoundedRectangle;
};

});
require.register("jonnor-noflo-cad/components/Rectangle.js", function(exports, require, module){
var Rectangle, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

Rectangle = (function(_super) {
  __extends(Rectangle, _super);

  function Rectangle() {
    this.width = null;
    this.height = null;
    this.inPorts = {
      width: new noflo.Port('number'),
      height: new noflo.Port('number')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.width.on('data', (function(_this) {
      return function(data) {
        _this.width = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.height.on('data', (function(_this) {
      return function(data) {
        _this.height = data;
        return _this.compute();
      };
    })(this));
  }

  Rectangle.prototype.compute = function() {
    var o;
    if ((this.width != null) && (this.height != null)) {
      o = csg.CAG.rectangle({
        radius: [this.width / 2.0, this.height / 2.0]
      });
      return this.outPorts.out.send(o);
    }
  };

  return Rectangle;

})(noflo.Component);

exports.getComponent = function() {
  return new Rectangle;
};

});
require.register("jonnor-noflo-cad/components/LinearExtrude.js", function(exports, require, module){
var LinearExtrude, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

LinearExtrude = (function(_super) {
  __extends(LinearExtrude, _super);

  function LinearExtrude() {
    this.model = null;
    this.height = null;
    this.inPorts = {
      model: new noflo.Port('object'),
      height: new noflo.Port('number')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.model.on('data', (function(_this) {
      return function(data) {
        _this.model = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.height.on('data', (function(_this) {
      return function(data) {
        _this.height = data;
        return _this.compute();
      };
    })(this));
  }

  LinearExtrude.prototype.compute = function() {
    var d, o;
    if (this.model && this.height) {
      d = {
        offset: [0, 0, this.height]
      };
      o = this.model.extrude(d);
      return this.outPorts.out.send(o);
    }
  };

  return LinearExtrude;

})(noflo.Component);

exports.getComponent = function() {
  return new LinearExtrude;
};

});
require.register("jonnor-noflo-cad/components/Translate.js", function(exports, require, module){
var Translate, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

Translate = (function(_super) {
  __extends(Translate, _super);

  function Translate() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.model = null;
    this.inPorts = {
      model: new noflo.Port('object'),
      x: new noflo.Port('number'),
      y: new noflo.Port('number'),
      z: new noflo.Port('number')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.x.on('data', (function(_this) {
      return function(data) {
        _this.x = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.y.on('data', (function(_this) {
      return function(data) {
        _this.y = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.z.on('data', (function(_this) {
      return function(data) {
        _this.z = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.model.on('data', (function(_this) {
      return function(data) {
        _this.model = data;
        return _this.compute();
      };
    })(this));
  }

  Translate.prototype.compute = function() {
    var o;
    if (this.model) {
      o = this.model.translate([this.x, this.y, this.z]);
      return this.outPorts.out.send(o);
    }
  };

  return Translate;

})(noflo.Component);

exports.getComponent = function() {
  return new Translate;
};

});
require.register("jonnor-noflo-cad/components/Subtract.js", function(exports, require, module){
var Subtract, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

Subtract = (function(_super) {
  __extends(Subtract, _super);

  function Subtract() {
    this.modelA = null;
    this.modelB = null;
    this.inPorts = {
      a: new noflo.Port('object'),
      b: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.a.on('data', (function(_this) {
      return function(data) {
        _this.modelA = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.b.on('data', (function(_this) {
      return function(data) {
        _this.modelB = data;
        return _this.compute();
      };
    })(this));
  }

  Subtract.prototype.compute = function() {
    var o;
    if (this.modelA && this.modelB) {
      o = this.modelA.subtract(this.modelB);
      return this.outPorts.out.send(o);
    }
  };

  return Subtract;

})(noflo.Component);

exports.getComponent = function() {
  return new Subtract;
};

});
require.register("jonnor-noflo-cad/components/Intersect.js", function(exports, require, module){
var Intersect, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

Intersect = (function(_super) {
  __extends(Intersect, _super);

  function Intersect() {
    this.modelA = null;
    this.modelB = null;
    this.inPorts = {
      a: new noflo.Port('object'),
      b: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.a.on('data', (function(_this) {
      return function(data) {
        _this.modelA = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.b.on('data', (function(_this) {
      return function(data) {
        _this.modelB = data;
        return _this.compute();
      };
    })(this));
  }

  Intersect.prototype.compute = function() {
    var o;
    if (this.modelA && this.modelB) {
      o = this.modelA.intersect(this.modelB);
      return this.outPorts.out.send(o);
    }
  };

  return Intersect;

})(noflo.Component);

exports.getComponent = function() {
  return new Intersect;
};

});
require.register("jonnor-noflo-cad/components/Union.js", function(exports, require, module){
var Union, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

Union = (function(_super) {
  __extends(Union, _super);

  function Union() {
    this.modelA = null;
    this.modelB = null;
    this.inPorts = {
      a: new noflo.Port('object'),
      b: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.a.on('data', (function(_this) {
      return function(data) {
        _this.modelA = data;
        return _this.compute();
      };
    })(this));
    this.inPorts.b.on('data', (function(_this) {
      return function(data) {
        _this.modelB = data;
        return _this.compute();
      };
    })(this));
  }

  Union.prototype.compute = function() {
    var o;
    if (this.modelA && this.modelB) {
      o = this.modelA.union(this.modelB);
      return this.outPorts.out.send(o);
    }
  };

  return Union;

})(noflo.Component);

exports.getComponent = function() {
  return new Union;
};

});
require.register("jonnor-noflo-cad/components/ToSTL.js", function(exports, require, module){
var ToSTL, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

ToSTL = (function(_super) {
  __extends(ToSTL, _super);

  function ToSTL() {
    this.inPorts = {
      model: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.model.on('data', (function(_this) {
      return function(data) {
        var o;
        o = data.toStlString();
        return _this.outPorts.out.send(o);
      };
    })(this));
  }

  return ToSTL;

})(noflo.Component);

exports.getComponent = function() {
  return new ToSTL;
};

});
require.register("jonnor-noflo-cad/components/ToDXF.js", function(exports, require, module){
var ToDXF, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

ToDXF = (function(_super) {
  __extends(ToDXF, _super);

  function ToDXF() {
    this.inPorts = {
      model: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.model.on('data', (function(_this) {
      return function(data) {
        var o;
        o = data.toDxfString();
        return _this.outPorts.out.send(o);
      };
    })(this));
  }

  return ToDXF;

})(noflo.Component);

exports.getComponent = function() {
  return new ToDXF;
};

});
require.register("jonnor-noflo-cad/components/ToOutlinePaths.js", function(exports, require, module){
var ToOutlinePaths, csg, noflo,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

csg = require('OpenJSCADorg/csg.js');

ToOutlinePaths = (function(_super) {
  __extends(ToOutlinePaths, _super);

  function ToOutlinePaths() {
    this.inPorts = {
      model: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('string')
    };
    this.inPorts.model.on('data', (function(_this) {
      return function(data) {
        var o;
        o = data.getOutlinePaths();
        return _this.outPorts.out.send(o);
      };
    })(this));
  }

  return ToOutlinePaths;

})(noflo.Component);

exports.getComponent = function() {
  return new ToOutlinePaths;
};

});
require.register("jonnor-noflo-cad/components/Viewer.js", function(exports, require, module){
var Viewer, noflo, openjscad,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

noflo = require('noflo');

openjscad = require('OpenJSCADorg/openjscad.js');

Viewer = (function(_super) {
  __extends(Viewer, _super);

  function Viewer() {
    this.width = null;
    this.height = null;
    this.depth = null;
    this.container = null;
    this.viewer = null;
    this.model = null;
    this.inPorts = {
      width: new noflo.Port('number'),
      height: new noflo.Port('number'),
      depth: new noflo.Port('number'),
      container: new noflo.Port('object'),
      model: new noflo.Port('object')
    };
    this.outPorts = {
      out: new noflo.Port('object')
    };
    this.inPorts.width.on('data', (function(_this) {
      return function(data) {
        _this.width = data;
        return _this.init();
      };
    })(this));
    this.inPorts.height.on('data', (function(_this) {
      return function(data) {
        _this.height = data;
        return _this.init();
      };
    })(this));
    this.inPorts.depth.on('data', (function(_this) {
      return function(data) {
        _this.depth = data;
        return _this.init();
      };
    })(this));
    this.inPorts.container.on('data', (function(_this) {
      return function(data) {
        _this.container = data;
        return _this.init();
      };
    })(this));
    this.inPorts.model.on('data', (function(_this) {
      return function(data) {
        _this.model = data;
        if (_this.viewer) {
          return _this.viewer.setCsg(_this.model);
        }
      };
    })(this));
  }

  Viewer.prototype.init = function() {
    if ((this.width != null) && (this.height != null) && (this.depth != null) && (this.container != null)) {
      this.viewer = new openjscad.Viewer(this.container, this.width, this.height, this.depth);
      if (this.model) {
        return this.viewer.setCsg(this.model);
      }
    }
  };

  return Viewer;

})(noflo.Component);

exports.getComponent = function() {
  return new Viewer;
};

});
require.register("noflo-ui-preview/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo-ui-preview","description":"NoFlo runtime environment for client-side previews","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"noflo/noflo-ui","keywords":[],"dependencies":{"noflo/noflo":"*","noflo/noflo-runtime-iframe":"*","noflo/noflo-ajax":"*","noflo/noflo-core":"*","noflo/noflo-css":"*","noflo/noflo-dom":"*","noflo/noflo-flow":"*","noflo/noflo-gestures":"*","noflo/noflo-groups":"*","noflo/noflo-interaction":"*","noflo/noflo-localstorage":"*","noflo/noflo-math":"*","noflo/noflo-objects":"*","noflo/noflo-packets":"*","noflo/noflo-physics":"*","noflo/noflo-routers":"*","noflo/noflo-strings":"*","noflo/noflo-websocket":"*","noflo/noflo-indexeddb":"*","noflo/noflo-github":"*","noflo/noflo-finitedomain":"*","d4tocchini/noflo-draggabilly":"*","forresto/noflo-gum":"*","forresto/noflo-seriously":"*","jonnor/noflo-cad":"*"},"json":["component.json"],"files":["iframe.html"]}');
});



























require.alias("noflo-noflo/component.json", "noflo-ui-preview/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-ui-preview/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-ui-preview/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-ui-preview/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-ui-preview/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-ui-preview/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-ui-preview/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-ui-preview/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-ui-preview/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-ui-preview/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-ui-preview/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-ui-preview/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-ui-preview/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-ui-preview/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-ui-preview/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-ui-preview/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-ui-preview/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-ui-preview/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-ui-preview/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-ui-preview/deps/noflo/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-runtime-iframe/index.js", "noflo-ui-preview/deps/noflo-runtime-iframe/index.js");
require.alias("noflo-noflo-runtime-iframe/component.json", "noflo-ui-preview/deps/noflo-runtime-iframe/component.json");
require.alias("noflo-noflo-runtime-iframe/index.js", "noflo-runtime-iframe/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-runtime-iframe/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-runtime-iframe/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-runtime-iframe/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-iframe/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-runtime-base/src/Base.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/Base.js");
require.alias("noflo-noflo-runtime-base/src/protocol/Graph.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/protocol/Graph.js");
require.alias("noflo-noflo-runtime-base/src/protocol/Network.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/protocol/Network.js");
require.alias("noflo-noflo-runtime-base/src/protocol/Component.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/src/protocol/Component.js");
require.alias("noflo-noflo-runtime-base/src/Base.js", "noflo-noflo-runtime-iframe/deps/noflo-runtime-base/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-runtime-base/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-runtime-base/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-runtime-base/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-runtime-base/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-runtime-base/src/Base.js", "noflo-noflo-runtime-base/index.js");
require.alias("noflo-noflo-core/index.js", "noflo-noflo-runtime-iframe/deps/noflo-core/index.js");
require.alias("noflo-noflo-core/component.json", "noflo-noflo-runtime-iframe/deps/noflo-core/component.json");
require.alias("noflo-noflo-core/components/Callback.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Callback.js");
require.alias("noflo-noflo-core/components/DisconnectAfterPacket.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/DisconnectAfterPacket.js");
require.alias("noflo-noflo-core/components/Drop.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Drop.js");
require.alias("noflo-noflo-core/components/Group.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Group.js");
require.alias("noflo-noflo-core/components/Kick.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Kick.js");
require.alias("noflo-noflo-core/components/Merge.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Merge.js");
require.alias("noflo-noflo-core/components/Output.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Output.js");
require.alias("noflo-noflo-core/components/Repeat.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Repeat.js");
require.alias("noflo-noflo-core/components/RepeatAsync.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/RepeatAsync.js");
require.alias("noflo-noflo-core/components/Split.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/Split.js");
require.alias("noflo-noflo-core/components/RunInterval.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/RunInterval.js");
require.alias("noflo-noflo-core/components/RunTimeout.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/RunTimeout.js");
require.alias("noflo-noflo-core/components/MakeFunction.js", "noflo-noflo-runtime-iframe/deps/noflo-core/components/MakeFunction.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-core/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-core/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-core/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-core/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-core/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-core/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-core/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-core/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-core/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-core/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-core/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-core/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-core/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-core/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-core/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-core/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-core/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-core/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-core/deps/underscore/index.js");

require.alias("noflo-noflo-flow/index.js", "noflo-noflo-runtime-iframe/deps/noflo-flow/index.js");
require.alias("noflo-noflo-flow/component.json", "noflo-noflo-runtime-iframe/deps/noflo-flow/component.json");
require.alias("noflo-noflo-flow/components/Concat.js", "noflo-noflo-runtime-iframe/deps/noflo-flow/components/Concat.js");
require.alias("noflo-noflo-flow/components/Gate.js", "noflo-noflo-runtime-iframe/deps/noflo-flow/components/Gate.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-flow/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-flow/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-flow/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-flow/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-flow/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-flow/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-flow/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-flow/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-flow/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-flow/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-flow/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-flow/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-flow/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-flow/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-flow/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-flow/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-ajax/index.js", "noflo-ui-preview/deps/noflo-ajax/index.js");
require.alias("noflo-noflo-ajax/component.json", "noflo-ui-preview/deps/noflo-ajax/component.json");
require.alias("noflo-noflo-ajax/components/Get.js", "noflo-ui-preview/deps/noflo-ajax/components/Get.js");
require.alias("noflo-noflo-ajax/components/GetJsonP.js", "noflo-ui-preview/deps/noflo-ajax/components/GetJsonP.js");
require.alias("noflo-noflo-ajax/index.js", "noflo-ajax/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-ajax/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-ajax/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-ajax/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-ajax/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-ajax/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-ajax/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-ajax/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-ajax/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-ajax/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-ajax/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-ajax/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-ajax/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-ajax/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-ajax/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-ajax/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-ajax/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-ajax/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-ajax/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-ajax/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-ajax/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-core/index.js", "noflo-ui-preview/deps/noflo-core/index.js");
require.alias("noflo-noflo-core/component.json", "noflo-ui-preview/deps/noflo-core/component.json");
require.alias("noflo-noflo-core/components/Callback.js", "noflo-ui-preview/deps/noflo-core/components/Callback.js");
require.alias("noflo-noflo-core/components/DisconnectAfterPacket.js", "noflo-ui-preview/deps/noflo-core/components/DisconnectAfterPacket.js");
require.alias("noflo-noflo-core/components/Drop.js", "noflo-ui-preview/deps/noflo-core/components/Drop.js");
require.alias("noflo-noflo-core/components/Group.js", "noflo-ui-preview/deps/noflo-core/components/Group.js");
require.alias("noflo-noflo-core/components/Kick.js", "noflo-ui-preview/deps/noflo-core/components/Kick.js");
require.alias("noflo-noflo-core/components/Merge.js", "noflo-ui-preview/deps/noflo-core/components/Merge.js");
require.alias("noflo-noflo-core/components/Output.js", "noflo-ui-preview/deps/noflo-core/components/Output.js");
require.alias("noflo-noflo-core/components/Repeat.js", "noflo-ui-preview/deps/noflo-core/components/Repeat.js");
require.alias("noflo-noflo-core/components/RepeatAsync.js", "noflo-ui-preview/deps/noflo-core/components/RepeatAsync.js");
require.alias("noflo-noflo-core/components/Split.js", "noflo-ui-preview/deps/noflo-core/components/Split.js");
require.alias("noflo-noflo-core/components/RunInterval.js", "noflo-ui-preview/deps/noflo-core/components/RunInterval.js");
require.alias("noflo-noflo-core/components/RunTimeout.js", "noflo-ui-preview/deps/noflo-core/components/RunTimeout.js");
require.alias("noflo-noflo-core/components/MakeFunction.js", "noflo-ui-preview/deps/noflo-core/components/MakeFunction.js");
require.alias("noflo-noflo-core/index.js", "noflo-core/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-core/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-core/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-core/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-core/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-core/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-core/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-core/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-core/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-core/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-core/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-core/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-core/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-core/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-core/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-core/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-core/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-core/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-core/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-core/deps/underscore/index.js");

require.alias("noflo-noflo-css/index.js", "noflo-ui-preview/deps/noflo-css/index.js");
require.alias("noflo-noflo-css/component.json", "noflo-ui-preview/deps/noflo-css/component.json");
require.alias("noflo-noflo-css/components/MoveElement.js", "noflo-ui-preview/deps/noflo-css/components/MoveElement.js");
require.alias("noflo-noflo-css/components/RotateElement.js", "noflo-ui-preview/deps/noflo-css/components/RotateElement.js");
require.alias("noflo-noflo-css/components/SetElementTop.js", "noflo-ui-preview/deps/noflo-css/components/SetElementTop.js");
require.alias("noflo-noflo-css/index.js", "noflo-css/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-css/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-css/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-css/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-css/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-css/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-css/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-css/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-css/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-css/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-css/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-css/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-css/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-css/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-css/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-css/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-css/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-css/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-css/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-css/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-css/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-dom/index.js", "noflo-ui-preview/deps/noflo-dom/index.js");
require.alias("noflo-noflo-dom/component.json", "noflo-ui-preview/deps/noflo-dom/component.json");
require.alias("noflo-noflo-dom/components/AddClass.js", "noflo-ui-preview/deps/noflo-dom/components/AddClass.js");
require.alias("noflo-noflo-dom/components/AppendChild.js", "noflo-ui-preview/deps/noflo-dom/components/AppendChild.js");
require.alias("noflo-noflo-dom/components/CreateElement.js", "noflo-ui-preview/deps/noflo-dom/components/CreateElement.js");
require.alias("noflo-noflo-dom/components/CreateFragment.js", "noflo-ui-preview/deps/noflo-dom/components/CreateFragment.js");
require.alias("noflo-noflo-dom/components/GetAttribute.js", "noflo-ui-preview/deps/noflo-dom/components/GetAttribute.js");
require.alias("noflo-noflo-dom/components/GetElement.js", "noflo-ui-preview/deps/noflo-dom/components/GetElement.js");
require.alias("noflo-noflo-dom/components/HasClass.js", "noflo-ui-preview/deps/noflo-dom/components/HasClass.js");
require.alias("noflo-noflo-dom/components/ReadHtml.js", "noflo-ui-preview/deps/noflo-dom/components/ReadHtml.js");
require.alias("noflo-noflo-dom/components/RemoveElement.js", "noflo-ui-preview/deps/noflo-dom/components/RemoveElement.js");
require.alias("noflo-noflo-dom/components/SetAttribute.js", "noflo-ui-preview/deps/noflo-dom/components/SetAttribute.js");
require.alias("noflo-noflo-dom/components/WriteHtml.js", "noflo-ui-preview/deps/noflo-dom/components/WriteHtml.js");
require.alias("noflo-noflo-dom/components/RemoveClass.js", "noflo-ui-preview/deps/noflo-dom/components/RemoveClass.js");
require.alias("noflo-noflo-dom/components/RequestAnimationFrame.js", "noflo-ui-preview/deps/noflo-dom/components/RequestAnimationFrame.js");
require.alias("noflo-noflo-dom/index.js", "noflo-dom/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-dom/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-dom/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-dom/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-dom/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-dom/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-dom/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-dom/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-dom/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-dom/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-dom/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-dom/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-dom/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-dom/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-dom/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-dom/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-dom/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-flow/index.js", "noflo-ui-preview/deps/noflo-flow/index.js");
require.alias("noflo-noflo-flow/component.json", "noflo-ui-preview/deps/noflo-flow/component.json");
require.alias("noflo-noflo-flow/components/Concat.js", "noflo-ui-preview/deps/noflo-flow/components/Concat.js");
require.alias("noflo-noflo-flow/components/Gate.js", "noflo-ui-preview/deps/noflo-flow/components/Gate.js");
require.alias("noflo-noflo-flow/index.js", "noflo-flow/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-flow/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-flow/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-flow/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-flow/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-flow/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-flow/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-flow/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-flow/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-flow/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-flow/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-flow/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-flow/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-flow/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-flow/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-flow/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-flow/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-gestures/graphs/DetectDrag.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectDrag.json");
require.alias("noflo-noflo-gestures/graphs/DetectSwipe.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectSwipe.json");
require.alias("noflo-noflo-gestures/graphs/DetectPinch.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectPinch.json");
require.alias("noflo-noflo-gestures/graphs/FilterByTarget.json", "noflo-ui-preview/deps/noflo-gestures/graphs/FilterByTarget.json");
require.alias("noflo-noflo-gestures/graphs/GestureToObject.json", "noflo-ui-preview/deps/noflo-gestures/graphs/GestureToObject.json");
require.alias("noflo-noflo-gestures/graphs/ListenGestures.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenGestures.json");
require.alias("noflo-noflo-gestures/graphs/ListenPointer.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenPointer.json");
require.alias("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectCardinalDirection.json");
require.alias("noflo-noflo-gestures/index.js", "noflo-ui-preview/deps/noflo-gestures/index.js");
require.alias("noflo-noflo-gestures/graphs/DetectDrag.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectDrag.json");
require.alias("noflo-noflo-gestures/graphs/DetectSwipe.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectSwipe.json");
require.alias("noflo-noflo-gestures/graphs/DetectPinch.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectPinch.json");
require.alias("noflo-noflo-gestures/graphs/FilterByTarget.json", "noflo-ui-preview/deps/noflo-gestures/graphs/FilterByTarget.json");
require.alias("noflo-noflo-gestures/graphs/GestureToObject.json", "noflo-ui-preview/deps/noflo-gestures/graphs/GestureToObject.json");
require.alias("noflo-noflo-gestures/graphs/ListenGestures.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenGestures.json");
require.alias("noflo-noflo-gestures/graphs/ListenPointer.json", "noflo-ui-preview/deps/noflo-gestures/graphs/ListenPointer.json");
require.alias("noflo-noflo-gestures/graphs/DetectCardinalDirection.json", "noflo-ui-preview/deps/noflo-gestures/graphs/DetectCardinalDirection.json");
require.alias("noflo-noflo-gestures/component.json", "noflo-ui-preview/deps/noflo-gestures/component.json");
require.alias("noflo-noflo-gestures/components/CalculateCenter.js", "noflo-ui-preview/deps/noflo-gestures/components/CalculateCenter.js");
require.alias("noflo-noflo-gestures/components/CalculateScale.js", "noflo-ui-preview/deps/noflo-gestures/components/CalculateScale.js");
require.alias("noflo-noflo-gestures/components/CardinalRouter.js", "noflo-ui-preview/deps/noflo-gestures/components/CardinalRouter.js");
require.alias("noflo-noflo-gestures/components/DegreesToCardinal.js", "noflo-ui-preview/deps/noflo-gestures/components/DegreesToCardinal.js");
require.alias("noflo-noflo-gestures/components/DegreesToCompass.js", "noflo-ui-preview/deps/noflo-gestures/components/DegreesToCompass.js");
require.alias("noflo-noflo-gestures/components/DetectScratch.js", "noflo-ui-preview/deps/noflo-gestures/components/DetectScratch.js");
require.alias("noflo-noflo-gestures/components/DetectTarget.js", "noflo-ui-preview/deps/noflo-gestures/components/DetectTarget.js");
require.alias("noflo-noflo-gestures/index.js", "noflo-gestures/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-gestures/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-gestures/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-gestures/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-gestures/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-gestures/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-gestures/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-gestures/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-gestures/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-gestures/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-gestures/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-gestures/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-gestures/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-gestures/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-gestures/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-gestures/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-gestures/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-gestures/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-gestures/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-gestures/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-gestures/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-interaction/index.js", "noflo-noflo-gestures/deps/noflo-interaction/index.js");
require.alias("noflo-noflo-interaction/component.json", "noflo-noflo-gestures/deps/noflo-interaction/component.json");
require.alias("noflo-noflo-interaction/components/ListenChange.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenChange.js");
require.alias("noflo-noflo-interaction/components/ListenDrag.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenDrag.js");
require.alias("noflo-noflo-interaction/components/ListenHash.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenHash.js");
require.alias("noflo-noflo-interaction/components/ListenKeyboard.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenKeyboard.js");
require.alias("noflo-noflo-interaction/components/ListenKeyboardShortcuts.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenKeyboardShortcuts.js");
require.alias("noflo-noflo-interaction/components/ListenMouse.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenMouse.js");
require.alias("noflo-noflo-interaction/components/ListenPointer.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenPointer.js");
require.alias("noflo-noflo-interaction/components/ListenResize.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenResize.js");
require.alias("noflo-noflo-interaction/components/ListenScroll.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenScroll.js");
require.alias("noflo-noflo-interaction/components/ListenSpeech.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenSpeech.js");
require.alias("noflo-noflo-interaction/components/ListenTouch.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ListenTouch.js");
require.alias("noflo-noflo-interaction/components/SetHash.js", "noflo-noflo-gestures/deps/noflo-interaction/components/SetHash.js");
require.alias("noflo-noflo-interaction/components/ReadCoordinates.js", "noflo-noflo-gestures/deps/noflo-interaction/components/ReadCoordinates.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-interaction/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-interaction/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-interaction/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-interaction/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-interaction/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-interaction/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-interaction/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-interaction/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-interaction/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-interaction/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-interaction/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-interaction/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-interaction/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-math/index.js", "noflo-noflo-gestures/deps/noflo-math/index.js");
require.alias("noflo-noflo-math/component.json", "noflo-noflo-gestures/deps/noflo-math/component.json");
require.alias("noflo-noflo-math/components/Add.js", "noflo-noflo-gestures/deps/noflo-math/components/Add.js");
require.alias("noflo-noflo-math/components/Subtract.js", "noflo-noflo-gestures/deps/noflo-math/components/Subtract.js");
require.alias("noflo-noflo-math/components/Multiply.js", "noflo-noflo-gestures/deps/noflo-math/components/Multiply.js");
require.alias("noflo-noflo-math/components/Divide.js", "noflo-noflo-gestures/deps/noflo-math/components/Divide.js");
require.alias("noflo-noflo-math/components/Floor.js", "noflo-noflo-gestures/deps/noflo-math/components/Floor.js");
require.alias("noflo-noflo-math/components/CalculateAngle.js", "noflo-noflo-gestures/deps/noflo-math/components/CalculateAngle.js");
require.alias("noflo-noflo-math/components/CalculateDistance.js", "noflo-noflo-gestures/deps/noflo-math/components/CalculateDistance.js");
require.alias("noflo-noflo-math/components/Compare.js", "noflo-noflo-gestures/deps/noflo-math/components/Compare.js");
require.alias("noflo-noflo-math/components/CountSum.js", "noflo-noflo-gestures/deps/noflo-math/components/CountSum.js");
require.alias("noflo-noflo-math/lib/MathComponent.js", "noflo-noflo-gestures/deps/noflo-math/lib/MathComponent.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-math/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-math/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-math/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-math/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-math/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-math/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-math/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-math/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-math/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-math/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-math/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-math/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-math/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-math/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-math/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-math/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-math/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-math/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-flow/index.js", "noflo-noflo-gestures/deps/noflo-flow/index.js");
require.alias("noflo-noflo-flow/component.json", "noflo-noflo-gestures/deps/noflo-flow/component.json");
require.alias("noflo-noflo-flow/components/Concat.js", "noflo-noflo-gestures/deps/noflo-flow/components/Concat.js");
require.alias("noflo-noflo-flow/components/Gate.js", "noflo-noflo-gestures/deps/noflo-flow/components/Gate.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-flow/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-flow/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-flow/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-flow/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-flow/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-flow/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-flow/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-flow/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-flow/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-flow/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-flow/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-flow/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-flow/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-flow/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-flow/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-flow/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-flow/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-flow/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-groups/index.js", "noflo-noflo-gestures/deps/noflo-groups/index.js");
require.alias("noflo-noflo-groups/component.json", "noflo-noflo-gestures/deps/noflo-groups/component.json");
require.alias("noflo-noflo-groups/components/ReadGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/ReadGroups.js");
require.alias("noflo-noflo-groups/components/RemoveGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/RemoveGroups.js");
require.alias("noflo-noflo-groups/components/Regroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/Regroup.js");
require.alias("noflo-noflo-groups/components/Group.js", "noflo-noflo-gestures/deps/noflo-groups/components/Group.js");
require.alias("noflo-noflo-groups/components/GroupZip.js", "noflo-noflo-gestures/deps/noflo-groups/components/GroupZip.js");
require.alias("noflo-noflo-groups/components/FilterByGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/FilterByGroup.js");
require.alias("noflo-noflo-groups/components/Objectify.js", "noflo-noflo-gestures/deps/noflo-groups/components/Objectify.js");
require.alias("noflo-noflo-groups/components/ReadGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/ReadGroup.js");
require.alias("noflo-noflo-groups/components/SendByGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/SendByGroup.js");
require.alias("noflo-noflo-groups/components/CollectGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/CollectGroups.js");
require.alias("noflo-noflo-groups/components/CollectObject.js", "noflo-noflo-gestures/deps/noflo-groups/components/CollectObject.js");
require.alias("noflo-noflo-groups/components/FirstGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/FirstGroup.js");
require.alias("noflo-noflo-groups/components/MapGroup.js", "noflo-noflo-gestures/deps/noflo-groups/components/MapGroup.js");
require.alias("noflo-noflo-groups/components/MergeGroups.js", "noflo-noflo-gestures/deps/noflo-groups/components/MergeGroups.js");
require.alias("noflo-noflo-groups/components/GroupByObjectKey.js", "noflo-noflo-gestures/deps/noflo-groups/components/GroupByObjectKey.js");
require.alias("component-underscore/index.js", "noflo-noflo-groups/deps/underscore/index.js");

require.alias("noflo-noflo/component.json", "noflo-noflo-groups/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-groups/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-groups/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-groups/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-groups/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-groups/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-groups/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-groups/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-groups/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-groups/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-groups/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-groups/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-groups/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-groups/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-groups/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-groups/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-packets/index.js", "noflo-noflo-gestures/deps/noflo-packets/index.js");
require.alias("noflo-noflo-packets/component.json", "noflo-noflo-gestures/deps/noflo-packets/component.json");
require.alias("noflo-noflo-packets/components/CountPackets.js", "noflo-noflo-gestures/deps/noflo-packets/components/CountPackets.js");
require.alias("noflo-noflo-packets/components/Unzip.js", "noflo-noflo-gestures/deps/noflo-packets/components/Unzip.js");
require.alias("noflo-noflo-packets/components/Defaults.js", "noflo-noflo-gestures/deps/noflo-packets/components/Defaults.js");
require.alias("noflo-noflo-packets/components/DoNotDisconnect.js", "noflo-noflo-gestures/deps/noflo-packets/components/DoNotDisconnect.js");
require.alias("noflo-noflo-packets/components/OnlyDisconnect.js", "noflo-noflo-gestures/deps/noflo-packets/components/OnlyDisconnect.js");
require.alias("noflo-noflo-packets/components/SplitPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/SplitPacket.js");
require.alias("noflo-noflo-packets/components/Range.js", "noflo-noflo-gestures/deps/noflo-packets/components/Range.js");
require.alias("noflo-noflo-packets/components/Flatten.js", "noflo-noflo-gestures/deps/noflo-packets/components/Flatten.js");
require.alias("noflo-noflo-packets/components/Compact.js", "noflo-noflo-gestures/deps/noflo-packets/components/Compact.js");
require.alias("noflo-noflo-packets/components/Zip.js", "noflo-noflo-gestures/deps/noflo-packets/components/Zip.js");
require.alias("noflo-noflo-packets/components/SendWith.js", "noflo-noflo-gestures/deps/noflo-packets/components/SendWith.js");
require.alias("noflo-noflo-packets/components/FilterPackets.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterPackets.js");
require.alias("noflo-noflo-packets/components/FilterByValue.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterByValue.js");
require.alias("noflo-noflo-packets/components/FilterByPosition.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterByPosition.js");
require.alias("noflo-noflo-packets/components/FilterPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/FilterPacket.js");
require.alias("noflo-noflo-packets/components/UniquePacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/UniquePacket.js");
require.alias("noflo-noflo-packets/components/GroupByPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/GroupByPacket.js");
require.alias("noflo-noflo-packets/components/LastPacket.js", "noflo-noflo-gestures/deps/noflo-packets/components/LastPacket.js");
require.alias("noflo-noflo-packets/components/Counter.js", "noflo-noflo-gestures/deps/noflo-packets/components/Counter.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-packets/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-packets/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-packets/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-packets/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-packets/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-packets/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-packets/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-packets/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-packets/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-packets/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-packets/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-packets/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-packets/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-packets/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-packets/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-packets/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-packets/deps/underscore/index.js");

require.alias("noflo-noflo-objects/index.js", "noflo-noflo-gestures/deps/noflo-objects/index.js");
require.alias("noflo-noflo-objects/component.json", "noflo-noflo-gestures/deps/noflo-objects/component.json");
require.alias("noflo-noflo-objects/components/Extend.js", "noflo-noflo-gestures/deps/noflo-objects/components/Extend.js");
require.alias("noflo-noflo-objects/components/MergeObjects.js", "noflo-noflo-gestures/deps/noflo-objects/components/MergeObjects.js");
require.alias("noflo-noflo-objects/components/SplitObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/SplitObject.js");
require.alias("noflo-noflo-objects/components/ReplaceKey.js", "noflo-noflo-gestures/deps/noflo-objects/components/ReplaceKey.js");
require.alias("noflo-noflo-objects/components/Keys.js", "noflo-noflo-gestures/deps/noflo-objects/components/Keys.js");
require.alias("noflo-noflo-objects/components/Size.js", "noflo-noflo-gestures/deps/noflo-objects/components/Size.js");
require.alias("noflo-noflo-objects/components/Values.js", "noflo-noflo-gestures/deps/noflo-objects/components/Values.js");
require.alias("noflo-noflo-objects/components/Join.js", "noflo-noflo-gestures/deps/noflo-objects/components/Join.js");
require.alias("noflo-noflo-objects/components/ExtractProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/ExtractProperty.js");
require.alias("noflo-noflo-objects/components/InsertProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/InsertProperty.js");
require.alias("noflo-noflo-objects/components/SliceArray.js", "noflo-noflo-gestures/deps/noflo-objects/components/SliceArray.js");
require.alias("noflo-noflo-objects/components/SplitArray.js", "noflo-noflo-gestures/deps/noflo-objects/components/SplitArray.js");
require.alias("noflo-noflo-objects/components/FilterPropertyValue.js", "noflo-noflo-gestures/deps/noflo-objects/components/FilterPropertyValue.js");
require.alias("noflo-noflo-objects/components/FlattenObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/FlattenObject.js");
require.alias("noflo-noflo-objects/components/MapProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/MapProperty.js");
require.alias("noflo-noflo-objects/components/RemoveProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/RemoveProperty.js");
require.alias("noflo-noflo-objects/components/MapPropertyValue.js", "noflo-noflo-gestures/deps/noflo-objects/components/MapPropertyValue.js");
require.alias("noflo-noflo-objects/components/GetObjectKey.js", "noflo-noflo-gestures/deps/noflo-objects/components/GetObjectKey.js");
require.alias("noflo-noflo-objects/components/UniqueArray.js", "noflo-noflo-gestures/deps/noflo-objects/components/UniqueArray.js");
require.alias("noflo-noflo-objects/components/SetProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/SetProperty.js");
require.alias("noflo-noflo-objects/components/SimplifyObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/SimplifyObject.js");
require.alias("noflo-noflo-objects/components/DuplicateProperty.js", "noflo-noflo-gestures/deps/noflo-objects/components/DuplicateProperty.js");
require.alias("noflo-noflo-objects/components/CreateObject.js", "noflo-noflo-gestures/deps/noflo-objects/components/CreateObject.js");
require.alias("noflo-noflo-objects/components/CreateDate.js", "noflo-noflo-gestures/deps/noflo-objects/components/CreateDate.js");
require.alias("noflo-noflo-objects/components/SetPropertyValue.js", "noflo-noflo-gestures/deps/noflo-objects/components/SetPropertyValue.js");
require.alias("noflo-noflo-objects/components/CallMethod.js", "noflo-noflo-gestures/deps/noflo-objects/components/CallMethod.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-objects/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-objects/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-objects/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-objects/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-objects/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-objects/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-objects/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-objects/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-objects/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-objects/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-objects/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-objects/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-objects/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-objects/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-objects/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-objects/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-objects/deps/underscore/index.js");

require.alias("noflo-noflo-dom/index.js", "noflo-noflo-gestures/deps/noflo-dom/index.js");
require.alias("noflo-noflo-dom/component.json", "noflo-noflo-gestures/deps/noflo-dom/component.json");
require.alias("noflo-noflo-dom/components/AddClass.js", "noflo-noflo-gestures/deps/noflo-dom/components/AddClass.js");
require.alias("noflo-noflo-dom/components/AppendChild.js", "noflo-noflo-gestures/deps/noflo-dom/components/AppendChild.js");
require.alias("noflo-noflo-dom/components/CreateElement.js", "noflo-noflo-gestures/deps/noflo-dom/components/CreateElement.js");
require.alias("noflo-noflo-dom/components/CreateFragment.js", "noflo-noflo-gestures/deps/noflo-dom/components/CreateFragment.js");
require.alias("noflo-noflo-dom/components/GetAttribute.js", "noflo-noflo-gestures/deps/noflo-dom/components/GetAttribute.js");
require.alias("noflo-noflo-dom/components/GetElement.js", "noflo-noflo-gestures/deps/noflo-dom/components/GetElement.js");
require.alias("noflo-noflo-dom/components/HasClass.js", "noflo-noflo-gestures/deps/noflo-dom/components/HasClass.js");
require.alias("noflo-noflo-dom/components/ReadHtml.js", "noflo-noflo-gestures/deps/noflo-dom/components/ReadHtml.js");
require.alias("noflo-noflo-dom/components/RemoveElement.js", "noflo-noflo-gestures/deps/noflo-dom/components/RemoveElement.js");
require.alias("noflo-noflo-dom/components/SetAttribute.js", "noflo-noflo-gestures/deps/noflo-dom/components/SetAttribute.js");
require.alias("noflo-noflo-dom/components/WriteHtml.js", "noflo-noflo-gestures/deps/noflo-dom/components/WriteHtml.js");
require.alias("noflo-noflo-dom/components/RemoveClass.js", "noflo-noflo-gestures/deps/noflo-dom/components/RemoveClass.js");
require.alias("noflo-noflo-dom/components/RequestAnimationFrame.js", "noflo-noflo-gestures/deps/noflo-dom/components/RequestAnimationFrame.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-dom/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-dom/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-dom/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-dom/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-dom/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-dom/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-dom/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-dom/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-dom/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-dom/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-dom/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-dom/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-dom/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-dom/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-dom/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-dom/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-dom/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-dom/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-strings/index.js", "noflo-noflo-gestures/deps/noflo-strings/index.js");
require.alias("noflo-noflo-strings/component.json", "noflo-noflo-gestures/deps/noflo-strings/component.json");
require.alias("noflo-noflo-strings/components/CompileString.js", "noflo-noflo-gestures/deps/noflo-strings/components/CompileString.js");
require.alias("noflo-noflo-strings/components/Filter.js", "noflo-noflo-gestures/deps/noflo-strings/components/Filter.js");
require.alias("noflo-noflo-strings/components/SendString.js", "noflo-noflo-gestures/deps/noflo-strings/components/SendString.js");
require.alias("noflo-noflo-strings/components/SplitStr.js", "noflo-noflo-gestures/deps/noflo-strings/components/SplitStr.js");
require.alias("noflo-noflo-strings/components/StringTemplate.js", "noflo-noflo-gestures/deps/noflo-strings/components/StringTemplate.js");
require.alias("noflo-noflo-strings/components/Replace.js", "noflo-noflo-gestures/deps/noflo-strings/components/Replace.js");
require.alias("noflo-noflo-strings/components/Jsonify.js", "noflo-noflo-gestures/deps/noflo-strings/components/Jsonify.js");
require.alias("noflo-noflo-strings/components/ParseJson.js", "noflo-noflo-gestures/deps/noflo-strings/components/ParseJson.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-strings/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-strings/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-strings/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-strings/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-strings/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-strings/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-strings/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-strings/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-strings/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-strings/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-strings/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-strings/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-strings/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-strings/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-strings/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-strings/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-strings/deps/underscore/index.js");

require.alias("noflo-noflo-core/index.js", "noflo-noflo-gestures/deps/noflo-core/index.js");
require.alias("noflo-noflo-core/component.json", "noflo-noflo-gestures/deps/noflo-core/component.json");
require.alias("noflo-noflo-core/components/Callback.js", "noflo-noflo-gestures/deps/noflo-core/components/Callback.js");
require.alias("noflo-noflo-core/components/DisconnectAfterPacket.js", "noflo-noflo-gestures/deps/noflo-core/components/DisconnectAfterPacket.js");
require.alias("noflo-noflo-core/components/Drop.js", "noflo-noflo-gestures/deps/noflo-core/components/Drop.js");
require.alias("noflo-noflo-core/components/Group.js", "noflo-noflo-gestures/deps/noflo-core/components/Group.js");
require.alias("noflo-noflo-core/components/Kick.js", "noflo-noflo-gestures/deps/noflo-core/components/Kick.js");
require.alias("noflo-noflo-core/components/Merge.js", "noflo-noflo-gestures/deps/noflo-core/components/Merge.js");
require.alias("noflo-noflo-core/components/Output.js", "noflo-noflo-gestures/deps/noflo-core/components/Output.js");
require.alias("noflo-noflo-core/components/Repeat.js", "noflo-noflo-gestures/deps/noflo-core/components/Repeat.js");
require.alias("noflo-noflo-core/components/RepeatAsync.js", "noflo-noflo-gestures/deps/noflo-core/components/RepeatAsync.js");
require.alias("noflo-noflo-core/components/Split.js", "noflo-noflo-gestures/deps/noflo-core/components/Split.js");
require.alias("noflo-noflo-core/components/RunInterval.js", "noflo-noflo-gestures/deps/noflo-core/components/RunInterval.js");
require.alias("noflo-noflo-core/components/RunTimeout.js", "noflo-noflo-gestures/deps/noflo-core/components/RunTimeout.js");
require.alias("noflo-noflo-core/components/MakeFunction.js", "noflo-noflo-gestures/deps/noflo-core/components/MakeFunction.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-core/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-core/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-core/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-core/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-core/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-core/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-core/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-core/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-core/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-core/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-core/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-core/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-core/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-core/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-core/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-core/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-core/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-core/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-core/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-core/deps/underscore/index.js");

require.alias("noflo-noflo-groups/index.js", "noflo-ui-preview/deps/noflo-groups/index.js");
require.alias("noflo-noflo-groups/component.json", "noflo-ui-preview/deps/noflo-groups/component.json");
require.alias("noflo-noflo-groups/components/ReadGroups.js", "noflo-ui-preview/deps/noflo-groups/components/ReadGroups.js");
require.alias("noflo-noflo-groups/components/RemoveGroups.js", "noflo-ui-preview/deps/noflo-groups/components/RemoveGroups.js");
require.alias("noflo-noflo-groups/components/Regroup.js", "noflo-ui-preview/deps/noflo-groups/components/Regroup.js");
require.alias("noflo-noflo-groups/components/Group.js", "noflo-ui-preview/deps/noflo-groups/components/Group.js");
require.alias("noflo-noflo-groups/components/GroupZip.js", "noflo-ui-preview/deps/noflo-groups/components/GroupZip.js");
require.alias("noflo-noflo-groups/components/FilterByGroup.js", "noflo-ui-preview/deps/noflo-groups/components/FilterByGroup.js");
require.alias("noflo-noflo-groups/components/Objectify.js", "noflo-ui-preview/deps/noflo-groups/components/Objectify.js");
require.alias("noflo-noflo-groups/components/ReadGroup.js", "noflo-ui-preview/deps/noflo-groups/components/ReadGroup.js");
require.alias("noflo-noflo-groups/components/SendByGroup.js", "noflo-ui-preview/deps/noflo-groups/components/SendByGroup.js");
require.alias("noflo-noflo-groups/components/CollectGroups.js", "noflo-ui-preview/deps/noflo-groups/components/CollectGroups.js");
require.alias("noflo-noflo-groups/components/CollectObject.js", "noflo-ui-preview/deps/noflo-groups/components/CollectObject.js");
require.alias("noflo-noflo-groups/components/FirstGroup.js", "noflo-ui-preview/deps/noflo-groups/components/FirstGroup.js");
require.alias("noflo-noflo-groups/components/MapGroup.js", "noflo-ui-preview/deps/noflo-groups/components/MapGroup.js");
require.alias("noflo-noflo-groups/components/MergeGroups.js", "noflo-ui-preview/deps/noflo-groups/components/MergeGroups.js");
require.alias("noflo-noflo-groups/components/GroupByObjectKey.js", "noflo-ui-preview/deps/noflo-groups/components/GroupByObjectKey.js");
require.alias("noflo-noflo-groups/index.js", "noflo-groups/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-groups/deps/underscore/index.js");

require.alias("noflo-noflo/component.json", "noflo-noflo-groups/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-groups/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-groups/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-groups/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-groups/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-groups/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-groups/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-groups/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-groups/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-groups/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-groups/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-groups/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-groups/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-groups/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-groups/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-groups/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-groups/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-groups/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-interaction/index.js", "noflo-ui-preview/deps/noflo-interaction/index.js");
require.alias("noflo-noflo-interaction/component.json", "noflo-ui-preview/deps/noflo-interaction/component.json");
require.alias("noflo-noflo-interaction/components/ListenChange.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenChange.js");
require.alias("noflo-noflo-interaction/components/ListenDrag.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenDrag.js");
require.alias("noflo-noflo-interaction/components/ListenHash.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenHash.js");
require.alias("noflo-noflo-interaction/components/ListenKeyboard.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenKeyboard.js");
require.alias("noflo-noflo-interaction/components/ListenKeyboardShortcuts.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenKeyboardShortcuts.js");
require.alias("noflo-noflo-interaction/components/ListenMouse.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenMouse.js");
require.alias("noflo-noflo-interaction/components/ListenPointer.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenPointer.js");
require.alias("noflo-noflo-interaction/components/ListenResize.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenResize.js");
require.alias("noflo-noflo-interaction/components/ListenScroll.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenScroll.js");
require.alias("noflo-noflo-interaction/components/ListenSpeech.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenSpeech.js");
require.alias("noflo-noflo-interaction/components/ListenTouch.js", "noflo-ui-preview/deps/noflo-interaction/components/ListenTouch.js");
require.alias("noflo-noflo-interaction/components/SetHash.js", "noflo-ui-preview/deps/noflo-interaction/components/SetHash.js");
require.alias("noflo-noflo-interaction/components/ReadCoordinates.js", "noflo-ui-preview/deps/noflo-interaction/components/ReadCoordinates.js");
require.alias("noflo-noflo-interaction/index.js", "noflo-interaction/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-interaction/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-interaction/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-interaction/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-interaction/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-interaction/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-interaction/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-interaction/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-interaction/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-interaction/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-interaction/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-interaction/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-interaction/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-interaction/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-interaction/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-interaction/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-interaction/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-localstorage/index.js", "noflo-ui-preview/deps/noflo-localstorage/index.js");
require.alias("noflo-noflo-localstorage/component.json", "noflo-ui-preview/deps/noflo-localstorage/component.json");
require.alias("noflo-noflo-localstorage/components/GetItem.js", "noflo-ui-preview/deps/noflo-localstorage/components/GetItem.js");
require.alias("noflo-noflo-localstorage/components/ListenRemoteChanges.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListenRemoteChanges.js");
require.alias("noflo-noflo-localstorage/components/ListAdd.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListAdd.js");
require.alias("noflo-noflo-localstorage/components/ListGet.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListGet.js");
require.alias("noflo-noflo-localstorage/components/ListRemove.js", "noflo-ui-preview/deps/noflo-localstorage/components/ListRemove.js");
require.alias("noflo-noflo-localstorage/components/RemoveItem.js", "noflo-ui-preview/deps/noflo-localstorage/components/RemoveItem.js");
require.alias("noflo-noflo-localstorage/components/SetItem.js", "noflo-ui-preview/deps/noflo-localstorage/components/SetItem.js");
require.alias("noflo-noflo-localstorage/index.js", "noflo-localstorage/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-localstorage/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-localstorage/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-localstorage/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-localstorage/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-localstorage/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-localstorage/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-localstorage/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-localstorage/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-localstorage/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-localstorage/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-math/index.js", "noflo-ui-preview/deps/noflo-math/index.js");
require.alias("noflo-noflo-math/component.json", "noflo-ui-preview/deps/noflo-math/component.json");
require.alias("noflo-noflo-math/components/Add.js", "noflo-ui-preview/deps/noflo-math/components/Add.js");
require.alias("noflo-noflo-math/components/Subtract.js", "noflo-ui-preview/deps/noflo-math/components/Subtract.js");
require.alias("noflo-noflo-math/components/Multiply.js", "noflo-ui-preview/deps/noflo-math/components/Multiply.js");
require.alias("noflo-noflo-math/components/Divide.js", "noflo-ui-preview/deps/noflo-math/components/Divide.js");
require.alias("noflo-noflo-math/components/Floor.js", "noflo-ui-preview/deps/noflo-math/components/Floor.js");
require.alias("noflo-noflo-math/components/CalculateAngle.js", "noflo-ui-preview/deps/noflo-math/components/CalculateAngle.js");
require.alias("noflo-noflo-math/components/CalculateDistance.js", "noflo-ui-preview/deps/noflo-math/components/CalculateDistance.js");
require.alias("noflo-noflo-math/components/Compare.js", "noflo-ui-preview/deps/noflo-math/components/Compare.js");
require.alias("noflo-noflo-math/components/CountSum.js", "noflo-ui-preview/deps/noflo-math/components/CountSum.js");
require.alias("noflo-noflo-math/lib/MathComponent.js", "noflo-ui-preview/deps/noflo-math/lib/MathComponent.js");
require.alias("noflo-noflo-math/index.js", "noflo-math/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-math/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-math/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-math/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-math/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-math/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-math/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-math/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-math/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-math/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-math/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-math/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-math/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-math/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-math/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-math/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-math/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-math/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-math/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-math/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-objects/index.js", "noflo-ui-preview/deps/noflo-objects/index.js");
require.alias("noflo-noflo-objects/component.json", "noflo-ui-preview/deps/noflo-objects/component.json");
require.alias("noflo-noflo-objects/components/Extend.js", "noflo-ui-preview/deps/noflo-objects/components/Extend.js");
require.alias("noflo-noflo-objects/components/MergeObjects.js", "noflo-ui-preview/deps/noflo-objects/components/MergeObjects.js");
require.alias("noflo-noflo-objects/components/SplitObject.js", "noflo-ui-preview/deps/noflo-objects/components/SplitObject.js");
require.alias("noflo-noflo-objects/components/ReplaceKey.js", "noflo-ui-preview/deps/noflo-objects/components/ReplaceKey.js");
require.alias("noflo-noflo-objects/components/Keys.js", "noflo-ui-preview/deps/noflo-objects/components/Keys.js");
require.alias("noflo-noflo-objects/components/Size.js", "noflo-ui-preview/deps/noflo-objects/components/Size.js");
require.alias("noflo-noflo-objects/components/Values.js", "noflo-ui-preview/deps/noflo-objects/components/Values.js");
require.alias("noflo-noflo-objects/components/Join.js", "noflo-ui-preview/deps/noflo-objects/components/Join.js");
require.alias("noflo-noflo-objects/components/ExtractProperty.js", "noflo-ui-preview/deps/noflo-objects/components/ExtractProperty.js");
require.alias("noflo-noflo-objects/components/InsertProperty.js", "noflo-ui-preview/deps/noflo-objects/components/InsertProperty.js");
require.alias("noflo-noflo-objects/components/SliceArray.js", "noflo-ui-preview/deps/noflo-objects/components/SliceArray.js");
require.alias("noflo-noflo-objects/components/SplitArray.js", "noflo-ui-preview/deps/noflo-objects/components/SplitArray.js");
require.alias("noflo-noflo-objects/components/FilterPropertyValue.js", "noflo-ui-preview/deps/noflo-objects/components/FilterPropertyValue.js");
require.alias("noflo-noflo-objects/components/FlattenObject.js", "noflo-ui-preview/deps/noflo-objects/components/FlattenObject.js");
require.alias("noflo-noflo-objects/components/MapProperty.js", "noflo-ui-preview/deps/noflo-objects/components/MapProperty.js");
require.alias("noflo-noflo-objects/components/RemoveProperty.js", "noflo-ui-preview/deps/noflo-objects/components/RemoveProperty.js");
require.alias("noflo-noflo-objects/components/MapPropertyValue.js", "noflo-ui-preview/deps/noflo-objects/components/MapPropertyValue.js");
require.alias("noflo-noflo-objects/components/GetObjectKey.js", "noflo-ui-preview/deps/noflo-objects/components/GetObjectKey.js");
require.alias("noflo-noflo-objects/components/UniqueArray.js", "noflo-ui-preview/deps/noflo-objects/components/UniqueArray.js");
require.alias("noflo-noflo-objects/components/SetProperty.js", "noflo-ui-preview/deps/noflo-objects/components/SetProperty.js");
require.alias("noflo-noflo-objects/components/SimplifyObject.js", "noflo-ui-preview/deps/noflo-objects/components/SimplifyObject.js");
require.alias("noflo-noflo-objects/components/DuplicateProperty.js", "noflo-ui-preview/deps/noflo-objects/components/DuplicateProperty.js");
require.alias("noflo-noflo-objects/components/CreateObject.js", "noflo-ui-preview/deps/noflo-objects/components/CreateObject.js");
require.alias("noflo-noflo-objects/components/CreateDate.js", "noflo-ui-preview/deps/noflo-objects/components/CreateDate.js");
require.alias("noflo-noflo-objects/components/SetPropertyValue.js", "noflo-ui-preview/deps/noflo-objects/components/SetPropertyValue.js");
require.alias("noflo-noflo-objects/components/CallMethod.js", "noflo-ui-preview/deps/noflo-objects/components/CallMethod.js");
require.alias("noflo-noflo-objects/index.js", "noflo-objects/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-objects/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-objects/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-objects/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-objects/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-objects/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-objects/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-objects/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-objects/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-objects/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-objects/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-objects/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-objects/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-objects/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-objects/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-objects/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-objects/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-objects/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-objects/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-objects/deps/underscore/index.js");

require.alias("noflo-noflo-packets/index.js", "noflo-ui-preview/deps/noflo-packets/index.js");
require.alias("noflo-noflo-packets/component.json", "noflo-ui-preview/deps/noflo-packets/component.json");
require.alias("noflo-noflo-packets/components/CountPackets.js", "noflo-ui-preview/deps/noflo-packets/components/CountPackets.js");
require.alias("noflo-noflo-packets/components/Unzip.js", "noflo-ui-preview/deps/noflo-packets/components/Unzip.js");
require.alias("noflo-noflo-packets/components/Defaults.js", "noflo-ui-preview/deps/noflo-packets/components/Defaults.js");
require.alias("noflo-noflo-packets/components/DoNotDisconnect.js", "noflo-ui-preview/deps/noflo-packets/components/DoNotDisconnect.js");
require.alias("noflo-noflo-packets/components/OnlyDisconnect.js", "noflo-ui-preview/deps/noflo-packets/components/OnlyDisconnect.js");
require.alias("noflo-noflo-packets/components/SplitPacket.js", "noflo-ui-preview/deps/noflo-packets/components/SplitPacket.js");
require.alias("noflo-noflo-packets/components/Range.js", "noflo-ui-preview/deps/noflo-packets/components/Range.js");
require.alias("noflo-noflo-packets/components/Flatten.js", "noflo-ui-preview/deps/noflo-packets/components/Flatten.js");
require.alias("noflo-noflo-packets/components/Compact.js", "noflo-ui-preview/deps/noflo-packets/components/Compact.js");
require.alias("noflo-noflo-packets/components/Zip.js", "noflo-ui-preview/deps/noflo-packets/components/Zip.js");
require.alias("noflo-noflo-packets/components/SendWith.js", "noflo-ui-preview/deps/noflo-packets/components/SendWith.js");
require.alias("noflo-noflo-packets/components/FilterPackets.js", "noflo-ui-preview/deps/noflo-packets/components/FilterPackets.js");
require.alias("noflo-noflo-packets/components/FilterByValue.js", "noflo-ui-preview/deps/noflo-packets/components/FilterByValue.js");
require.alias("noflo-noflo-packets/components/FilterByPosition.js", "noflo-ui-preview/deps/noflo-packets/components/FilterByPosition.js");
require.alias("noflo-noflo-packets/components/FilterPacket.js", "noflo-ui-preview/deps/noflo-packets/components/FilterPacket.js");
require.alias("noflo-noflo-packets/components/UniquePacket.js", "noflo-ui-preview/deps/noflo-packets/components/UniquePacket.js");
require.alias("noflo-noflo-packets/components/GroupByPacket.js", "noflo-ui-preview/deps/noflo-packets/components/GroupByPacket.js");
require.alias("noflo-noflo-packets/components/LastPacket.js", "noflo-ui-preview/deps/noflo-packets/components/LastPacket.js");
require.alias("noflo-noflo-packets/components/Counter.js", "noflo-ui-preview/deps/noflo-packets/components/Counter.js");
require.alias("noflo-noflo-packets/index.js", "noflo-packets/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-packets/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-packets/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-packets/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-packets/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-packets/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-packets/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-packets/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-packets/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-packets/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-packets/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-packets/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-packets/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-packets/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-packets/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-packets/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-packets/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-packets/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-packets/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-packets/deps/underscore/index.js");

require.alias("noflo-noflo-physics/index.js", "noflo-ui-preview/deps/noflo-physics/index.js");
require.alias("noflo-noflo-physics/component.json", "noflo-ui-preview/deps/noflo-physics/component.json");
require.alias("noflo-noflo-physics/components/Spring.js", "noflo-ui-preview/deps/noflo-physics/components/Spring.js");
require.alias("noflo-noflo-physics/index.js", "noflo-physics/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-physics/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-physics/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-physics/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-physics/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-physics/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-physics/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-physics/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-physics/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-physics/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-physics/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-physics/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-physics/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-physics/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-physics/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-physics/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-physics/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-physics/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-physics/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-physics/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-physics/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-routers/index.js", "noflo-ui-preview/deps/noflo-routers/index.js");
require.alias("noflo-noflo-routers/component.json", "noflo-ui-preview/deps/noflo-routers/component.json");
require.alias("noflo-noflo-routers/components/ControlledSequence.js", "noflo-ui-preview/deps/noflo-routers/components/ControlledSequence.js");
require.alias("noflo-noflo-routers/components/KickRouter.js", "noflo-ui-preview/deps/noflo-routers/components/KickRouter.js");
require.alias("noflo-noflo-routers/components/PacketRouter.js", "noflo-ui-preview/deps/noflo-routers/components/PacketRouter.js");
require.alias("noflo-noflo-routers/components/RegexpRouter.js", "noflo-ui-preview/deps/noflo-routers/components/RegexpRouter.js");
require.alias("noflo-noflo-routers/components/SplitInSequence.js", "noflo-ui-preview/deps/noflo-routers/components/SplitInSequence.js");
require.alias("noflo-noflo-routers/index.js", "noflo-routers/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-routers/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-routers/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-routers/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-routers/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-routers/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-routers/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-routers/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-routers/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-routers/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-routers/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-routers/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-routers/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-routers/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-routers/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-routers/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-routers/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-routers/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-routers/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-routers/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-routers/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-routers/deps/underscore/index.js");

require.alias("noflo-noflo-strings/index.js", "noflo-ui-preview/deps/noflo-strings/index.js");
require.alias("noflo-noflo-strings/component.json", "noflo-ui-preview/deps/noflo-strings/component.json");
require.alias("noflo-noflo-strings/components/CompileString.js", "noflo-ui-preview/deps/noflo-strings/components/CompileString.js");
require.alias("noflo-noflo-strings/components/Filter.js", "noflo-ui-preview/deps/noflo-strings/components/Filter.js");
require.alias("noflo-noflo-strings/components/SendString.js", "noflo-ui-preview/deps/noflo-strings/components/SendString.js");
require.alias("noflo-noflo-strings/components/SplitStr.js", "noflo-ui-preview/deps/noflo-strings/components/SplitStr.js");
require.alias("noflo-noflo-strings/components/StringTemplate.js", "noflo-ui-preview/deps/noflo-strings/components/StringTemplate.js");
require.alias("noflo-noflo-strings/components/Replace.js", "noflo-ui-preview/deps/noflo-strings/components/Replace.js");
require.alias("noflo-noflo-strings/components/Jsonify.js", "noflo-ui-preview/deps/noflo-strings/components/Jsonify.js");
require.alias("noflo-noflo-strings/components/ParseJson.js", "noflo-ui-preview/deps/noflo-strings/components/ParseJson.js");
require.alias("noflo-noflo-strings/index.js", "noflo-strings/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-strings/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-strings/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-strings/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-strings/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-strings/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-strings/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-strings/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-strings/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-strings/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-strings/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-strings/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-strings/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-strings/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-strings/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-strings/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-strings/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-strings/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-strings/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("component-underscore/index.js", "noflo-noflo-strings/deps/underscore/index.js");

require.alias("noflo-noflo-websocket/index.js", "noflo-ui-preview/deps/noflo-websocket/index.js");
require.alias("noflo-noflo-websocket/component.json", "noflo-ui-preview/deps/noflo-websocket/component.json");
require.alias("noflo-noflo-websocket/components/Connect.js", "noflo-ui-preview/deps/noflo-websocket/components/Connect.js");
require.alias("noflo-noflo-websocket/components/SendMessage.js", "noflo-ui-preview/deps/noflo-websocket/components/SendMessage.js");
require.alias("noflo-noflo-websocket/components/ListenMessages.js", "noflo-ui-preview/deps/noflo-websocket/components/ListenMessages.js");
require.alias("noflo-noflo-websocket/index.js", "noflo-websocket/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-websocket/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-websocket/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-websocket/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-websocket/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-websocket/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-websocket/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-websocket/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-websocket/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-websocket/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-websocket/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-websocket/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-websocket/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-websocket/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-websocket/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-websocket/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-websocket/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-websocket/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-websocket/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-websocket/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-websocket/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-indexeddb/index.js", "noflo-ui-preview/deps/noflo-indexeddb/index.js");
require.alias("noflo-noflo-indexeddb/component.json", "noflo-ui-preview/deps/noflo-indexeddb/component.json");
require.alias("noflo-noflo-indexeddb/components/Open.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Open.js");
require.alias("noflo-noflo-indexeddb/components/Close.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Close.js");
require.alias("noflo-noflo-indexeddb/components/DeleteDatabase.js", "noflo-ui-preview/deps/noflo-indexeddb/components/DeleteDatabase.js");
require.alias("noflo-noflo-indexeddb/components/CreateStore.js", "noflo-ui-preview/deps/noflo-indexeddb/components/CreateStore.js");
require.alias("noflo-noflo-indexeddb/components/CreateIndex.js", "noflo-ui-preview/deps/noflo-indexeddb/components/CreateIndex.js");
require.alias("noflo-noflo-indexeddb/components/DeleteStore.js", "noflo-ui-preview/deps/noflo-indexeddb/components/DeleteStore.js");
require.alias("noflo-noflo-indexeddb/components/UpgradeRouter.js", "noflo-ui-preview/deps/noflo-indexeddb/components/UpgradeRouter.js");
require.alias("noflo-noflo-indexeddb/components/BeginTransaction.js", "noflo-ui-preview/deps/noflo-indexeddb/components/BeginTransaction.js");
require.alias("noflo-noflo-indexeddb/components/AbortTransaction.js", "noflo-ui-preview/deps/noflo-indexeddb/components/AbortTransaction.js");
require.alias("noflo-noflo-indexeddb/components/GetStore.js", "noflo-ui-preview/deps/noflo-indexeddb/components/GetStore.js");
require.alias("noflo-noflo-indexeddb/components/GetIndex.js", "noflo-ui-preview/deps/noflo-indexeddb/components/GetIndex.js");
require.alias("noflo-noflo-indexeddb/components/Query.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Query.js");
require.alias("noflo-noflo-indexeddb/components/QueryOnly.js", "noflo-ui-preview/deps/noflo-indexeddb/components/QueryOnly.js");
require.alias("noflo-noflo-indexeddb/components/QueryFrom.js", "noflo-ui-preview/deps/noflo-indexeddb/components/QueryFrom.js");
require.alias("noflo-noflo-indexeddb/components/QueryTo.js", "noflo-ui-preview/deps/noflo-indexeddb/components/QueryTo.js");
require.alias("noflo-noflo-indexeddb/components/Put.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Put.js");
require.alias("noflo-noflo-indexeddb/components/Get.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Get.js");
require.alias("noflo-noflo-indexeddb/components/Delete.js", "noflo-ui-preview/deps/noflo-indexeddb/components/Delete.js");
require.alias("noflo-noflo-indexeddb/index.js", "noflo-indexeddb/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-indexeddb/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-indexeddb/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-indexeddb/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-indexeddb/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("noflo-noflo-github/index.js", "noflo-ui-preview/deps/noflo-github/index.js");
require.alias("noflo-noflo-github/component.json", "noflo-ui-preview/deps/noflo-github/component.json");
require.alias("noflo-noflo-github/components/CreateRepository.js", "noflo-ui-preview/deps/noflo-github/components/CreateRepository.js");
require.alias("noflo-noflo-github/components/CreateOrgRepository.js", "noflo-ui-preview/deps/noflo-github/components/CreateOrgRepository.js");
require.alias("noflo-noflo-github/components/GetRepository.js", "noflo-ui-preview/deps/noflo-github/components/GetRepository.js");
require.alias("noflo-noflo-github/components/GetContents.js", "noflo-ui-preview/deps/noflo-github/components/GetContents.js");
require.alias("noflo-noflo-github/components/GetCurrentUser.js", "noflo-ui-preview/deps/noflo-github/components/GetCurrentUser.js");
require.alias("noflo-noflo-github/components/GetUser.js", "noflo-ui-preview/deps/noflo-github/components/GetUser.js");
require.alias("noflo-noflo-github/components/GetStargazers.js", "noflo-ui-preview/deps/noflo-github/components/GetStargazers.js");
require.alias("noflo-noflo-github/components/SetContents.js", "noflo-ui-preview/deps/noflo-github/components/SetContents.js");
require.alias("noflo-noflo-github/index.js", "noflo-github/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-github/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-github/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-github/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-github/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-github/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-github/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-github/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-github/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-github/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-github/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-github/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-github/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-github/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-github/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-github/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-github/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-github/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-github/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-github/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-github/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("bergie-octo/octo.js", "noflo-noflo-github/deps/octo/octo.js");
require.alias("bergie-octo/octo.js", "noflo-noflo-github/deps/octo/index.js");
require.alias("visionmedia-superagent/lib/client.js", "bergie-octo/deps/superagent/lib/client.js");
require.alias("visionmedia-superagent/lib/client.js", "bergie-octo/deps/superagent/index.js");
require.alias("component-emitter/index.js", "visionmedia-superagent/deps/emitter/index.js");

require.alias("component-reduce/index.js", "visionmedia-superagent/deps/reduce/index.js");

require.alias("visionmedia-superagent/lib/client.js", "visionmedia-superagent/index.js");
require.alias("bergie-octo/octo.js", "bergie-octo/index.js");
require.alias("noflo-noflo-finitedomain/index.js", "noflo-ui-preview/deps/noflo-finitedomain/index.js");
require.alias("noflo-noflo-finitedomain/component.json", "noflo-ui-preview/deps/noflo-finitedomain/component.json");
require.alias("noflo-noflo-finitedomain/components/CreateSpace.js", "noflo-ui-preview/deps/noflo-finitedomain/components/CreateSpace.js");
require.alias("noflo-noflo-finitedomain/components/DeclareVariable.js", "noflo-ui-preview/deps/noflo-finitedomain/components/DeclareVariable.js");
require.alias("noflo-noflo-finitedomain/components/GreaterThan.js", "noflo-ui-preview/deps/noflo-finitedomain/components/GreaterThan.js");
require.alias("noflo-noflo-finitedomain/components/Solve.js", "noflo-ui-preview/deps/noflo-finitedomain/components/Solve.js");
require.alias("noflo-noflo-finitedomain/index.js", "noflo-finitedomain/index.js");
require.alias("noflo-noflo/component.json", "noflo-noflo-finitedomain/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "noflo-noflo-finitedomain/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "noflo-noflo-finitedomain/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo-finitedomain/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("bergie-FD.js/fd.js", "noflo-noflo-finitedomain/deps/fdjs/fd.js");
require.alias("bergie-FD.js/fd.js", "noflo-noflo-finitedomain/deps/fdjs/index.js");
require.alias("bergie-FD.js/fd.js", "bergie-FD.js/index.js");
require.alias("d4tocchini-noflo-draggabilly/index.js", "noflo-ui-preview/deps/noflo-draggabilly/index.js");
require.alias("d4tocchini-noflo-draggabilly/component.json", "noflo-ui-preview/deps/noflo-draggabilly/component.json");
require.alias("d4tocchini-noflo-draggabilly/components/Draggabilly.js", "noflo-ui-preview/deps/noflo-draggabilly/components/Draggabilly.js");
require.alias("d4tocchini-noflo-draggabilly/index.js", "noflo-draggabilly/index.js");
require.alias("noflo-noflo/component.json", "d4tocchini-noflo-draggabilly/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "d4tocchini-noflo-draggabilly/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "d4tocchini-noflo-draggabilly/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("forresto-noflo-gum/index.js", "noflo-ui-preview/deps/noflo-gum/index.js");
require.alias("forresto-noflo-gum/component.json", "noflo-ui-preview/deps/noflo-gum/component.json");
require.alias("forresto-noflo-gum/components/GetUserMedia.js", "noflo-ui-preview/deps/noflo-gum/components/GetUserMedia.js");
require.alias("forresto-noflo-gum/index.js", "noflo-gum/index.js");
require.alias("noflo-noflo/component.json", "forresto-noflo-gum/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "forresto-noflo-gum/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "forresto-noflo-gum/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "forresto-noflo-gum/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "forresto-noflo-gum/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "forresto-noflo-gum/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "forresto-noflo-gum/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "forresto-noflo-gum/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "forresto-noflo-gum/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "forresto-noflo-gum/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "forresto-noflo-gum/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "forresto-noflo-gum/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "forresto-noflo-gum/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-gum/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "forresto-noflo-gum/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "forresto-noflo-gum/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "forresto-noflo-gum/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "forresto-noflo-gum/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "forresto-noflo-gum/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-gum/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("forresto-noflo-seriously/index.js", "noflo-ui-preview/deps/noflo-seriously/index.js");
require.alias("forresto-noflo-seriously/vendor/seriously.js", "noflo-ui-preview/deps/noflo-seriously/vendor/seriously.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.ascii.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.ascii.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.bleach-bypass.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.bleach-bypass.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.blend.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.blend.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.blur.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.blur.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.brightness-contrast.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.brightness-contrast.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.channels.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.channels.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.chroma.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.chroma.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.color.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.color.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.colorcomplements.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.colorcomplements.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.colorcube.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.colorcube.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.daltonize.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.daltonize.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.directionblur.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.directionblur.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.dither.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.dither.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.edge.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.edge.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.emboss.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.emboss.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.exposure.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.exposure.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.fader.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.fader.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.falsecolor.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.falsecolor.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.filmgrain.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.filmgrain.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.hex.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.hex.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.highlights-shadows.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.highlights-shadows.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.hue-saturation.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.hue-saturation.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.invert.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.invert.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.kaleidoscope.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.kaleidoscope.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.layers.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.layers.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.linear-transfer.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.linear-transfer.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.lumakey.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.lumakey.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.nightvision.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.nightvision.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.noise.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.noise.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.repeat.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.repeat.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.ripple.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.ripple.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.scanlines.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.scanlines.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.sepia.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.sepia.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.simplex.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.simplex.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.sketch.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.sketch.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.split.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.split.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.tone.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.tone.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.tvglitch.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.tvglitch.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.vignette.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.vignette.js");
require.alias("forresto-noflo-seriously/vendor/effects/seriously.whitebalance.js", "noflo-ui-preview/deps/noflo-seriously/vendor/effects/seriously.whitebalance.js");
require.alias("forresto-noflo-seriously/vendor/transforms/seriously.camerashake.js", "noflo-ui-preview/deps/noflo-seriously/vendor/transforms/seriously.camerashake.js");
require.alias("forresto-noflo-seriously/vendor/transforms/seriously.transform3d.js", "noflo-ui-preview/deps/noflo-seriously/vendor/transforms/seriously.transform3d.js");
require.alias("forresto-noflo-seriously/component.json", "noflo-ui-preview/deps/noflo-seriously/component.json");
require.alias("forresto-noflo-seriously/components/SetFilterSource.js", "noflo-ui-preview/deps/noflo-seriously/components/SetFilterSource.js");
require.alias("forresto-noflo-seriously/components/SetFilterTarget.js", "noflo-ui-preview/deps/noflo-seriously/components/SetFilterTarget.js");
require.alias("forresto-noflo-seriously/lib/SeriouslyEffect.js", "noflo-ui-preview/deps/noflo-seriously/lib/SeriouslyEffect.js");
require.alias("forresto-noflo-seriously/components/FilterAscii.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterAscii.js");
require.alias("forresto-noflo-seriously/components/FilterBleachBypass.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterBleachBypass.js");
require.alias("forresto-noflo-seriously/components/FilterBlend.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterBlend.js");
require.alias("forresto-noflo-seriously/components/FilterChannels.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterChannels.js");
require.alias("forresto-noflo-seriously/components/FilterChroma.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterChroma.js");
require.alias("forresto-noflo-seriously/components/FilterColor.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterColor.js");
require.alias("forresto-noflo-seriously/components/FilterColorCube.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterColorCube.js");
require.alias("forresto-noflo-seriously/components/FilterDaltonize.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterDaltonize.js");
require.alias("forresto-noflo-seriously/components/FilterEdge.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterEdge.js");
require.alias("forresto-noflo-seriously/components/FilterEmboss.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterEmboss.js");
require.alias("forresto-noflo-seriously/components/FilterExposure.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterExposure.js");
require.alias("forresto-noflo-seriously/components/FilterFader.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterFader.js");
require.alias("forresto-noflo-seriously/components/FilterHex.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterHex.js");
require.alias("forresto-noflo-seriously/components/FilterHueSaturation.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterHueSaturation.js");
require.alias("forresto-noflo-seriously/components/FilterInvert.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterInvert.js");
require.alias("forresto-noflo-seriously/components/FilterLumakey.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterLumakey.js");
require.alias("forresto-noflo-seriously/components/FilterNightVision.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterNightVision.js");
require.alias("forresto-noflo-seriously/components/FilterNoise.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterNoise.js");
require.alias("forresto-noflo-seriously/components/FilterRipple.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterRipple.js");
require.alias("forresto-noflo-seriously/components/FilterScanLines.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterScanLines.js");
require.alias("forresto-noflo-seriously/components/FilterSepia.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterSepia.js");
require.alias("forresto-noflo-seriously/components/FilterSketch.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterSketch.js");
require.alias("forresto-noflo-seriously/components/FilterSplit.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterSplit.js");
require.alias("forresto-noflo-seriously/components/FilterTone.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterTone.js");
require.alias("forresto-noflo-seriously/components/FilterTVGlitch.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterTVGlitch.js");
require.alias("forresto-noflo-seriously/components/FilterVignette.js", "noflo-ui-preview/deps/noflo-seriously/components/FilterVignette.js");
require.alias("forresto-noflo-seriously/index.js", "noflo-seriously/index.js");
require.alias("noflo-noflo/component.json", "forresto-noflo-seriously/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "forresto-noflo-seriously/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "forresto-noflo-seriously/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "forresto-noflo-seriously/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "forresto-noflo-seriously/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "forresto-noflo-seriously/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "forresto-noflo-seriously/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "forresto-noflo-seriously/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "forresto-noflo-seriously/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "forresto-noflo-seriously/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "forresto-noflo-seriously/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "forresto-noflo-seriously/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "forresto-noflo-seriously/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-seriously/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "forresto-noflo-seriously/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "forresto-noflo-seriously/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "forresto-noflo-seriously/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "forresto-noflo-seriously/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "forresto-noflo-seriously/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "forresto-noflo-seriously/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("jonnor-noflo-cad/index.js", "noflo-ui-preview/deps/noflo-cad/index.js");
require.alias("jonnor-noflo-cad/component.json", "noflo-ui-preview/deps/noflo-cad/component.json");
require.alias("jonnor-noflo-cad/components/Cube.js", "noflo-ui-preview/deps/noflo-cad/components/Cube.js");
require.alias("jonnor-noflo-cad/components/RoundedRectangle.js", "noflo-ui-preview/deps/noflo-cad/components/RoundedRectangle.js");
require.alias("jonnor-noflo-cad/components/Rectangle.js", "noflo-ui-preview/deps/noflo-cad/components/Rectangle.js");
require.alias("jonnor-noflo-cad/components/LinearExtrude.js", "noflo-ui-preview/deps/noflo-cad/components/LinearExtrude.js");
require.alias("jonnor-noflo-cad/components/Translate.js", "noflo-ui-preview/deps/noflo-cad/components/Translate.js");
require.alias("jonnor-noflo-cad/components/Subtract.js", "noflo-ui-preview/deps/noflo-cad/components/Subtract.js");
require.alias("jonnor-noflo-cad/components/Intersect.js", "noflo-ui-preview/deps/noflo-cad/components/Intersect.js");
require.alias("jonnor-noflo-cad/components/Union.js", "noflo-ui-preview/deps/noflo-cad/components/Union.js");
require.alias("jonnor-noflo-cad/components/ToSTL.js", "noflo-ui-preview/deps/noflo-cad/components/ToSTL.js");
require.alias("jonnor-noflo-cad/components/ToDXF.js", "noflo-ui-preview/deps/noflo-cad/components/ToDXF.js");
require.alias("jonnor-noflo-cad/components/ToOutlinePaths.js", "noflo-ui-preview/deps/noflo-cad/components/ToOutlinePaths.js");
require.alias("jonnor-noflo-cad/components/Viewer.js", "noflo-ui-preview/deps/noflo-cad/components/Viewer.js");
require.alias("jonnor-noflo-cad/index.js", "noflo-cad/index.js");
require.alias("noflo-noflo/component.json", "jonnor-noflo-cad/deps/noflo/component.json");
require.alias("noflo-noflo/src/lib/Graph.js", "jonnor-noflo-cad/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "jonnor-noflo-cad/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "jonnor-noflo-cad/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "jonnor-noflo-cad/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "jonnor-noflo-cad/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "jonnor-noflo-cad/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "jonnor-noflo-cad/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "jonnor-noflo-cad/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "jonnor-noflo-cad/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "jonnor-noflo-cad/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/LoggingComponent.js", "jonnor-noflo-cad/deps/noflo/src/lib/LoggingComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "jonnor-noflo-cad/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "jonnor-noflo-cad/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "jonnor-noflo-cad/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "jonnor-noflo-cad/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "jonnor-noflo-cad/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "jonnor-noflo-cad/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/components/Graph.js", "jonnor-noflo-cad/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "jonnor-noflo-cad/deps/noflo/index.js");
require.alias("component-emitter/index.js", "noflo-noflo/deps/emitter/index.js");

require.alias("component-underscore/index.js", "noflo-noflo/deps/underscore/index.js");

require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("jonnor-OpenJSCADorg/openjscad.js", "jonnor-noflo-cad/deps/OpenJSCADorg/openjscad.js");
require.alias("jonnor-OpenJSCADorg/lightgl.js", "jonnor-noflo-cad/deps/OpenJSCADorg/lightgl.js");
require.alias("jonnor-OpenJSCADorg/csg.js", "jonnor-noflo-cad/deps/OpenJSCADorg/csg.js");
require.alias("jonnor-OpenJSCADorg/openjscad.js", "jonnor-noflo-cad/deps/OpenJSCADorg/index.js");
require.alias("components-underscore/underscore.js", "jonnor-OpenJSCADorg/deps/underscore/underscore.js");
require.alias("components-underscore/underscore.js", "jonnor-OpenJSCADorg/deps/underscore/index.js");
require.alias("components-underscore/underscore.js", "components-underscore/index.js");
require.alias("jonnor-OpenJSCADorg/openjscad.js", "jonnor-OpenJSCADorg/index.js");